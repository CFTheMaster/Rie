{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SOCI - The C++ Database Access Library SOCI is a database access library written in C++ that makes an illusion of embedding SQL queries in the regular C++ code, staying entirely within the Standard C++. The idea is to provide C++ programmers a way to access SQL databases in the most natural and intuitive way. If you find existing libraries too difficult for your needs or just distracting, SOCI can be a good alternative. Basic Syntax The simplest motivating code example for the SQL query that is supposed to retrieve a single row is: int id = ...; string name; int salary; sql << \"select name, salary from persons where id = \" << id, into(name), into(salary); Basic ORM The following benefits from extensive support for object-relational mapping: int id = ...; Person p; sql << \"select first_name, last_name, date_of_birth \" \"from persons where id = \" << id, into(p); Integrations Integration with STL is also supported: Rowset<string> rs = (sql.prepare << \"select name from persons\"); std::copy(rs.begin(), rs.end(), std::ostream_iterator<std::string>(std::cout, \"\\n\")); SOCI offers also extensive integration with Boost datatypes (optional, tuple and fusion) and flexible support for user-defined datatypes. Database Backends Starting from its 2.0.0 release, SOCI uses the plug-in architecture for backends - this allows to target various database servers. Currently (SOCI 4.0.0), backends for following database systems are supported: DB2 Firebird MySQL ODBC (generic backend) Oracle PostgreSQL SQLite3 The intent of the library is to cover as many database technologies as possible. For this, the project has to rely on volunteer contributions from other programmers, who have expertise with the existing database interfaces and would like to help writing dedicated backends. Language Bindings Even though SOCI is mainly a C++ library, it also allows to use it from other programming languages. Currently the package contains the Ada binding, with more bindings likely to come in the future.","title":"Home"},{"location":"#soci-the-c-database-access-library","text":"SOCI is a database access library written in C++ that makes an illusion of embedding SQL queries in the regular C++ code, staying entirely within the Standard C++. The idea is to provide C++ programmers a way to access SQL databases in the most natural and intuitive way. If you find existing libraries too difficult for your needs or just distracting, SOCI can be a good alternative.","title":"SOCI - The C++ Database Access Library"},{"location":"#basic-syntax","text":"The simplest motivating code example for the SQL query that is supposed to retrieve a single row is: int id = ...; string name; int salary; sql << \"select name, salary from persons where id = \" << id, into(name), into(salary);","title":"Basic Syntax"},{"location":"#basic-orm","text":"The following benefits from extensive support for object-relational mapping: int id = ...; Person p; sql << \"select first_name, last_name, date_of_birth \" \"from persons where id = \" << id, into(p);","title":"Basic ORM"},{"location":"#integrations","text":"Integration with STL is also supported: Rowset<string> rs = (sql.prepare << \"select name from persons\"); std::copy(rs.begin(), rs.end(), std::ostream_iterator<std::string>(std::cout, \"\\n\")); SOCI offers also extensive integration with Boost datatypes (optional, tuple and fusion) and flexible support for user-defined datatypes.","title":"Integrations"},{"location":"#database-backends","text":"Starting from its 2.0.0 release, SOCI uses the plug-in architecture for backends - this allows to target various database servers. Currently (SOCI 4.0.0), backends for following database systems are supported: DB2 Firebird MySQL ODBC (generic backend) Oracle PostgreSQL SQLite3 The intent of the library is to cover as many database technologies as possible. For this, the project has to rely on volunteer contributions from other programmers, who have expertise with the existing database interfaces and would like to help writing dedicated backends.","title":"Database Backends"},{"location":"#language-bindings","text":"Even though SOCI is mainly a C++ library, it also allows to use it from other programming languages. Currently the package contains the Ada binding, with more bindings likely to come in the future.","title":"Language Bindings"},{"location":"beyond/","text":"Beyond standard SQL Sometimes the standard SQL is not enough and database-specific syntax needs to be used. When possible and practical, SOCI provides wrappers hiding the differences between the backends and this section describes these wrappers. And, if this is still not enough, you can use the backend-specific methods directly as described below. Affected rows It can be useful to know how many rows were affected by the last SQL statement, most often when using INSERT , UPDATE or DELETE . SOCI provides statement::get_affected_rows() method allowing to do this: statement st = (sql.prepare << \"update some_table ...\"); st.execute(true); if ( !st.get_affected_rows() ) { ... investigate why no rows were modified ... } Portability note This method behaviour in case of partially executed update, i.e. when some records were updated or inserted while some other have failed to be updated or inserted, depends on the exact backend and, in the case of ODBC backend, on the exact ODBC driver used. It can return -1 , meaning that the number of rows is unknown, the number of rows actually updated or the total number of affected rows. Sequences It is common to have auto-incrementing database fields or fields whose value come from a sequence. In the latter case you need to retrieve the value of the field for a new row before inserting it into the database. In the former case, this is unnecessary but you may still want to know the value generated by the database, e.g. to use it as a foreign key in another table. So it would be useful to have a way to obtain the value of such a field. But, of course, to make life of database programmers more interesting, different products usually support either autoincrement fields or sequences but not both -- and they use different syntaxes for them, too. SOCI tries to help to deal with this unfortunate situation by providing two functions: session::get_next_sequence_value() and session::get_last_insert_id . If you know which kind of database you use, you may use only one of them: when working with sequences, the first one allows to generate the next value in a sequence and when working with autoincrement fields, the second one retrieves the last value generated for such a field for the given table. However if you use multiple SOCI backends or even just a single ODBC backend but support connecting to databases of different types, you actually must use both of them in the following way to insert a row: long long id; statement st; if ( sql.get_next_sequence_value(\"table_sequence\", id) ) { st << \"insert into table(id, f1, f2) values(:id, :f1, :f2)\", use(id), use(f1), use(f2); } else { // We're not using sequences, so don't specify the value, // it will be automatically generated by the database on insert. st << \"insert into table(f1, f2) value(:f1, :f2)\", use(f1), use(f2); // If the ID used for the above row is needed later, get it: if ( !sql.get_last_insert_id(\"table\", id) ) ... unexpected error, handle appropriately ... } Portability note These methods are currently only implemented in Firebird, MySQL, ODBC, PostgreSQL and SQLite3 backends. Beyond SOCI API As the original name of the library (Simple Oracle Call Interface) clearly stated, SOCI is intended to be a simple library, targeting the majority of needs in regular C++ application. We do not claim that everything can be done with SOCI and it was never the intent of the library. What is important, though, is that the simplicity of the library does not prevent the client applications from reaching into the low-level specifics of each database backend in order to achieve special configuration or performance goals. Most of the SOCI classes have the getBackEnd method, which returns the pointer to the actual backend object that implements the given functionality. The knowledge of the actual backend allows the client application to get access to all low-level details that are involved. blob b(sql); oracle_session_back_end * sessionBackEnd = static_cast<oracle_session_back_end *>(sql.get_back_end()); oracle_blob_back_end * blobBackEnd = static_cast<oracle_blob_back_end *>(b.get_back_end()); OCILobDisableBuffering(sessionBackEnd->svchp_, sessionBackEnd->errhp_, blobBackEnd->lobp_); The above example retrieves the rowid (\"something\" that identifies the row in the table) from the table and uses the get_back_end function to extract the actual object that implements this functionality. Assuming that it is the \"postgresql\" backend which is in use, the downcast is performed to use the postgresql_rowid_back_end interface to get the actual OID value that is a physical, low-level implementation of row identifier on PostgreSQL databases. In order for any of the above to compile, you have to explicitly #include the appropriate backend's header file. Please see the header file related to the given backend to learn what low-level handles and descriptors are available.","title":"Beyond SQL"},{"location":"beyond/#beyond-standard-sql","text":"Sometimes the standard SQL is not enough and database-specific syntax needs to be used. When possible and practical, SOCI provides wrappers hiding the differences between the backends and this section describes these wrappers. And, if this is still not enough, you can use the backend-specific methods directly as described below.","title":"Beyond standard SQL"},{"location":"beyond/#affected-rows","text":"It can be useful to know how many rows were affected by the last SQL statement, most often when using INSERT , UPDATE or DELETE . SOCI provides statement::get_affected_rows() method allowing to do this: statement st = (sql.prepare << \"update some_table ...\"); st.execute(true); if ( !st.get_affected_rows() ) { ... investigate why no rows were modified ... }","title":"Affected rows"},{"location":"beyond/#portability-note","text":"This method behaviour in case of partially executed update, i.e. when some records were updated or inserted while some other have failed to be updated or inserted, depends on the exact backend and, in the case of ODBC backend, on the exact ODBC driver used. It can return -1 , meaning that the number of rows is unknown, the number of rows actually updated or the total number of affected rows.","title":"Portability note"},{"location":"beyond/#sequences","text":"It is common to have auto-incrementing database fields or fields whose value come from a sequence. In the latter case you need to retrieve the value of the field for a new row before inserting it into the database. In the former case, this is unnecessary but you may still want to know the value generated by the database, e.g. to use it as a foreign key in another table. So it would be useful to have a way to obtain the value of such a field. But, of course, to make life of database programmers more interesting, different products usually support either autoincrement fields or sequences but not both -- and they use different syntaxes for them, too. SOCI tries to help to deal with this unfortunate situation by providing two functions: session::get_next_sequence_value() and session::get_last_insert_id . If you know which kind of database you use, you may use only one of them: when working with sequences, the first one allows to generate the next value in a sequence and when working with autoincrement fields, the second one retrieves the last value generated for such a field for the given table. However if you use multiple SOCI backends or even just a single ODBC backend but support connecting to databases of different types, you actually must use both of them in the following way to insert a row: long long id; statement st; if ( sql.get_next_sequence_value(\"table_sequence\", id) ) { st << \"insert into table(id, f1, f2) values(:id, :f1, :f2)\", use(id), use(f1), use(f2); } else { // We're not using sequences, so don't specify the value, // it will be automatically generated by the database on insert. st << \"insert into table(f1, f2) value(:f1, :f2)\", use(f1), use(f2); // If the ID used for the above row is needed later, get it: if ( !sql.get_last_insert_id(\"table\", id) ) ... unexpected error, handle appropriately ... }","title":"Sequences"},{"location":"beyond/#portability-note_1","text":"These methods are currently only implemented in Firebird, MySQL, ODBC, PostgreSQL and SQLite3 backends.","title":"Portability note"},{"location":"beyond/#beyond-soci-api","text":"As the original name of the library (Simple Oracle Call Interface) clearly stated, SOCI is intended to be a simple library, targeting the majority of needs in regular C++ application. We do not claim that everything can be done with SOCI and it was never the intent of the library. What is important, though, is that the simplicity of the library does not prevent the client applications from reaching into the low-level specifics of each database backend in order to achieve special configuration or performance goals. Most of the SOCI classes have the getBackEnd method, which returns the pointer to the actual backend object that implements the given functionality. The knowledge of the actual backend allows the client application to get access to all low-level details that are involved. blob b(sql); oracle_session_back_end * sessionBackEnd = static_cast<oracle_session_back_end *>(sql.get_back_end()); oracle_blob_back_end * blobBackEnd = static_cast<oracle_blob_back_end *>(b.get_back_end()); OCILobDisableBuffering(sessionBackEnd->svchp_, sessionBackEnd->errhp_, blobBackEnd->lobp_); The above example retrieves the rowid (\"something\" that identifies the row in the table) from the table and uses the get_back_end function to extract the actual object that implements this functionality. Assuming that it is the \"postgresql\" backend which is in use, the downcast is performed to use the postgresql_rowid_back_end interface to get the actual OID value that is a physical, low-level implementation of row identifier on PostgreSQL databases. In order for any of the above to compile, you have to explicitly #include the appropriate backend's header file. Please see the header file related to the given backend to learn what low-level handles and descriptors are available.","title":"Beyond SOCI API"},{"location":"binding/","text":"Data Binding SOCI provides mechanisms to bind local buffers for input and output data. Note: The Oracle documentation uses two terms: defining (for instructing the library where the output data should go) and binding (for the input data and input/output PL/SQL parameters). For the sake of simplicity, SOCI uses the term binding for both of these. Binding output data (into) The into expression is used to add binding information to the statement: int count; sql << \"select count(*) from person\", into(count); string name; sql << \"select name from person where id = 7\", into(name); In the above examples, some data is retrieved from the database and transmitted into the given local variable. There should be as many into elements as there are expected columns in the result (see dynamic resultset binding for the exception to this rule). Binding input data (use) The use expression associates the SQL placeholder (written with colon) with the local data: int val = 7; sql << \"insert into numbers(val) values(:val)\", use(val); In the above statement, the first \"val\" is a column name (assuming that there is appropriate table numbers with this column), the second \"val\" (with colon) is a placeholder and its name is ignored here, and the third \"val\" is a name of local variable. To better understand the meaning of each \"val\" above, consider also: int number = 7; sql << \"insert into numbers(val) values(:blabla)\", use(number); Both examples above will insert the value of some local variable into the table numbers - we say that the local variable is used in the SQL statement. There should be as many use elements as there are parameters used in the SQL query. Object lifetime and immutability SOCI assumes that local variables provided as use elements live at least as long at it takes to execute the whole statement. In short statement forms like above, the statement is executed sometime at the end of the full expression and the whole process is driven by the invisible temporary object handled by the library. If the data provided by user comes from another temporary variable, it might be possible for the compiler to arrange them in a way that the user data will be destroyed before the statement will have its chance to execute, referencing objects that no longer exist: // Dangerous code! string getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(getNameFromSomewhere()); In the above example, the data passed to the database comes from the temporary variable that is a result of call to getNameFromSomewhere - this should be avoided and named variables should be used to ensure safe lifetime relations: // Safe code string getNameFromSomewhere(); string name = getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(name); It is still possible to provide const data for use elements. Note that some database servers, like Oracle, allow PL/SQL procedures to modify their in/out parameters - this is detected by the SOCI library and an error is reported if the database attempts to modify the use element that holds const data. The above example can be ultimately written in the following way: // Safe and efficient code string getNameFromSomewhere(); string const& name = getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(name); Binding by position If there is more output or input \"holes\" in the single statement, it is possible to use many into and use expressions, separated by commas, where each expression will be responsible for the consecutive \"hole\" in the statement: string firstName = \"John\", lastName = \"Smith\"; int personId = 7; sql << \"insert into person(id, firstname, lastname) values(:id, :fn, :ln)\", use(personId), use(firstName), use(lastName); sql << \"select firstname, lastname from person where id = :id\", into(firstName), into(lastName), use(personId); In the code above, the order of \"holes\" in the SQL statement and the order of into and use expression should match. Binding by name The SQL placeholders that have their names (with colon) can be bound by name to clearly associate the local variable with the given placeholder. This explicit naming allows to use different order of elements: string firstName = \"John\", lastName = \"Smith\"; int personId = 7; sql << \"insert into person(id, firstname, lastname) values(:id, :fn, :ln)\", use(firstName, \"fn\"), use(lastName, \"ln\"), use(personId, \"id\"); or bind the same local data to many \"holes\" at the same time: string addr = \"...\"; sql << \"update person\" \" set mainaddress = :addr, contactaddress = :addr\" \" where id = 7\", use(addr, \"addr\"); Bulk operations Bulk operations allow the user to bind, as into or use element, whole vectors of objects. This allows the database backend to optimize access and data transfer and benefit from the fact that std::vector stores data in contiguous memory blocks (the actual optimization depends on the backend and the capability of the underlying data base server). It is possible to use the vector as a data source: std::vector<int> v; // ... sql << \"insert into t ...\", use(v); as well as a destination: std::vector<int> v; v.resize(100); sql << \"select ...\", into(v); In the latter case the initial size of the vector defines the maximum number of data elements that the user is willing to accept and after executing the query the vector will be automatically resized to reflect that actual number of rows that were read and transmitted. That is, the vector will be automatically shrunk if the amount of data that was available was smaller than requested. It is also possible to operate on the chosen sub-range of the vector: std::vector<int> v; // ... std::size_t begin = ...; std::size_t end = ...; sql << \"insert into t ...\", use(v, begin, end); // or: sql << \"select ...\", into(v, begin, end); Above, only the sub-range of the vector is used for data transfer and in the case of into operation, the end variable will be automatically adjusted to reflect the amount of data that was actually transmitted, but the vector object as a whole will retain its initial size. Bulk operations can also involve indicators, see below. Bulk operations support user-defined data types, if they have appropriate conversion routines defined.","title":"Data Binding"},{"location":"binding/#data-binding","text":"SOCI provides mechanisms to bind local buffers for input and output data. Note: The Oracle documentation uses two terms: defining (for instructing the library where the output data should go) and binding (for the input data and input/output PL/SQL parameters). For the sake of simplicity, SOCI uses the term binding for both of these.","title":"Data Binding"},{"location":"binding/#binding-output-data-into","text":"The into expression is used to add binding information to the statement: int count; sql << \"select count(*) from person\", into(count); string name; sql << \"select name from person where id = 7\", into(name); In the above examples, some data is retrieved from the database and transmitted into the given local variable. There should be as many into elements as there are expected columns in the result (see dynamic resultset binding for the exception to this rule).","title":"Binding output data (into)"},{"location":"binding/#binding-input-data-use","text":"The use expression associates the SQL placeholder (written with colon) with the local data: int val = 7; sql << \"insert into numbers(val) values(:val)\", use(val); In the above statement, the first \"val\" is a column name (assuming that there is appropriate table numbers with this column), the second \"val\" (with colon) is a placeholder and its name is ignored here, and the third \"val\" is a name of local variable. To better understand the meaning of each \"val\" above, consider also: int number = 7; sql << \"insert into numbers(val) values(:blabla)\", use(number); Both examples above will insert the value of some local variable into the table numbers - we say that the local variable is used in the SQL statement. There should be as many use elements as there are parameters used in the SQL query.","title":"Binding input data (use)"},{"location":"binding/#object-lifetime-and-immutability","text":"SOCI assumes that local variables provided as use elements live at least as long at it takes to execute the whole statement. In short statement forms like above, the statement is executed sometime at the end of the full expression and the whole process is driven by the invisible temporary object handled by the library. If the data provided by user comes from another temporary variable, it might be possible for the compiler to arrange them in a way that the user data will be destroyed before the statement will have its chance to execute, referencing objects that no longer exist: // Dangerous code! string getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(getNameFromSomewhere()); In the above example, the data passed to the database comes from the temporary variable that is a result of call to getNameFromSomewhere - this should be avoided and named variables should be used to ensure safe lifetime relations: // Safe code string getNameFromSomewhere(); string name = getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(name); It is still possible to provide const data for use elements. Note that some database servers, like Oracle, allow PL/SQL procedures to modify their in/out parameters - this is detected by the SOCI library and an error is reported if the database attempts to modify the use element that holds const data. The above example can be ultimately written in the following way: // Safe and efficient code string getNameFromSomewhere(); string const& name = getNameFromSomewhere(); sql << \"insert into person(name) values(:n)\", use(name);","title":"Object lifetime and immutability"},{"location":"binding/#binding-by-position","text":"If there is more output or input \"holes\" in the single statement, it is possible to use many into and use expressions, separated by commas, where each expression will be responsible for the consecutive \"hole\" in the statement: string firstName = \"John\", lastName = \"Smith\"; int personId = 7; sql << \"insert into person(id, firstname, lastname) values(:id, :fn, :ln)\", use(personId), use(firstName), use(lastName); sql << \"select firstname, lastname from person where id = :id\", into(firstName), into(lastName), use(personId); In the code above, the order of \"holes\" in the SQL statement and the order of into and use expression should match.","title":"Binding by position"},{"location":"binding/#binding-by-name","text":"The SQL placeholders that have their names (with colon) can be bound by name to clearly associate the local variable with the given placeholder. This explicit naming allows to use different order of elements: string firstName = \"John\", lastName = \"Smith\"; int personId = 7; sql << \"insert into person(id, firstname, lastname) values(:id, :fn, :ln)\", use(firstName, \"fn\"), use(lastName, \"ln\"), use(personId, \"id\"); or bind the same local data to many \"holes\" at the same time: string addr = \"...\"; sql << \"update person\" \" set mainaddress = :addr, contactaddress = :addr\" \" where id = 7\", use(addr, \"addr\");","title":"Binding by name"},{"location":"binding/#bulk-operations","text":"Bulk operations allow the user to bind, as into or use element, whole vectors of objects. This allows the database backend to optimize access and data transfer and benefit from the fact that std::vector stores data in contiguous memory blocks (the actual optimization depends on the backend and the capability of the underlying data base server). It is possible to use the vector as a data source: std::vector<int> v; // ... sql << \"insert into t ...\", use(v); as well as a destination: std::vector<int> v; v.resize(100); sql << \"select ...\", into(v); In the latter case the initial size of the vector defines the maximum number of data elements that the user is willing to accept and after executing the query the vector will be automatically resized to reflect that actual number of rows that were read and transmitted. That is, the vector will be automatically shrunk if the amount of data that was available was smaller than requested. It is also possible to operate on the chosen sub-range of the vector: std::vector<int> v; // ... std::size_t begin = ...; std::size_t end = ...; sql << \"insert into t ...\", use(v, begin, end); // or: sql << \"select ...\", into(v, begin, end); Above, only the sub-range of the vector is used for data transfer and in the case of into operation, the end variable will be automatically adjusted to reflect the amount of data that was actually transmitted, but the vector object as a whole will retain its initial size. Bulk operations can also involve indicators, see below. Bulk operations support user-defined data types, if they have appropriate conversion routines defined.","title":"Bulk operations"},{"location":"boost/","text":"Boost Integration The SOCI user code can be easily integrated with the Boost library thanks to the very flexible type conversion facility. The integration with Boost types is optional and is not enabled by default, which means that SOCI can also be compiled and used without any dependency on Boost. In order to enable the support for any of the above types, the user needs to either include one of these headers: #include <boost-optional.h> #include <boost-tuple.h> #include <boost-fusion.h> #include <boost-gregorian-date.h> or to define the SOCI_USE_BOOST macro before including the soci.h main header file. Boost.Optional boost::optional<T> provides an alternative way to support the null data condition and as such relieves the user from necessity to handle separate indicator values. The boost::optional<T> objects can be used everywhere where the regular user provided values are expected. Example: boost::optional<string> name; sql << \"select name from person where id = 7\", into(name); if (name.is_initialized()) { // OK, the name was retrieved and is not-null cout << \"The name is \" << name.get(); } else { // the name is null } The boost::optional<T> objects are fully supported for both into and use elements, in both single and vector forms. They can be also used for user-defined data types. Boost.Tuple boost::tuple<T1, ...> allows to work with whole rows of information and in some cases can be more convenient to use than the more dynamically-oriented row type. boost::tuple<string, string, int> person; sql << \"select name, phone, salary from persons where ...\", into(person); Tuples are supported for both into and use elements. They can be used with rowset as well. Tuples can be also composed with boost::optional<T> boost::tuple<string, boost::optional<string>, int> person; sql << \"select name, phone, salary from persons where ...\", into(person); if (person.get<1>().is_initialized()) { // the given person has a phone number } else { // this person does not have a phone number } Boost.Fusion The boost::fusion::vector types are supported in the same way as tuples. Note: Support for boost::fusion::vector is enabled only if the detected Boost version is at least 1.35. Boost.DateTime The boost::gregorian::date is provided as a conversion for base type std::tm and can be used as a replacement for it.","title":"Boost"},{"location":"boost/#boost-integration","text":"The SOCI user code can be easily integrated with the Boost library thanks to the very flexible type conversion facility. The integration with Boost types is optional and is not enabled by default, which means that SOCI can also be compiled and used without any dependency on Boost. In order to enable the support for any of the above types, the user needs to either include one of these headers: #include <boost-optional.h> #include <boost-tuple.h> #include <boost-fusion.h> #include <boost-gregorian-date.h> or to define the SOCI_USE_BOOST macro before including the soci.h main header file.","title":"Boost Integration"},{"location":"boost/#boostoptional","text":"boost::optional<T> provides an alternative way to support the null data condition and as such relieves the user from necessity to handle separate indicator values. The boost::optional<T> objects can be used everywhere where the regular user provided values are expected. Example: boost::optional<string> name; sql << \"select name from person where id = 7\", into(name); if (name.is_initialized()) { // OK, the name was retrieved and is not-null cout << \"The name is \" << name.get(); } else { // the name is null } The boost::optional<T> objects are fully supported for both into and use elements, in both single and vector forms. They can be also used for user-defined data types.","title":"Boost.Optional"},{"location":"boost/#boosttuple","text":"boost::tuple<T1, ...> allows to work with whole rows of information and in some cases can be more convenient to use than the more dynamically-oriented row type. boost::tuple<string, string, int> person; sql << \"select name, phone, salary from persons where ...\", into(person); Tuples are supported for both into and use elements. They can be used with rowset as well. Tuples can be also composed with boost::optional<T> boost::tuple<string, boost::optional<string>, int> person; sql << \"select name, phone, salary from persons where ...\", into(person); if (person.get<1>().is_initialized()) { // the given person has a phone number } else { // this person does not have a phone number }","title":"Boost.Tuple"},{"location":"boost/#boostfusion","text":"The boost::fusion::vector types are supported in the same way as tuples. Note: Support for boost::fusion::vector is enabled only if the detected Boost version is at least 1.35.","title":"Boost.Fusion"},{"location":"boost/#boostdatetime","text":"The boost::gregorian::date is provided as a conversion for base type std::tm and can be used as a replacement for it.","title":"Boost.DateTime"},{"location":"connections/","text":"Connections The session class encapsulates the database connection and other backend-related details, which are common to all the statements that will be later executed. It has a couple of overloaded constructors. Using backend factory The most basic one expects two parameters: the requested backend factory object and the generic connection string, which meaning is backend-dependent. Example: session sql(oracle, \"service=orcl user=scott password=tiger\"); Another example might be: session sql(postgresql, \"dbname=mydb\"); Above, the sql object is a local (automatic) object that encapsulates the connection. This session constructor either connects successfully, or throws an exception. Portability note In case of SOCI linked against DLLs on Windows, the factory objects are not exported from the DLLs. In order to avoid linker errors, access factory objects via dedicated backend functions provided (eg. factory_postgresql() ). Using loadable backends Dynamically loadable backends are compiled as shared libraries and allow to select backends at run-time by name. The usage is similar to the above, but instead of providing the factory object, the backend name is expected: session sql(\"postgresql\", \"dbname=mydb\"); For convenience, the URL-like form that combines both the backend name with connection parameters is supported as well: session sql(\"postgresql://dbname=mydb\"); The last two constructors described above try to locate the shared library with the name libsoci_ABC.so (or libsoci_ABC.dll on Windows), where ABC is the backend name. In the above examples, the expected library name will be libsoci_postgresql.so for Unix-like systems. The most general form of the constructor takes a single object of connection_parameters type which contains a pointer to the backend to use, the connection string and also any connection options. Using this constructor is the only way to pass any non-default options to the backend. For example, to suppress any interactive prompts when using ODBC backend you could do: connection_parameters parameters(\"odbc\", \"DSN=mydb\"); parameters.set_option(odbc_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters); Notice that you need to #include<soci-odbc.h> to obtain the option name declaration. The existing options are described in the backend-specific part of the documentation. IBM DB2 driver for ODBC and CLI also support the driver completion requests. So, the DB2 backend provides similar option db2_option_driver_complete with #include <soci-db2.h> required to obtain the option name. Environment configuration The SOCI_BACKENDS_PATH environment variable defines the set of paths where the shared libraries will be searched for. There can be many paths, separated by colons, and they are used from left to right until the library with the appropriate name is found. If this variable is not set or is empty, the current directory is used as a default path for dynamically loaded backends. Using registered backends The run-time selection of backends is also supported with libraries linked statically. Each backend provides a separate function of the form register_factory_*name* , where *name* is a backend name. Thus: extern \"C\" void register_factory_postgresql(); // ... register_factory_postgresql(); session sql(\"postgresql://dbname=mydb\"); The above example registers the backend for PostgreSQL and later creates the session object for that backend. This form is provided for those projects that prefer static linking but still wish to benefit from run-time backend selection. An alternative way to set up the session is to create it in the disconnected state and connect later: session sql; // some time later: sql.open(postgresql, \"dbname=mydb\"); // or: sql.open(\"postgresql://dbname=mydb\"); // or also: connection_parameters parameters(\"postgresql\", \"dbname=mydb\"); sql.open(parameters); The rules for backend naming are the same as with the constructors described above. The session can be also explicitly close d and reconnect ed, which can help with basic session error recovery. The reconnect function has no parameters and attempts to use the same values as those provided with earlier constructor or open calls. See also the page devoted to multithreading for a detailed description of connection pools. It is possible to have many active session s at the same time, even using different backends. Portability note The following backend factories are currently (as of 3.1.0 release) available: mysql (requires #include \"soci-mysql.h\" ) oracle (requires #include \"soci-oracle.h\" ) postgresql (requires #include \"soci-postgresql.h\" ) The following backends are also available, with various levels of completeness: sqlite3 (requires #include \"soci-sqlite3.h\" ) odbc (requires #include \"soci-odbc.h\" ) firebird (requires #include \"soci-firebird.h\" ) db2 (requires #include \"soci-db2.h\" ) Connection failover The failover_callback interface can be used as a callback channel for notifications of events that are automatically processed when the session is forcibly closed due to connectivity problems. The user can override the following methods: // Called when the failover operation has started, // after discovering connectivity problems. virtual void started(); // Called after successful failover and creating a new connection; // the sql parameter denotes the new connection and allows the user // to replay any initial sequence of commands (like session configuration). virtual void finished(session & sql); // Called when the attempt to reconnect failed, // if the user code sets the retry parameter to true, // then new connection will be attempted; // the newTarget connection string is a hint that can be ignored // by external means. virtual void failed(bool & retry, std::string & newTarget); // Called when there was a failure that prevents further failover attempts. virtual void aborted(); The user-provided callback implementation can be installed (or reset) with: sql.set_failover_callback(myCallback); Portability note The failover_callback functionality is currently supported only by PostgreSQL and Oracle backends (in the latter case the failover mechanism is governed by the Oracle-specific cluster configuration settings). Other backends allow the callback object to be installed, but will ignore it and will not generate notification calls.","title":"Connections"},{"location":"connections/#connections","text":"The session class encapsulates the database connection and other backend-related details, which are common to all the statements that will be later executed. It has a couple of overloaded constructors.","title":"Connections"},{"location":"connections/#using-backend-factory","text":"The most basic one expects two parameters: the requested backend factory object and the generic connection string, which meaning is backend-dependent. Example: session sql(oracle, \"service=orcl user=scott password=tiger\"); Another example might be: session sql(postgresql, \"dbname=mydb\"); Above, the sql object is a local (automatic) object that encapsulates the connection. This session constructor either connects successfully, or throws an exception.","title":"Using backend factory"},{"location":"connections/#portability-note","text":"In case of SOCI linked against DLLs on Windows, the factory objects are not exported from the DLLs. In order to avoid linker errors, access factory objects via dedicated backend functions provided (eg. factory_postgresql() ).","title":"Portability note"},{"location":"connections/#using-loadable-backends","text":"Dynamically loadable backends are compiled as shared libraries and allow to select backends at run-time by name. The usage is similar to the above, but instead of providing the factory object, the backend name is expected: session sql(\"postgresql\", \"dbname=mydb\"); For convenience, the URL-like form that combines both the backend name with connection parameters is supported as well: session sql(\"postgresql://dbname=mydb\"); The last two constructors described above try to locate the shared library with the name libsoci_ABC.so (or libsoci_ABC.dll on Windows), where ABC is the backend name. In the above examples, the expected library name will be libsoci_postgresql.so for Unix-like systems. The most general form of the constructor takes a single object of connection_parameters type which contains a pointer to the backend to use, the connection string and also any connection options. Using this constructor is the only way to pass any non-default options to the backend. For example, to suppress any interactive prompts when using ODBC backend you could do: connection_parameters parameters(\"odbc\", \"DSN=mydb\"); parameters.set_option(odbc_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters); Notice that you need to #include<soci-odbc.h> to obtain the option name declaration. The existing options are described in the backend-specific part of the documentation. IBM DB2 driver for ODBC and CLI also support the driver completion requests. So, the DB2 backend provides similar option db2_option_driver_complete with #include <soci-db2.h> required to obtain the option name.","title":"Using loadable backends"},{"location":"connections/#environment-configuration","text":"The SOCI_BACKENDS_PATH environment variable defines the set of paths where the shared libraries will be searched for. There can be many paths, separated by colons, and they are used from left to right until the library with the appropriate name is found. If this variable is not set or is empty, the current directory is used as a default path for dynamically loaded backends.","title":"Environment configuration"},{"location":"connections/#using-registered-backends","text":"The run-time selection of backends is also supported with libraries linked statically. Each backend provides a separate function of the form register_factory_*name* , where *name* is a backend name. Thus: extern \"C\" void register_factory_postgresql(); // ... register_factory_postgresql(); session sql(\"postgresql://dbname=mydb\"); The above example registers the backend for PostgreSQL and later creates the session object for that backend. This form is provided for those projects that prefer static linking but still wish to benefit from run-time backend selection. An alternative way to set up the session is to create it in the disconnected state and connect later: session sql; // some time later: sql.open(postgresql, \"dbname=mydb\"); // or: sql.open(\"postgresql://dbname=mydb\"); // or also: connection_parameters parameters(\"postgresql\", \"dbname=mydb\"); sql.open(parameters); The rules for backend naming are the same as with the constructors described above. The session can be also explicitly close d and reconnect ed, which can help with basic session error recovery. The reconnect function has no parameters and attempts to use the same values as those provided with earlier constructor or open calls. See also the page devoted to multithreading for a detailed description of connection pools. It is possible to have many active session s at the same time, even using different backends.","title":"Using registered backends"},{"location":"connections/#portability-note_1","text":"The following backend factories are currently (as of 3.1.0 release) available: mysql (requires #include \"soci-mysql.h\" ) oracle (requires #include \"soci-oracle.h\" ) postgresql (requires #include \"soci-postgresql.h\" ) The following backends are also available, with various levels of completeness: sqlite3 (requires #include \"soci-sqlite3.h\" ) odbc (requires #include \"soci-odbc.h\" ) firebird (requires #include \"soci-firebird.h\" ) db2 (requires #include \"soci-db2.h\" )","title":"Portability note"},{"location":"connections/#connection-failover","text":"The failover_callback interface can be used as a callback channel for notifications of events that are automatically processed when the session is forcibly closed due to connectivity problems. The user can override the following methods: // Called when the failover operation has started, // after discovering connectivity problems. virtual void started(); // Called after successful failover and creating a new connection; // the sql parameter denotes the new connection and allows the user // to replay any initial sequence of commands (like session configuration). virtual void finished(session & sql); // Called when the attempt to reconnect failed, // if the user code sets the retry parameter to true, // then new connection will be attempted; // the newTarget connection string is a hint that can be ignored // by external means. virtual void failed(bool & retry, std::string & newTarget); // Called when there was a failure that prevents further failover attempts. virtual void aborted(); The user-provided callback implementation can be installed (or reset) with: sql.set_failover_callback(myCallback);","title":"Connection failover"},{"location":"connections/#portability-note_2","text":"The failover_callback functionality is currently supported only by PostgreSQL and Oracle backends (in the latter case the failover mechanism is governed by the Oracle-specific cluster configuration settings). Other backends allow the callback object to be installed, but will ignore it and will not generate notification calls.","title":"Portability note"},{"location":"errors/","text":"Errors All DB-related errors manifest themselves as exceptions of type soci_error , which is derived from std::runtime_error . This allows to handle database errors within the standard exception framework: int main() { try { // regular code } catch (std::exception const & e) { cerr << \"Bang! \" << e.what() << endl; } } The soci_error class exposes two public functions: The get_error_message() const function returns std::string with a brief error message, without any additional information that can be present in the full error message returned by what() . The get_error_category() const function returns one of the error_category enumeration values, which allows the user to portably react to some subset of common errors. For example, connection_error or constraint_violation have meanings that are common across different database backends, even though the actual mechanics might differ. Portability Error categories are not universally supported and there is no claim that all possible errors that are reported by the database server are covered or interpreted. If the error category is not recognized by the backend, it defaults to unknown . MySQL The MySQL backend can throw instances of the mysql_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the MySQL error code (as returned by mysql_errno() ): int main() { try { // regular code } catch (soci::mysql_soci_error const & e) { cerr << \"MySQL error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } } Oracle The Oracle backend can also throw the instances of the oracle_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the Oracle error code: int main() { try { // regular code } catch (soci::oracle_soci_error const & e) { cerr << \"Oracle error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } } PostgreSQL The PostgreSQL backend can also throw the instances of the postgresql_soci_error , which is publicly derived from soci_error and has an additional public sqlstate() member function returning the five-character \"SQLSTATE\" error code: int main() { try { // regular code } catch (soci::postgresql_soci_error const & e) { cerr << \"PostgreSQL error: \" << e.sqlstate() << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } }","title":"Errors"},{"location":"errors/#errors","text":"All DB-related errors manifest themselves as exceptions of type soci_error , which is derived from std::runtime_error . This allows to handle database errors within the standard exception framework: int main() { try { // regular code } catch (std::exception const & e) { cerr << \"Bang! \" << e.what() << endl; } } The soci_error class exposes two public functions: The get_error_message() const function returns std::string with a brief error message, without any additional information that can be present in the full error message returned by what() . The get_error_category() const function returns one of the error_category enumeration values, which allows the user to portably react to some subset of common errors. For example, connection_error or constraint_violation have meanings that are common across different database backends, even though the actual mechanics might differ.","title":"Errors"},{"location":"errors/#portability","text":"Error categories are not universally supported and there is no claim that all possible errors that are reported by the database server are covered or interpreted. If the error category is not recognized by the backend, it defaults to unknown .","title":"Portability"},{"location":"errors/#mysql","text":"The MySQL backend can throw instances of the mysql_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the MySQL error code (as returned by mysql_errno() ): int main() { try { // regular code } catch (soci::mysql_soci_error const & e) { cerr << \"MySQL error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } }","title":"MySQL"},{"location":"errors/#oracle","text":"The Oracle backend can also throw the instances of the oracle_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the Oracle error code: int main() { try { // regular code } catch (soci::oracle_soci_error const & e) { cerr << \"Oracle error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } }","title":"Oracle"},{"location":"errors/#postgresql","text":"The PostgreSQL backend can also throw the instances of the postgresql_soci_error , which is publicly derived from soci_error and has an additional public sqlstate() member function returning the five-character \"SQLSTATE\" error code: int main() { try { // regular code } catch (soci::postgresql_soci_error const & e) { cerr << \"PostgreSQL error: \" << e.sqlstate() << \" \" << e.what() << endl; } catch (soci::exception const & e) { cerr << \"Some other error: \" << e.what() << endl; } }","title":"PostgreSQL"},{"location":"faq/","text":"FAQ This part of the documentation is supposed to gather in a single place the usual questions (and answers) about SOCI with regard to the design decisions that have shaped it. Q: Why \"SOCI\"? SOCI was initially developed in the environment where Oracle was the main database technology in use. As a wrapper for the native OCI API (Oracle Call Interface), the name \"Simple Oracle Call Interface\" was quite obvious - until the 2.0 release, when the internal architecture was largely redesigned to allow the use of backends that support other database servers. We have kept the same name to indicate that Oracle is the main supported technology in the sense that the library includes only those features that were naturally implemented in Oracle. With the 2.1 release of the library, two new backends were added (MySQL and SQLite3) and we decided to drop the original full name so that new users looking for a library supporting any of these simpler libraries are not discouraged by seeing \"Oracle\" somewhere in the name. The other possible interpretation was \"Syntax Oriented Call Interface\", which stresses the fact that SOCI was built to support the most natural and easy interface for the user that is similar to the Embedded SQL concept (see below). But on the other hand, SOCI also provides other features (like object-relational mapping) and as a whole it is not just \"emulator\" of the Embedded SQL. With all these considerations in mind, SOCI is just \"SOCI - The C++ Database Access Library\". Still, Oracle is considered to be the main driving server technology in terms of the set of features that are supported by the library. This also means that backends for other servers might need to work around some of the imposed idioms and protocols, but already available and well-working PostgreSQL, MySQL and SQLite3 backends show that it's actually not that bad and the abstractions provided by the library are actually very universal. Of course, some of the features that were provided for Oracle might not be supported for all other servers, but we think that it's better to have one leading technology (where at least one group is fully happy) instead of some \"common denominator\" for all databases (where nobody is happy). Q: Where the basic SOCI syntax comes from? The basic SOCI syntax was inspired by the Embedded SQL, which is part of the SQL standard, supported by the major DB technologies and even available as built-in part of the languages used in some DB-oriented integrated development environments. The term \"Embedded SQL\" is enough for Google to spit millions of references - one of the typical examples is: { int a; /* ... */ EXEC SQL SELECT salary INTO :a FROM Employee WHERE SSN=876543210; /* ... */ printf(\"The salary is %d\\n\", a); /* ... */ } The above is not a regular C (nor C++) code, of course. It's the mix of C and SQL and there is a separate, pecialized preprocessor needed to convert it to something that the actual C (or C++) compiler will be able to understand. This means that the compilation of the program using embedded SQL is two-phase: preprocess the embedded SQL part and compile the result. This two-phase development is quite troublesome, especially when it comes to debugging. Yet, the advantage of it is that the code expresses the programmer's intents in a very straightforward way: read something from the database and put it into the local variable. Just like that. The SOCI library was born as an answer to the following question: is it possible to have the same expressive power without the disadvantages of two-phase builds? The following was chosen to be the basic SOCI syntax that can mirror the above Embedded SQL example: int a; sql << \"SELECT salary FROM Employee WHERE SSN=876543210\", into(a); (as you see, SOCI changes the order of elements a little bit, so that the SQL query is separate and not mixed with other elements) Apart from mimicking the Embedded SQL techniques in the regular, fully standard C++ code, the above syntax has the following benefit: it is minimal with respect to what has to be said. Every single piece above is needed and expresses something important, like: which session should be used (the client can be connected to many databases at the same time) - here, the sql object encapsulates the session, what SQL query should be executed - here, it's the string literal, but it could be also a std::string variable, where to put the result - here, the local variable a will receive the result. Everything else is just a couple of operators that allow to treat the whole as a single expression. It's rather difficult to remove anything from this example. The fact that the basic SOCI syntax is minimal (but without being obscure at the same time, see below) means that the programmer does not need to bother with unnecessary noise that some other database libraries impose. We hope that after having written one line of code like above by themselves, most programmers will react with something like \"how obvious!\" instead of \"how advanced!\". Q: Why should I use SQL queries as strings in my program? I prefer the query to be generated or composed piece-by-piece by separate functions. First, you don't need to use SQL queries as string literals. In bigger projects it is a common practice to store SQL queries externally (in a file, or in a... database) and load them before use. This means that they are not necessarily expected to appear in the program code, as they do in our simple code examples and the advantage of separating them from the source code of the main program is, among others, the possibility to optimize and tune the SQL queries without recompilation and relinking of the whole program. What is the most important, though, is that SOCI does not try to mess with the text of the query (apart from very few cases), which means that the database server will get exactly the same text of the query as is used in the program. The advantage of this is that there is no new SQL-like (or even SQL- un like) syntax that you would need to learn, and also that it's much easier to convince a typical DBA to help with SQL tuning or other specialized activities, if he is given the material in the form that is not polluted with any foreign abstractions. Q: Why not some stream-like interface, which is well-known to all C++ programmers? An example of the stream-like interface might be something like this (this is imaginary syntax, not supported by SOCI): sql.exec(\"select a, b, c from some_table\"); while (!sql.eof()) { int a, b, c; sql >> a >> b >> c; // ... } We think that the data stored in the relational database should be treated as a set of relations - which is exactly what it is. This means that what is read from the database as a result of some SQL query is a set of rows . This set might be ordered, but it is still a set of rows, not a uniformly flat list of values. This distinction might seem to be unnecessarily low-level and that the uniform stream-like presentation of data is more preferable, but it's actually the other way round - the set of rows is something more structured - and that structure was designed into the database - than the flat stream and is therefore less prone to programming errors like miscounting the number of values that is expected in each row. Consider the following programming error: sql.exec(\"select a, b from some_table\"); // only TWO columns while (!sql.eof()) { int a, b, c; sql >> a >> b >> c; // this causes \"row-tearing\" // ... } \"How to detect the end of each line in a file\" is a common beginner's question that relates to the use of IOStreams - and this common question clearly shows that for the record-oriented data the stream is not an optimal abstraction. Of course, we don't claim that IOStreams is bad - but we do insist that the record-oriented data is better manipulated in a way that is also record-aware. Having said that, we have provided some form of the stream-like interface, but with the important limitation that the stream is always bound to the single row, so that the row-tearing effect is not possible. In other words, data returned from the database is still structured into rows, but each row can be separately traversed like a stream. We hope that it provides a good balance between convenience and code safety. Q: Why use indicators instead of some special value to discover that something is null? Some programmers are used to indicating the null value by using some special (which means: \"unlikely\" to be ever used) value - for example, to use the smallest integer value to indicate null integer. Or to use empty string to indicate null string. And so on. We think that it's completely wrong . Null (in the database sense) is an information about the data. It describes the state of the data and if it's null, then there's no data at all . Nothing. Null. It does not make any sense to talk about some special value if in fact there is no value at all - especially if we take into account that, for example, the smallest integer value (or whatever else you choose as the \"special\" value) might not be that special in the given application or domain. Thus, SOCI uses a separate indicators to describe the state of exchanged data. It also has an additional benefit of allowing the library to convey more than two states (null and not null). Indeed, the SOCI library uses indicators also to report that the data was read, but truncated (this applies to strings when reading to fixed-length character arrays). Truncation is also an information about the data and as such it's better to have it in addition to the data, not as part of it. Having said that, it is important to point at the Integration with Boost that allows to use boost::optional<T> to conveniently pack together the data and the information about its state. Q: Overloaded comma operator is just obfuscation, I don't like it. Well, consider the following: \"Send the query X to the server Y and put result into variable Z.\" Above, the \"and\" plays a role of the comma. Even if overloading the comma operator is not a very popular practice in C++, some libraries do this, achieving terse and easy to learn syntax. We are pretty sure that in SOCI the comma operator was overloaded with a good effect. Q: The operator<< provides a bad abstraction for the \"input\" statements. Indeed, the operator<< in the basic SOCI syntax shows that something (the query) is sent somewhere (to the server). Some people don't like this, especially when the \"select\" statements are involved. If the high-level idea is to read data from somewhere, then operator<< seems unintuitive to the die-hard IOStreams users. The fact is, however, that the code containing SQL statement already indicates that there is a client-server relationship with some other software component (very likely remote). In such code it does not make any sense to pretend that the communication is one-way only, because it's clear that even the \"select\" statements need to be sent somewhere. This approach is also more uniform and allows to cover other statements like \"drop table\" or alike, where no data is expected to be exchanged at all (and therefore the IOStreams analogies for data exchange have no sense at all). No matter what is the kind of the SQL statement, it is sent to the server and this \"sending\" justifies the choice of operator<< . Using different operators ( operator>> and operator<< ) as a way of distinguishing between different high-level ideas ( reading and writing from the data store, respectively) does make sense on much higher level of abstraction, where the SQL statement itself is already hidden - and we do encourage programmers to use SOCI for implementing such high-level abstractions. For this, the object-relational mapping facilities available in SOCI might prove to be a valuable tool as well, as an effective bridge between the low-level world of SQL statements and the high-level world of user-defined abstract data types. Q: Why the Boost license? We decided to use the Boost license , because it's well recognized in the C++ community, allows us to keep our minimum copyrights, and at the same time allows SOCI to be safely used in commercial projects, without imposing concerns (or just plainuncertainty) typical to other open source licenses, like GPL. We also hope that by choosing the Boost license we have made the life easier for both us and our users. It saves us from answering law-related questions that were already answered on the Boost license info page and it should also give more confidence to our users - especially to those of them, who already accepted the conditions of the Boost license - the just have one license less to analyze. Still, if for any reason the conditions of this license are not acceptable, we encourage the users to contact us directly (see links on the relevant SOCI page) to discuss any remaining concerns.","title":"FAQ"},{"location":"faq/#faq","text":"This part of the documentation is supposed to gather in a single place the usual questions (and answers) about SOCI with regard to the design decisions that have shaped it.","title":"FAQ"},{"location":"faq/#q-why-soci","text":"SOCI was initially developed in the environment where Oracle was the main database technology in use. As a wrapper for the native OCI API (Oracle Call Interface), the name \"Simple Oracle Call Interface\" was quite obvious - until the 2.0 release, when the internal architecture was largely redesigned to allow the use of backends that support other database servers. We have kept the same name to indicate that Oracle is the main supported technology in the sense that the library includes only those features that were naturally implemented in Oracle. With the 2.1 release of the library, two new backends were added (MySQL and SQLite3) and we decided to drop the original full name so that new users looking for a library supporting any of these simpler libraries are not discouraged by seeing \"Oracle\" somewhere in the name. The other possible interpretation was \"Syntax Oriented Call Interface\", which stresses the fact that SOCI was built to support the most natural and easy interface for the user that is similar to the Embedded SQL concept (see below). But on the other hand, SOCI also provides other features (like object-relational mapping) and as a whole it is not just \"emulator\" of the Embedded SQL. With all these considerations in mind, SOCI is just \"SOCI - The C++ Database Access Library\". Still, Oracle is considered to be the main driving server technology in terms of the set of features that are supported by the library. This also means that backends for other servers might need to work around some of the imposed idioms and protocols, but already available and well-working PostgreSQL, MySQL and SQLite3 backends show that it's actually not that bad and the abstractions provided by the library are actually very universal. Of course, some of the features that were provided for Oracle might not be supported for all other servers, but we think that it's better to have one leading technology (where at least one group is fully happy) instead of some \"common denominator\" for all databases (where nobody is happy).","title":"Q: Why \"SOCI\"?"},{"location":"faq/#q-where-the-basic-soci-syntax-comes-from","text":"The basic SOCI syntax was inspired by the Embedded SQL, which is part of the SQL standard, supported by the major DB technologies and even available as built-in part of the languages used in some DB-oriented integrated development environments. The term \"Embedded SQL\" is enough for Google to spit millions of references - one of the typical examples is: { int a; /* ... */ EXEC SQL SELECT salary INTO :a FROM Employee WHERE SSN=876543210; /* ... */ printf(\"The salary is %d\\n\", a); /* ... */ } The above is not a regular C (nor C++) code, of course. It's the mix of C and SQL and there is a separate, pecialized preprocessor needed to convert it to something that the actual C (or C++) compiler will be able to understand. This means that the compilation of the program using embedded SQL is two-phase: preprocess the embedded SQL part and compile the result. This two-phase development is quite troublesome, especially when it comes to debugging. Yet, the advantage of it is that the code expresses the programmer's intents in a very straightforward way: read something from the database and put it into the local variable. Just like that. The SOCI library was born as an answer to the following question: is it possible to have the same expressive power without the disadvantages of two-phase builds? The following was chosen to be the basic SOCI syntax that can mirror the above Embedded SQL example: int a; sql << \"SELECT salary FROM Employee WHERE SSN=876543210\", into(a); (as you see, SOCI changes the order of elements a little bit, so that the SQL query is separate and not mixed with other elements) Apart from mimicking the Embedded SQL techniques in the regular, fully standard C++ code, the above syntax has the following benefit: it is minimal with respect to what has to be said. Every single piece above is needed and expresses something important, like: which session should be used (the client can be connected to many databases at the same time) - here, the sql object encapsulates the session, what SQL query should be executed - here, it's the string literal, but it could be also a std::string variable, where to put the result - here, the local variable a will receive the result. Everything else is just a couple of operators that allow to treat the whole as a single expression. It's rather difficult to remove anything from this example. The fact that the basic SOCI syntax is minimal (but without being obscure at the same time, see below) means that the programmer does not need to bother with unnecessary noise that some other database libraries impose. We hope that after having written one line of code like above by themselves, most programmers will react with something like \"how obvious!\" instead of \"how advanced!\".","title":"Q: Where the basic SOCI syntax comes from?"},{"location":"faq/#q-why-should-i-use-sql-queries-as-strings-in-my-program-i-prefer-the-query-to-be-generated-or-composed-piece-by-piece-by-separate-functions","text":"First, you don't need to use SQL queries as string literals. In bigger projects it is a common practice to store SQL queries externally (in a file, or in a... database) and load them before use. This means that they are not necessarily expected to appear in the program code, as they do in our simple code examples and the advantage of separating them from the source code of the main program is, among others, the possibility to optimize and tune the SQL queries without recompilation and relinking of the whole program. What is the most important, though, is that SOCI does not try to mess with the text of the query (apart from very few cases), which means that the database server will get exactly the same text of the query as is used in the program. The advantage of this is that there is no new SQL-like (or even SQL- un like) syntax that you would need to learn, and also that it's much easier to convince a typical DBA to help with SQL tuning or other specialized activities, if he is given the material in the form that is not polluted with any foreign abstractions.","title":"Q: Why should I use SQL queries as strings in my program? I prefer the query to be generated or composed piece-by-piece by separate functions."},{"location":"faq/#q-why-not-some-stream-like-interface-which-is-well-known-to-all-c-programmers","text":"An example of the stream-like interface might be something like this (this is imaginary syntax, not supported by SOCI): sql.exec(\"select a, b, c from some_table\"); while (!sql.eof()) { int a, b, c; sql >> a >> b >> c; // ... } We think that the data stored in the relational database should be treated as a set of relations - which is exactly what it is. This means that what is read from the database as a result of some SQL query is a set of rows . This set might be ordered, but it is still a set of rows, not a uniformly flat list of values. This distinction might seem to be unnecessarily low-level and that the uniform stream-like presentation of data is more preferable, but it's actually the other way round - the set of rows is something more structured - and that structure was designed into the database - than the flat stream and is therefore less prone to programming errors like miscounting the number of values that is expected in each row. Consider the following programming error: sql.exec(\"select a, b from some_table\"); // only TWO columns while (!sql.eof()) { int a, b, c; sql >> a >> b >> c; // this causes \"row-tearing\" // ... } \"How to detect the end of each line in a file\" is a common beginner's question that relates to the use of IOStreams - and this common question clearly shows that for the record-oriented data the stream is not an optimal abstraction. Of course, we don't claim that IOStreams is bad - but we do insist that the record-oriented data is better manipulated in a way that is also record-aware. Having said that, we have provided some form of the stream-like interface, but with the important limitation that the stream is always bound to the single row, so that the row-tearing effect is not possible. In other words, data returned from the database is still structured into rows, but each row can be separately traversed like a stream. We hope that it provides a good balance between convenience and code safety.","title":"Q: Why not some stream-like interface, which is well-known to all C++ programmers?"},{"location":"faq/#q-why-use-indicators-instead-of-some-special-value-to-discover-that-something-is-null","text":"Some programmers are used to indicating the null value by using some special (which means: \"unlikely\" to be ever used) value - for example, to use the smallest integer value to indicate null integer. Or to use empty string to indicate null string. And so on. We think that it's completely wrong . Null (in the database sense) is an information about the data. It describes the state of the data and if it's null, then there's no data at all . Nothing. Null. It does not make any sense to talk about some special value if in fact there is no value at all - especially if we take into account that, for example, the smallest integer value (or whatever else you choose as the \"special\" value) might not be that special in the given application or domain. Thus, SOCI uses a separate indicators to describe the state of exchanged data. It also has an additional benefit of allowing the library to convey more than two states (null and not null). Indeed, the SOCI library uses indicators also to report that the data was read, but truncated (this applies to strings when reading to fixed-length character arrays). Truncation is also an information about the data and as such it's better to have it in addition to the data, not as part of it. Having said that, it is important to point at the Integration with Boost that allows to use boost::optional<T> to conveniently pack together the data and the information about its state.","title":"Q: Why use indicators instead of some special value to discover that something is null?"},{"location":"faq/#q-overloaded-comma-operator-is-just-obfuscation-i-dont-like-it","text":"Well, consider the following: \"Send the query X to the server Y and put result into variable Z.\" Above, the \"and\" plays a role of the comma. Even if overloading the comma operator is not a very popular practice in C++, some libraries do this, achieving terse and easy to learn syntax. We are pretty sure that in SOCI the comma operator was overloaded with a good effect.","title":"Q: Overloaded comma operator is just obfuscation, I don't like it."},{"location":"faq/#q-the-operatorltlt-provides-a-bad-abstraction-for-the-input-statements","text":"Indeed, the operator<< in the basic SOCI syntax shows that something (the query) is sent somewhere (to the server). Some people don't like this, especially when the \"select\" statements are involved. If the high-level idea is to read data from somewhere, then operator<< seems unintuitive to the die-hard IOStreams users. The fact is, however, that the code containing SQL statement already indicates that there is a client-server relationship with some other software component (very likely remote). In such code it does not make any sense to pretend that the communication is one-way only, because it's clear that even the \"select\" statements need to be sent somewhere. This approach is also more uniform and allows to cover other statements like \"drop table\" or alike, where no data is expected to be exchanged at all (and therefore the IOStreams analogies for data exchange have no sense at all). No matter what is the kind of the SQL statement, it is sent to the server and this \"sending\" justifies the choice of operator<< . Using different operators ( operator>> and operator<< ) as a way of distinguishing between different high-level ideas ( reading and writing from the data store, respectively) does make sense on much higher level of abstraction, where the SQL statement itself is already hidden - and we do encourage programmers to use SOCI for implementing such high-level abstractions. For this, the object-relational mapping facilities available in SOCI might prove to be a valuable tool as well, as an effective bridge between the low-level world of SQL statements and the high-level world of user-defined abstract data types.","title":"Q: The operator&lt;&lt; provides a bad abstraction for the \"input\" statements."},{"location":"faq/#q-why-the-boost-license","text":"We decided to use the Boost license , because it's well recognized in the C++ community, allows us to keep our minimum copyrights, and at the same time allows SOCI to be safely used in commercial projects, without imposing concerns (or just plainuncertainty) typical to other open source licenses, like GPL. We also hope that by choosing the Boost license we have made the life easier for both us and our users. It saves us from answering law-related questions that were already answered on the Boost license info page and it should also give more confidence to our users - especially to those of them, who already accepted the conditions of the Boost license - the just have one license less to analyze. Still, if for any reason the conditions of this license are not acceptable, we encourage the users to contact us directly (see links on the relevant SOCI page) to discuss any remaining concerns.","title":"Q: Why the Boost license?"},{"location":"indicators/","text":"Data Indicators In order to support SQL NULL values and other conditions which are not real errors, the concept of indicator is provided. Select with NULL values For example, when the following SQL query is executed: select name from person where id = 7 there are three possible outcomes: there is a person with id = 7 and her name is returned there is a person with id = 7, but she has no name (her name is null in the database table) there is no such person Whereas the first alternative is easy to handle, the other two are more complex. Moreover, they are not necessarily errors from the application's point of view and what's more interesting, they are different and the application may wish to detect which is the case. The following example does this: string name; indicator ind; sql << \"select name from person where id = 7\", into(name, ind); if (sql.got_data()) { switch (ind) { case i_ok: // the data was returned without problems break; case i_null: // there is a person, but he has no name (his name is null) break; case i_truncated: // the name was returned only in part, // because the provided buffer was too short // (not possible with std::string, but possible with char* and char[]) break; } } else { // no such person in the database } The use of indicator variable is optional, but if it is not used and the result would be i_null , then the exception is thrown. This means that you should use indicator variables everywhere where the application logic (and database schema) allow the \"attribute not set\" condition. Insert with NULL values Indicator variables can be also used when binding input data, to control whether the data is to be used as provided, or explicitly overrided to be null: int id = 7; string name; indicator ind = i_null; sql << \"insert into person(id, name) values(:id, :name)\", use(id), use(name, ind); In the above example, the row is inserted with name attribute set to null. Bulk operations with NULL values Indicator variables can also be used in conjunction with vector based insert, update, and select statements: vector<string> names(100); vector<indicator> inds; sql << \"select name from person where id = 7\", into(names, inds); The above example retrieves first 100 rows of data (or less). The initial size of names vector provides the (maximum) number of rows that should be read. Both vectors will be automatically resized according to the number of rows that were actually read. The following example inserts null for each value of name: vector<int> ids; vector<string> names; vector<indicator> nameIndicators; for (int i = 0; i != 10; ++i) { ids.push_back(i); names.push_back(\"\"); nameIndicators.push_back(i_null); } sql << \"insert into person(id, name) values(:id, :name)\", use(ids), use(name, nameIndicators); See also Integration with Boost to learn how the Boost.Optional library can be used to handle null data conditions in a more natural way.","title":"Data Indicators"},{"location":"indicators/#data-indicators","text":"In order to support SQL NULL values and other conditions which are not real errors, the concept of indicator is provided.","title":"Data Indicators"},{"location":"indicators/#select-with-null-values","text":"For example, when the following SQL query is executed: select name from person where id = 7 there are three possible outcomes: there is a person with id = 7 and her name is returned there is a person with id = 7, but she has no name (her name is null in the database table) there is no such person Whereas the first alternative is easy to handle, the other two are more complex. Moreover, they are not necessarily errors from the application's point of view and what's more interesting, they are different and the application may wish to detect which is the case. The following example does this: string name; indicator ind; sql << \"select name from person where id = 7\", into(name, ind); if (sql.got_data()) { switch (ind) { case i_ok: // the data was returned without problems break; case i_null: // there is a person, but he has no name (his name is null) break; case i_truncated: // the name was returned only in part, // because the provided buffer was too short // (not possible with std::string, but possible with char* and char[]) break; } } else { // no such person in the database } The use of indicator variable is optional, but if it is not used and the result would be i_null , then the exception is thrown. This means that you should use indicator variables everywhere where the application logic (and database schema) allow the \"attribute not set\" condition.","title":"Select with NULL values"},{"location":"indicators/#insert-with-null-values","text":"Indicator variables can be also used when binding input data, to control whether the data is to be used as provided, or explicitly overrided to be null: int id = 7; string name; indicator ind = i_null; sql << \"insert into person(id, name) values(:id, :name)\", use(id), use(name, ind); In the above example, the row is inserted with name attribute set to null.","title":"Insert with NULL values"},{"location":"indicators/#bulk-operations-with-null-values","text":"Indicator variables can also be used in conjunction with vector based insert, update, and select statements: vector<string> names(100); vector<indicator> inds; sql << \"select name from person where id = 7\", into(names, inds); The above example retrieves first 100 rows of data (or less). The initial size of names vector provides the (maximum) number of rows that should be read. Both vectors will be automatically resized according to the number of rows that were actually read. The following example inserts null for each value of name: vector<int> ids; vector<string> names; vector<indicator> nameIndicators; for (int i = 0; i != 10; ++i) { ids.push_back(i); names.push_back(\"\"); nameIndicators.push_back(i_null); } sql << \"insert into person(id, name) values(:id, :name)\", use(ids), use(name, nameIndicators); See also Integration with Boost to learn how the Boost.Optional library can be used to handle null data conditions in a more natural way.","title":"Bulk operations with NULL values"},{"location":"installation/","text":"Installation Requirements Below is an overall list of SOCI core: C++ compiler: GCC , Microsoft Visual C++ , LLVM/clang CMake 2.8+ - in order to use build configuration for CMake Boost C++ Libraries : DateTime, Fusion, Optional, Preprocessor, Tuple and backend-specific dependencies: DB2 Call Level Interface (CLI) Firebird client library mysqlclient - C API to MySQL ODBC (Open Database Connectivity) implementation: Microsoft ODBC iODBC , unixODBC Oracle Call Interface (OCI) libpq - C API to PostgreSQL SQLite 3 library Downloads Download package with latest release of the SOCI source code: soci-X.Y.Z , where X.Y.Z is the version number. Unpack the archive. You can always clone SOCI from the Git repository: git clone git://github.com/SOCI/soci.git Building with CMake SOCI is configured to build using CMake system in version 2.8+. The build configuration allows to control various aspects of compilation and installation by setting common CMake variables that change behaviour, describe system or control build (see CMake help ) as well as SOCI-specific variables described below. All these variables are available regardless of platform or compilation toolset used. Running CMake from the command line allows to set variables in the CMake cache with the following syntax: -DVARIABLE:TYPE=VALUE . If you are new to CMake, you may find the tutorial Running CMake helpful. Running CMake on Unix Steps outline using GNU Make Makefile -s: mkdir build cd build cmake -G \"Unix Makefiles\" -DWITH_BOOST=OFF -DWITH_ORACLE=OFF (...) /path/to/soci-X.Y.Z make make install Running CMake on Windows Steps outline using Visual Studio 2010 and MSBuild: mkdir build cd build cmake -G \"Visual Studio 10\" -DWITH_BOOST=OFF -DWITH_ORACLE=OFF (...) C:\\path\\to\\soci-X.Y.Z msbuild.exe SOCI.sln CMake configuration By default, CMake will try to determine availability of all dependencies automatically. If you are lucky, you will not need to specify any of the CMake variables explained below. However, if CMake reports some of the core or backend-specific dependencies as missing, you will need specify relevant variables to tell CMake where to look for the required components. CMake configures SOCI build performing sequence of steps. Each subsequent step is dependant on result of previous steps corresponding with particular feature. First, CMake checks system platform and compilation toolset. Next, CMake tries to find all external dependencies. Then, depending on the results of the dependency check, CMake determines SOCI backends which are possible to build. The SOCI-specific variables described below provide users with basic control of this behaviour. The following sections provide summary of variables accepted by CMake scripts configuring SOCI build. The lists consist of common variables for SOCI core and all backends as well as variables specific to SOCI backends and their direct dependencies. List of a few essential CMake variables: CMAKE_BUILD_TYPE - string - Specifies the build type for make based generators (see CMake help ). CMAKE_INSTALL_PREFIX - path - Install directory used by install command (see CMake help ). CMAKE_VERBOSE_MAKEFILE - boolean - If ON, create verbose makefile (see CMake help ). List of variables to control common SOCI features and dependencies: SOCI_CXX11 - boolean - Request to compile in C++11 compatibility mode. Default is OFF , unless CMAKE_CXX_STANDARD with version 11 or later is given in the command line. SOCI_SHARED - boolean - Request to build shared libraries for SOCI core and all successfully configured backends. Default is ON . SOCI_STATIC - boolean - Request to build static libraries for SOCI core and all successfully configured backends. Default is ON . SOCI_TESTS - boolean - Request to build regression tests for SOCI core and all successfully configured backends. WITH_BOOST - boolean - Should CMake try to detect Boost C++ Libraries . If ON, CMake will try to find Boost headers and binaries of Boost.Date_Time library. Empty (sample backend) SOCI_EMPTY - boolean - Builds the sample backend called Empty. Always ON by default. SOCI_EMPTY_TEST_CONNSTR - string - Connection string used to run regression tests of the Empty backend. It is a dummy value. Example: -DSOCI_EMPTY_TEST_CONNSTR=\"dummy connection\" IBM DB2 WITH_DB2 - boolean - Should CMake try to detect IBM DB2 Call Level Interface (CLI) library. DB2_INCLUDE_DIR - string - Path to DB2 CLI include directories where CMake should look for sqlcli1.h header. DB2_LIBRARIES - string - Full paths to db2 or db2api libraries to link SOCI against to enable the backend support. SOCI_DB2 - boolean - Requests to build DB2 backend. Automatically switched on, if WITH_DB2 is set to ON. SOCI_DB2_TEST_CONNSTR - string - See DB2 backend reference for details. Example: -DSOCI_DB2_TEST_CONNSTR:STRING=\"DSN=SAMPLE;Uid=db2inst1;Pwd=db2inst1;autocommit=off\" Firebird WITH_FIREBIRD - boolean - Should CMake try to detect Firebird client library. FIREBIRD_INCLUDE_DIR - string - Path to Firebird include directories where CMake should look for ibase.h header. FIREBIRD_LIBRARIES - string - Full paths to Firebird fbclient or fbclient_ms libraries to link SOCI against to enable the backend support. SOCI_FIREBIRD - boolean - Requests to build Firebird backend. Automatically switched on, if WITH_FIREBIRD is set to ON. SOCI_FIREBIRD_TEST_CONNSTR - string - See Firebird backend reference for details. Example: -DSOCI_FIREBIRD_TEST_CONNSTR:STRING=\"service=LOCALHOST:/tmp/soci_test.fdb user=SYSDBA password=masterkey\" MySQL WITH_MYSQL - boolean - Should CMake try to detect mysqlclient libraries providing MySQL C API. Note, currently the mysql_config program is not being used. MYSQL_DIR - string - Path to MySQL installation root directory. CMake will scan subdirectories MYSQL_DIR/include and MYSQL_DIR/lib respectively for MySQL headers and libraries. MYSQL_INCLUDE_DIR - string - Path to MySQL include directory where CMake should look for mysql.h header. MYSQL_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_MYSQL - boolean - Requests to build MySQL backend. Automatically switched on, if WITH_MYSQL is set to ON. SOCI_MYSQL_TEST_CONNSTR - string - Connection string to MySQL test database. Format of the string is explained MySQL backend reference . Example: -DSOCI_MYSQL_TEST_CONNSTR:STRING=\"db=mydb user=mloskot password=secret\" ODBC WITH_ODBC - boolean - Should CMake try to detect ODBC libraries. On Unix systems, CMake tries to find unixODBC or iODBC implementations. ODBC_INCLUDE_DIR - string - Path to ODBC implementation include directories where CMake should look for sql.h header. ODBC_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_ODBC - boolean - Requests to build ODBC backend. Automatically switched on, if WITH_ODBC is set to ON. SOCI_ODBC_TEST_{database}_CONNSTR - string - ODBC Data Source Name (DSN) or ODBC File Data Source Name (FILEDSN) to test database: Microsoft Access (.mdb), Microsoft SQL Server, MySQL, PostgreSQL or any other ODBC SQL data source. {database} is placeholder for name of database driver ACCESS, MYSQL, POSTGRESQL, etc. See ODBC backend reference for details. Example: -DSOCI_ODBC_TEST_POSTGRESQL_CONNSTR=\"FILEDSN=/home/mloskot/soci/build/test-postgresql.dsn\" Oracle WITH_ORACLE - boolean - Should CMake try to detect Oracle Call Interface (OCI) libraries. ORACLE_INCLUDE_DIR - string - Path to Oracle include directory where CMake should look for oci.h header. ORACLE_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_ORACLE - boolean - Requests to build Oracle backend. Automatically switched on, if WITH_ORACLE is set to ON. SOCI_ORACLE_TEST_CONNSTR - string - Connection string to Oracle test database. Format of the string is explained Oracle backend reference . Example: -DSOCI_ORACLE_TEST_CONNSTR:STRING=\"service=orcl user=scott password=tiger\" PostgreSQL WITH_POSTGRESQL - boolean - Should CMake try to detect PostgreSQL client interface libraries. SOCI relies on libpq C library. POSTGRESQL_INCLUDE_DIR - string - Path to PostgreSQL include directory where CMake should look for libpq-fe.h header. POSTGRESQL_LIBRARY - string - Full paths to libraries to link SOCI against to enable the backend support. The POSTGRESQL_LIBRARIES will be set with PostgreSQL libraries needed for linking. SOCI_POSTGRESQL - boolean - Requests to build PostgreSQL backend. Automatically switched on, if WITH_POSTGRESQL is set to ON. SOCI_POSTGRESQL_TEST_CONNSTR - string - Connection string to PostgreSQL test database. Format of the string is explained PostgreSQL backend reference. Example: -DSOCI_POSTGRESQL_TEST_CONNSTR:STRING=\"dbname=mydb user=scott\" SQLite 3 WITH_SQLITE3 - boolean - Should CMake try to detect SQLite C/C++ library. As bonus, the configuration tries OSGeo4W distribution if OSGEO4W_ROOT environment variable is set. SQLITE3_INCLUDE_DIR - string - Path to SQLite 3 include directory where CMake should look for sqlite3.h header. SQLITE3_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_SQLITE3 - boolean - Requests to build SQLite3 backend. Automatically switched on, if WITH_SQLITE3 is set to ON. SOCI_SQLITE3_TEST_CONNSTR - string - Connection string is simply a file path where SQLite3 test database will be created (e.g. /home/john/soci_test.db). Check SQLite3 backend reference for details. Example: -DSOCI_SQLITE3_TEST_CONNSTR=\"my.db\" or -DSOCI_SQLITE3_TEST_CONNSTR=\":memory:\" . Building with Makefiles on Unix NOTE: These (classic) Makefiles have not been maintained for long time. The officially maintained build configuration is CMake. If you still want to use these Makefiles, you've been warned that you may need to patch them. The classic set of Makefiles for Unix/Linux systems is provided for those users who need complete control over the whole processand who can benefit from the basic scaffolding that they can extend on their own. In this sense, the basic Makefiles are supposed to provide a minimal starting point for custom experimentation and are not intended to be a complete build/installation solution. At the same time, they are complete in the sense that they can compile the library with all test programs and for some users this level of support will be just fine. The core directory of the library distribution contains the Makefile.basic that can be used to compile the core part of the library. Run make -f Makefile.basic or make -f Makefile.basic shared to get the static and shared versions, respectively. Similarly, the backends/<i>name</i> directory contains the backend part for each supported backend with the appropriate Makefile.basic and the backends/<i>name</i>/test directory contains the test program for the given backend. For example, the simplest way to compile the static version of the library and the test program for PostgreSQL is: cd src/core make -f Makefile.basic cd ../backends/postgresql make -f Makefile.basic cd test make -f Makefile.basic For each backend and its test program, the Makefile.basic s contain the variables that can have values specific to the given environment - they usually name the include and library paths. These variables are placed at the beginning of the Makefile.basic s. Please review their values in case of any compilation problems. The Makefiles for test programs can be a good starting point to find out correct compiler and linker options. Running tests The process of running regression tests highly depends on user's environment and build configuration, so it may be quite involving process. The CMake configuration provides variables to allow users willing to run the tests to configure build and specify database connection parameters (see the lists above for variable names). In order to run regression tests, configure and build desired SOCI backends and prepare working database instances for them. While configuring build with CMake, specify SOCI_TESTS=ON to enable building regression tests. Also, specify SOCI_{backend name}_TEST_CONNSTR variables to tell the tests runner how to connect with your test databases. Dedicated make test target can be used to execute regression tests on build completion: mkdir build cd build cmake -G \"Unix Makefiles\" \\ -DWITH_BOOST=OFF \\ -DSOCI_TESTS=ON \\ -DSOCI_EMPTY_TEST_CONNSTR=\"dummy connection\" \\ -DSOCI_SQLITE3_TEST_CONNSTR=\"test.db\" \\ (...) ../soci-X.Y.Z make make test make install In the example above, regression tests for the sample Empty backend and SQLite 3 backend are configured for execution by make test target. Using library CMake build produces set of shared and static libraries for SOCI core and backends separately. On Unix, for example, build/lib directory will consist of the static libraries named like libsoci_core.a , libsoci_sqlite3.a and shared libraries with names like libsoci_core.so.4.0.0 , libsoci_sqlite3.so.4.0.0 , and so on. In order to use SOCI in your program, you need to specify your project build configuration with paths to SOCI headers and libraries. Then, tell the linker to link against the libraries you want to use in your program.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#requirements","text":"Below is an overall list of SOCI core: C++ compiler: GCC , Microsoft Visual C++ , LLVM/clang CMake 2.8+ - in order to use build configuration for CMake Boost C++ Libraries : DateTime, Fusion, Optional, Preprocessor, Tuple and backend-specific dependencies: DB2 Call Level Interface (CLI) Firebird client library mysqlclient - C API to MySQL ODBC (Open Database Connectivity) implementation: Microsoft ODBC iODBC , unixODBC Oracle Call Interface (OCI) libpq - C API to PostgreSQL SQLite 3 library","title":"Requirements"},{"location":"installation/#downloads","text":"Download package with latest release of the SOCI source code: soci-X.Y.Z , where X.Y.Z is the version number. Unpack the archive. You can always clone SOCI from the Git repository: git clone git://github.com/SOCI/soci.git","title":"Downloads"},{"location":"installation/#building-with-cmake","text":"SOCI is configured to build using CMake system in version 2.8+. The build configuration allows to control various aspects of compilation and installation by setting common CMake variables that change behaviour, describe system or control build (see CMake help ) as well as SOCI-specific variables described below. All these variables are available regardless of platform or compilation toolset used. Running CMake from the command line allows to set variables in the CMake cache with the following syntax: -DVARIABLE:TYPE=VALUE . If you are new to CMake, you may find the tutorial Running CMake helpful.","title":"Building with CMake"},{"location":"installation/#running-cmake-on-unix","text":"Steps outline using GNU Make Makefile -s: mkdir build cd build cmake -G \"Unix Makefiles\" -DWITH_BOOST=OFF -DWITH_ORACLE=OFF (...) /path/to/soci-X.Y.Z make make install","title":"Running CMake on Unix"},{"location":"installation/#running-cmake-on-windows","text":"Steps outline using Visual Studio 2010 and MSBuild: mkdir build cd build cmake -G \"Visual Studio 10\" -DWITH_BOOST=OFF -DWITH_ORACLE=OFF (...) C:\\path\\to\\soci-X.Y.Z msbuild.exe SOCI.sln","title":"Running CMake on Windows"},{"location":"installation/#cmake-configuration","text":"By default, CMake will try to determine availability of all dependencies automatically. If you are lucky, you will not need to specify any of the CMake variables explained below. However, if CMake reports some of the core or backend-specific dependencies as missing, you will need specify relevant variables to tell CMake where to look for the required components. CMake configures SOCI build performing sequence of steps. Each subsequent step is dependant on result of previous steps corresponding with particular feature. First, CMake checks system platform and compilation toolset. Next, CMake tries to find all external dependencies. Then, depending on the results of the dependency check, CMake determines SOCI backends which are possible to build. The SOCI-specific variables described below provide users with basic control of this behaviour. The following sections provide summary of variables accepted by CMake scripts configuring SOCI build. The lists consist of common variables for SOCI core and all backends as well as variables specific to SOCI backends and their direct dependencies. List of a few essential CMake variables: CMAKE_BUILD_TYPE - string - Specifies the build type for make based generators (see CMake help ). CMAKE_INSTALL_PREFIX - path - Install directory used by install command (see CMake help ). CMAKE_VERBOSE_MAKEFILE - boolean - If ON, create verbose makefile (see CMake help ). List of variables to control common SOCI features and dependencies: SOCI_CXX11 - boolean - Request to compile in C++11 compatibility mode. Default is OFF , unless CMAKE_CXX_STANDARD with version 11 or later is given in the command line. SOCI_SHARED - boolean - Request to build shared libraries for SOCI core and all successfully configured backends. Default is ON . SOCI_STATIC - boolean - Request to build static libraries for SOCI core and all successfully configured backends. Default is ON . SOCI_TESTS - boolean - Request to build regression tests for SOCI core and all successfully configured backends. WITH_BOOST - boolean - Should CMake try to detect Boost C++ Libraries . If ON, CMake will try to find Boost headers and binaries of Boost.Date_Time library.","title":"CMake configuration"},{"location":"installation/#empty-sample-backend","text":"SOCI_EMPTY - boolean - Builds the sample backend called Empty. Always ON by default. SOCI_EMPTY_TEST_CONNSTR - string - Connection string used to run regression tests of the Empty backend. It is a dummy value. Example: -DSOCI_EMPTY_TEST_CONNSTR=\"dummy connection\"","title":"Empty (sample backend)"},{"location":"installation/#ibm-db2","text":"WITH_DB2 - boolean - Should CMake try to detect IBM DB2 Call Level Interface (CLI) library. DB2_INCLUDE_DIR - string - Path to DB2 CLI include directories where CMake should look for sqlcli1.h header. DB2_LIBRARIES - string - Full paths to db2 or db2api libraries to link SOCI against to enable the backend support. SOCI_DB2 - boolean - Requests to build DB2 backend. Automatically switched on, if WITH_DB2 is set to ON. SOCI_DB2_TEST_CONNSTR - string - See DB2 backend reference for details. Example: -DSOCI_DB2_TEST_CONNSTR:STRING=\"DSN=SAMPLE;Uid=db2inst1;Pwd=db2inst1;autocommit=off\"","title":"IBM DB2"},{"location":"installation/#firebird","text":"WITH_FIREBIRD - boolean - Should CMake try to detect Firebird client library. FIREBIRD_INCLUDE_DIR - string - Path to Firebird include directories where CMake should look for ibase.h header. FIREBIRD_LIBRARIES - string - Full paths to Firebird fbclient or fbclient_ms libraries to link SOCI against to enable the backend support. SOCI_FIREBIRD - boolean - Requests to build Firebird backend. Automatically switched on, if WITH_FIREBIRD is set to ON. SOCI_FIREBIRD_TEST_CONNSTR - string - See Firebird backend reference for details. Example: -DSOCI_FIREBIRD_TEST_CONNSTR:STRING=\"service=LOCALHOST:/tmp/soci_test.fdb user=SYSDBA password=masterkey\"","title":"Firebird"},{"location":"installation/#mysql","text":"WITH_MYSQL - boolean - Should CMake try to detect mysqlclient libraries providing MySQL C API. Note, currently the mysql_config program is not being used. MYSQL_DIR - string - Path to MySQL installation root directory. CMake will scan subdirectories MYSQL_DIR/include and MYSQL_DIR/lib respectively for MySQL headers and libraries. MYSQL_INCLUDE_DIR - string - Path to MySQL include directory where CMake should look for mysql.h header. MYSQL_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_MYSQL - boolean - Requests to build MySQL backend. Automatically switched on, if WITH_MYSQL is set to ON. SOCI_MYSQL_TEST_CONNSTR - string - Connection string to MySQL test database. Format of the string is explained MySQL backend reference . Example: -DSOCI_MYSQL_TEST_CONNSTR:STRING=\"db=mydb user=mloskot password=secret\"","title":"MySQL"},{"location":"installation/#odbc","text":"WITH_ODBC - boolean - Should CMake try to detect ODBC libraries. On Unix systems, CMake tries to find unixODBC or iODBC implementations. ODBC_INCLUDE_DIR - string - Path to ODBC implementation include directories where CMake should look for sql.h header. ODBC_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_ODBC - boolean - Requests to build ODBC backend. Automatically switched on, if WITH_ODBC is set to ON. SOCI_ODBC_TEST_{database}_CONNSTR - string - ODBC Data Source Name (DSN) or ODBC File Data Source Name (FILEDSN) to test database: Microsoft Access (.mdb), Microsoft SQL Server, MySQL, PostgreSQL or any other ODBC SQL data source. {database} is placeholder for name of database driver ACCESS, MYSQL, POSTGRESQL, etc. See ODBC backend reference for details. Example: -DSOCI_ODBC_TEST_POSTGRESQL_CONNSTR=\"FILEDSN=/home/mloskot/soci/build/test-postgresql.dsn\"","title":"ODBC"},{"location":"installation/#oracle","text":"WITH_ORACLE - boolean - Should CMake try to detect Oracle Call Interface (OCI) libraries. ORACLE_INCLUDE_DIR - string - Path to Oracle include directory where CMake should look for oci.h header. ORACLE_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_ORACLE - boolean - Requests to build Oracle backend. Automatically switched on, if WITH_ORACLE is set to ON. SOCI_ORACLE_TEST_CONNSTR - string - Connection string to Oracle test database. Format of the string is explained Oracle backend reference . Example: -DSOCI_ORACLE_TEST_CONNSTR:STRING=\"service=orcl user=scott password=tiger\"","title":"Oracle"},{"location":"installation/#postgresql","text":"WITH_POSTGRESQL - boolean - Should CMake try to detect PostgreSQL client interface libraries. SOCI relies on libpq C library. POSTGRESQL_INCLUDE_DIR - string - Path to PostgreSQL include directory where CMake should look for libpq-fe.h header. POSTGRESQL_LIBRARY - string - Full paths to libraries to link SOCI against to enable the backend support. The POSTGRESQL_LIBRARIES will be set with PostgreSQL libraries needed for linking. SOCI_POSTGRESQL - boolean - Requests to build PostgreSQL backend. Automatically switched on, if WITH_POSTGRESQL is set to ON. SOCI_POSTGRESQL_TEST_CONNSTR - string - Connection string to PostgreSQL test database. Format of the string is explained PostgreSQL backend reference. Example: -DSOCI_POSTGRESQL_TEST_CONNSTR:STRING=\"dbname=mydb user=scott\"","title":"PostgreSQL"},{"location":"installation/#sqlite-3","text":"WITH_SQLITE3 - boolean - Should CMake try to detect SQLite C/C++ library. As bonus, the configuration tries OSGeo4W distribution if OSGEO4W_ROOT environment variable is set. SQLITE3_INCLUDE_DIR - string - Path to SQLite 3 include directory where CMake should look for sqlite3.h header. SQLITE3_LIBRARIES - string - Full paths to libraries to link SOCI against to enable the backend support. SOCI_SQLITE3 - boolean - Requests to build SQLite3 backend. Automatically switched on, if WITH_SQLITE3 is set to ON. SOCI_SQLITE3_TEST_CONNSTR - string - Connection string is simply a file path where SQLite3 test database will be created (e.g. /home/john/soci_test.db). Check SQLite3 backend reference for details. Example: -DSOCI_SQLITE3_TEST_CONNSTR=\"my.db\" or -DSOCI_SQLITE3_TEST_CONNSTR=\":memory:\" .","title":"SQLite 3"},{"location":"installation/#building-with-makefiles-on-unix","text":"NOTE: These (classic) Makefiles have not been maintained for long time. The officially maintained build configuration is CMake. If you still want to use these Makefiles, you've been warned that you may need to patch them. The classic set of Makefiles for Unix/Linux systems is provided for those users who need complete control over the whole processand who can benefit from the basic scaffolding that they can extend on their own. In this sense, the basic Makefiles are supposed to provide a minimal starting point for custom experimentation and are not intended to be a complete build/installation solution. At the same time, they are complete in the sense that they can compile the library with all test programs and for some users this level of support will be just fine. The core directory of the library distribution contains the Makefile.basic that can be used to compile the core part of the library. Run make -f Makefile.basic or make -f Makefile.basic shared to get the static and shared versions, respectively. Similarly, the backends/<i>name</i> directory contains the backend part for each supported backend with the appropriate Makefile.basic and the backends/<i>name</i>/test directory contains the test program for the given backend. For example, the simplest way to compile the static version of the library and the test program for PostgreSQL is: cd src/core make -f Makefile.basic cd ../backends/postgresql make -f Makefile.basic cd test make -f Makefile.basic For each backend and its test program, the Makefile.basic s contain the variables that can have values specific to the given environment - they usually name the include and library paths. These variables are placed at the beginning of the Makefile.basic s. Please review their values in case of any compilation problems. The Makefiles for test programs can be a good starting point to find out correct compiler and linker options.","title":"Building with Makefiles on Unix"},{"location":"installation/#running-tests","text":"The process of running regression tests highly depends on user's environment and build configuration, so it may be quite involving process. The CMake configuration provides variables to allow users willing to run the tests to configure build and specify database connection parameters (see the lists above for variable names). In order to run regression tests, configure and build desired SOCI backends and prepare working database instances for them. While configuring build with CMake, specify SOCI_TESTS=ON to enable building regression tests. Also, specify SOCI_{backend name}_TEST_CONNSTR variables to tell the tests runner how to connect with your test databases. Dedicated make test target can be used to execute regression tests on build completion: mkdir build cd build cmake -G \"Unix Makefiles\" \\ -DWITH_BOOST=OFF \\ -DSOCI_TESTS=ON \\ -DSOCI_EMPTY_TEST_CONNSTR=\"dummy connection\" \\ -DSOCI_SQLITE3_TEST_CONNSTR=\"test.db\" \\ (...) ../soci-X.Y.Z make make test make install In the example above, regression tests for the sample Empty backend and SQLite 3 backend are configured for execution by make test target.","title":"Running tests"},{"location":"installation/#using-library","text":"CMake build produces set of shared and static libraries for SOCI core and backends separately. On Unix, for example, build/lib directory will consist of the static libraries named like libsoci_core.a , libsoci_sqlite3.a and shared libraries with names like libsoci_core.so.4.0.0 , libsoci_sqlite3.so.4.0.0 , and so on. In order to use SOCI in your program, you need to specify your project build configuration with paths to SOCI headers and libraries. Then, tell the linker to link against the libraries you want to use in your program.","title":"Using library"},{"location":"interfaces/","text":"Interfaces One of the major features of SOCI, although not immediately visible, is the variety of interfaces (APIs) that are available for the user. These can be divided into sugar , core and simple . Sugar The most exposed and promoted interface supports the syntax sugar that makes SOCI similar in look and feel to embedded SQL. The example of application code using this interface is: session sql(\"postgresql://dbname=mydb\"); int id = 123; string name; sql << \"select name from persons where id = :id\", into(name), use(id); Core The above example is equivalent to the following, more explicit sequence of calls: session sql(\"postgresql://dbname=mydb\"); int id = 123; string name; statement st(sql); st.exchange(into(name)); st.exchange(use(id)); st.alloc(); st.prepare(\"select name from persons where id = :id\"); st.define_and_bind(); st.execute(true); The value of the core interface is that it is the basis for all other interfaces, and can be also used by developers to easily prepare their own convenience interfaces. Users who cannot or for some reason do not want to use the natural sugar interface should try the core one as the foundation and access point to all SOCI functionality. Note that the sugar interface wraps only those parts of the core that are related to data binding and query streaming. Simple The simple interface is provided specifically to allow easy integration of the SOCI library with other languages that have the ability to link with binaries using the \"C\" calling convention. To facilitate this integration, the simple interface does not use any pointers to data except C-style strings and opaque handles, but the consequence of this is that user data is managed by SOCI and not by user code. To avoid exceptions passing the module boundaries, all errors are reported as state variables of relevant objects. The above examples can be rewritten as (without error-handling): #include <soci-simple.h> // ... session_handle sql = soci_create_session(\"postgresql://dbname=mydb\"); statement_handle st = soci_create_statement(sql); soci_use_int(st, \"id\"); soci_set_use_int(st, \"id\", 123); int namePosition = soci_into_string(st); soci_prepare(st, \"select name from persons where id = :id\"); soci_execute(st, true); char const * name = soci_get_into_string(st, namePosition); printf(\"name is %s\\n\", name); soci_destroy_statement(st); soci_destroy_session(sql); The simple interface supports single and bulk data exchange for static binding. Dynamic row description is not supported in this release. See Simple client interface reference documentation for more details. Low-level backend interface The low-level backend interface allows to interact with backends directly and in principle allows to access the database without involving any other component. There is no particular reason to use this interface in the user code.","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"One of the major features of SOCI, although not immediately visible, is the variety of interfaces (APIs) that are available for the user. These can be divided into sugar , core and simple .","title":"Interfaces"},{"location":"interfaces/#sugar","text":"The most exposed and promoted interface supports the syntax sugar that makes SOCI similar in look and feel to embedded SQL. The example of application code using this interface is: session sql(\"postgresql://dbname=mydb\"); int id = 123; string name; sql << \"select name from persons where id = :id\", into(name), use(id);","title":"Sugar"},{"location":"interfaces/#core","text":"The above example is equivalent to the following, more explicit sequence of calls: session sql(\"postgresql://dbname=mydb\"); int id = 123; string name; statement st(sql); st.exchange(into(name)); st.exchange(use(id)); st.alloc(); st.prepare(\"select name from persons where id = :id\"); st.define_and_bind(); st.execute(true); The value of the core interface is that it is the basis for all other interfaces, and can be also used by developers to easily prepare their own convenience interfaces. Users who cannot or for some reason do not want to use the natural sugar interface should try the core one as the foundation and access point to all SOCI functionality. Note that the sugar interface wraps only those parts of the core that are related to data binding and query streaming.","title":"Core"},{"location":"interfaces/#simple","text":"The simple interface is provided specifically to allow easy integration of the SOCI library with other languages that have the ability to link with binaries using the \"C\" calling convention. To facilitate this integration, the simple interface does not use any pointers to data except C-style strings and opaque handles, but the consequence of this is that user data is managed by SOCI and not by user code. To avoid exceptions passing the module boundaries, all errors are reported as state variables of relevant objects. The above examples can be rewritten as (without error-handling): #include <soci-simple.h> // ... session_handle sql = soci_create_session(\"postgresql://dbname=mydb\"); statement_handle st = soci_create_statement(sql); soci_use_int(st, \"id\"); soci_set_use_int(st, \"id\", 123); int namePosition = soci_into_string(st); soci_prepare(st, \"select name from persons where id = :id\"); soci_execute(st, true); char const * name = soci_get_into_string(st, namePosition); printf(\"name is %s\\n\", name); soci_destroy_statement(st); soci_destroy_session(sql); The simple interface supports single and bulk data exchange for static binding. Dynamic row description is not supported in this release. See Simple client interface reference documentation for more details.","title":"Simple"},{"location":"interfaces/#low-level-backend-interface","text":"The low-level backend interface allows to interact with backends directly and in principle allows to access the database without involving any other component. There is no particular reason to use this interface in the user code.","title":"Low-level backend interface"},{"location":"license/","text":"License The SOCI library is distributed under the terms of the Boost Software License . Boost Software License Version 1.0 - August 17th, 2003 Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the \"Software\") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following: The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"The SOCI library is distributed under the terms of the Boost Software License .","title":"License"},{"location":"license/#boost-software-license","text":"Version 1.0 - August 17th, 2003 Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the \"Software\") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following: The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Boost Software License"},{"location":"lobs/","text":"Large Objects (LOBs) Binary (BLOBs) The SOCI library provides also an interface for basic operations on large objects (BLOBs - Binary Large OBjects). blob b(sql); // sql is a session object sql << \"select mp3 from mymusic where id = 123\", into(b); The following functions are provided in the blob interface, mimicking the file-like operations: std::size_t get_len(); std::size_t read_from_start(char * buf, std::size_t toRead, std::size_t offset = 0); std::size_t write_from_start(const char * buf, std::size_t toWrite, std::size_t offset = 0); std::size_t append(char const *buf, std::size_t toWrite); void trim(std::size_t newLen); The offset parameter is always counted from the beginning of the BLOB's data. Portability notes The way to define BLOB table columns and create or destroy BLOB objects in the database varies between different database engines. Please see the SQL documentation relevant for the given server to learn how this is actually done. The test programs provided with the SOCI library can be also a simple source of full working examples. The trim function is not currently available for the PostgreSQL backend. Long strings and XML The SOCI library recognizes the fact that long string values are not handled portably and in some databases long string values need to be stored as a different data type. Similar concerns relate to the use of XML values, which are essentially strings at the application level, but can be stored in special database-level field types. In order to facilitate handling of long strings and XML values the following wrapper types are defined: struct xml_type { std::string value; }; struct long_string { std::string value; }; Values of these wrapper types can be used with into and use elements with the database target type that is specifically intended to handle XML and long strings data types. For Oracle, these database-side types are, respectively: XMLType , CLOB For PostgreSQL, these types are: XML text For Firebird, there is no special XML support, but BLOB SUB_TYPE TEXT can be used for storing it, as well as long strings. For ODBC backend, these types depend on the type of the database connected to. In particularly important special case of Microsoft SQL Server, these types are: xml text When using ODBC backend to connect to a PostgreSQL database, please be aware that by default PostgreSQL ODBC driver truncates all \"unknown\" types, such as XML, to maximal varchar type size which is just 256 bytes and so is often insufficient for XML values in practice. It is advised to set the UnknownsAsLongVarchar connection option to 1 to avoid truncating XML strings or use PostgreSQL ODBC driver 9.6.300 or later, which allows the backend to set this option to 1 automatically on connection.","title":"LOBs"},{"location":"lobs/#large-objects-lobs","text":"","title":"Large Objects (LOBs)"},{"location":"lobs/#binary-blobs","text":"The SOCI library provides also an interface for basic operations on large objects (BLOBs - Binary Large OBjects). blob b(sql); // sql is a session object sql << \"select mp3 from mymusic where id = 123\", into(b); The following functions are provided in the blob interface, mimicking the file-like operations: std::size_t get_len(); std::size_t read_from_start(char * buf, std::size_t toRead, std::size_t offset = 0); std::size_t write_from_start(const char * buf, std::size_t toWrite, std::size_t offset = 0); std::size_t append(char const *buf, std::size_t toWrite); void trim(std::size_t newLen); The offset parameter is always counted from the beginning of the BLOB's data.","title":"Binary (BLOBs)"},{"location":"lobs/#portability-notes","text":"The way to define BLOB table columns and create or destroy BLOB objects in the database varies between different database engines. Please see the SQL documentation relevant for the given server to learn how this is actually done. The test programs provided with the SOCI library can be also a simple source of full working examples. The trim function is not currently available for the PostgreSQL backend.","title":"Portability notes"},{"location":"lobs/#long-strings-and-xml","text":"The SOCI library recognizes the fact that long string values are not handled portably and in some databases long string values need to be stored as a different data type. Similar concerns relate to the use of XML values, which are essentially strings at the application level, but can be stored in special database-level field types. In order to facilitate handling of long strings and XML values the following wrapper types are defined: struct xml_type { std::string value; }; struct long_string { std::string value; }; Values of these wrapper types can be used with into and use elements with the database target type that is specifically intended to handle XML and long strings data types. For Oracle, these database-side types are, respectively: XMLType , CLOB For PostgreSQL, these types are: XML text For Firebird, there is no special XML support, but BLOB SUB_TYPE TEXT can be used for storing it, as well as long strings. For ODBC backend, these types depend on the type of the database connected to. In particularly important special case of Microsoft SQL Server, these types are: xml text When using ODBC backend to connect to a PostgreSQL database, please be aware that by default PostgreSQL ODBC driver truncates all \"unknown\" types, such as XML, to maximal varchar type size which is just 256 bytes and so is often insufficient for XML values in practice. It is advised to set the UnknownsAsLongVarchar connection option to 1 to avoid truncating XML strings or use PostgreSQL ODBC driver 9.6.300 or later, which allows the backend to set this option to 1 automatically on connection.","title":"Long strings and XML"},{"location":"logging/","text":"Logging SOCI provides a flexible, but requiring some effort to use, way to log all queries done by the library and a more limited but very simple way to do it. Simple logging The following members of the session class support the basic logging functionality: void set_log_stream(std::ostream * s); std::ostream * get_log_stream() const; std::string get_last_query() const; The first two functions allow to set the user-provided output stream object for logging. The NULL value, which is the default, means that there is no logging. An example use might be: session sql(oracle, \"...\"); ofstream file(\"my_log.txt\"); sql.set_log_stream(&file); // ... Each statement logs its query string before the preparation step (whether explicit or implicit) and therefore logging is effective whether the query succeeds or not. Note that each prepared query is logged only once, independent on how many times it is executed. The get_last_query function allows to retrieve the last used query. Flexible logging using custom loggers If the above is not enough, it is also possible to log the queries in exactly the way you want by deriving your own my_log_impl class from soci::logger_impl and implementing its pure virtual start_query() and do_clone() methods: class my_log_impl : public soci::logger_impl { public: virtual void start_query(std::string const & query) { ... log the given query ... } private: virtual logger_impl* do_clone() const { return new my_log_impl(...); } }; Then simply pass a new, heap-allocated instance of this class to the session object: soci::session sql(...); sql.set_logger(new my_log_impl(...)); and start_query() method of the logger will be called for all queries.","title":"Logging"},{"location":"logging/#logging","text":"SOCI provides a flexible, but requiring some effort to use, way to log all queries done by the library and a more limited but very simple way to do it.","title":"Logging"},{"location":"logging/#simple-logging","text":"The following members of the session class support the basic logging functionality: void set_log_stream(std::ostream * s); std::ostream * get_log_stream() const; std::string get_last_query() const; The first two functions allow to set the user-provided output stream object for logging. The NULL value, which is the default, means that there is no logging. An example use might be: session sql(oracle, \"...\"); ofstream file(\"my_log.txt\"); sql.set_log_stream(&file); // ... Each statement logs its query string before the preparation step (whether explicit or implicit) and therefore logging is effective whether the query succeeds or not. Note that each prepared query is logged only once, independent on how many times it is executed. The get_last_query function allows to retrieve the last used query.","title":"Simple logging"},{"location":"logging/#flexible-logging-using-custom-loggers","text":"If the above is not enough, it is also possible to log the queries in exactly the way you want by deriving your own my_log_impl class from soci::logger_impl and implementing its pure virtual start_query() and do_clone() methods: class my_log_impl : public soci::logger_impl { public: virtual void start_query(std::string const & query) { ... log the given query ... } private: virtual logger_impl* do_clone() const { return new my_log_impl(...); } }; Then simply pass a new, heap-allocated instance of this class to the session object: soci::session sql(...); sql.set_logger(new my_log_impl(...)); and start_query() method of the logger will be called for all queries.","title":"Flexible logging using custom loggers"},{"location":"multithreading/","text":"Multithreading The general rule for multithreading is that SOCI classes are not thread-safe, meaning that their instances should not be used concurrently by multiple threads. The simplest solution for multithreaded code is to set up a separate session object for each thread that needs to inteact with the database. Depending on the design of the client application this might be also the most straightforward approach. For some applications, however, it might be preferable to decouple the set of threads from the set of sessions, so that they can be optimized separately with different resources in mind. The connection_pool class is provided for this purpose: // phase 1: preparation const size_t poolSize = 10; connection_pool pool(poolSize); for (size_t i = 0; i != poolSize; ++i) { session & sql = pool.at(i); sql.open(\"postgresql://dbname=mydb\"); } // phase 2: usage from working threads { session sql(pool); sql << \"select something from somewhere...\"; } // session is returned to the pool automatically The connection_pool 's constructor expects the size of the pool and internally creates an array of session s in the disconnected state. Later, the at function provides non-synchronized access to each element of the array. Note that this function is not thread-safe and exists only to make it easier to set up the pool in the initialization phase. Note that it is not obligatory to use the same connection parameters for all sessions in the pool, although this will be most likely the usual case. The working threads that need to lease a single session from the pool use the dedicated constructor of the session class - this constructor blocks until some session object becomes available in the pool and attaches to it, so that all further uses will be forwarded to the session object managed by the pool. As long as the local session object exists, the associated session in the pool is locked and no other thread will gain access to it. When the local session variable goes out of scope, the related entry in the pool's internal array is released, so that it can be used by other threads. This way, the connection pool guarantees that its session objects are never used by more than one thread at a time. Note that the above scheme is the simplest way to use the connection pool, but it is also constraining in the fact that the session 's constructor can block waiting for the availability of some entry in the pool. For more demanding users there are also low-level functions that allow to lease sessions from the pool with timeout on wait. Please consult the reference for details.","title":"Multi-threading"},{"location":"multithreading/#multithreading","text":"The general rule for multithreading is that SOCI classes are not thread-safe, meaning that their instances should not be used concurrently by multiple threads. The simplest solution for multithreaded code is to set up a separate session object for each thread that needs to inteact with the database. Depending on the design of the client application this might be also the most straightforward approach. For some applications, however, it might be preferable to decouple the set of threads from the set of sessions, so that they can be optimized separately with different resources in mind. The connection_pool class is provided for this purpose: // phase 1: preparation const size_t poolSize = 10; connection_pool pool(poolSize); for (size_t i = 0; i != poolSize; ++i) { session & sql = pool.at(i); sql.open(\"postgresql://dbname=mydb\"); } // phase 2: usage from working threads { session sql(pool); sql << \"select something from somewhere...\"; } // session is returned to the pool automatically The connection_pool 's constructor expects the size of the pool and internally creates an array of session s in the disconnected state. Later, the at function provides non-synchronized access to each element of the array. Note that this function is not thread-safe and exists only to make it easier to set up the pool in the initialization phase. Note that it is not obligatory to use the same connection parameters for all sessions in the pool, although this will be most likely the usual case. The working threads that need to lease a single session from the pool use the dedicated constructor of the session class - this constructor blocks until some session object becomes available in the pool and attaches to it, so that all further uses will be forwarded to the session object managed by the pool. As long as the local session object exists, the associated session in the pool is locked and no other thread will gain access to it. When the local session variable goes out of scope, the related entry in the pool's internal array is released, so that it can be used by other threads. This way, the connection pool guarantees that its session objects are never used by more than one thread at a time. Note that the above scheme is the simplest way to use the connection pool, but it is also constraining in the fact that the session 's constructor can block waiting for the availability of some entry in the pool. For more demanding users there are also low-level functions that allow to lease sessions from the pool with timeout on wait. Please consult the reference for details.","title":"Multithreading"},{"location":"procedures/","text":"Stored Procedures The procedure class provides a convenient mechanism for calling stored procedures: sql << \"create or replace procedure echo(output out varchar2,\" \"input in varchar2) as \" \"begin output := input; end;\"; std::string in(\"my message\"); std::string out; procedure proc = (sql.prepare << \"echo(:output, :input)\", use(out, \"output\"), use(in, \"input\")); proc.execute(true); assert(out == \"my message\"); Portability note The above way of calling stored procedures is provided for portability of the code that might need it. It is of course still possible to call procedures or functions using the syntax supported by the given database server.","title":"Procedures"},{"location":"procedures/#stored-procedures","text":"The procedure class provides a convenient mechanism for calling stored procedures: sql << \"create or replace procedure echo(output out varchar2,\" \"input in varchar2) as \" \"begin output := input; end;\"; std::string in(\"my message\"); std::string out; procedure proc = (sql.prepare << \"echo(:output, :input)\", use(out, \"output\"), use(in, \"input\")); proc.execute(true); assert(out == \"my message\");","title":"Stored Procedures"},{"location":"procedures/#portability-note","text":"The above way of calling stored procedures is provided for portability of the code that might need it. It is of course still possible to call procedures or functions using the syntax supported by the given database server.","title":"Portability note"},{"location":"queries/","text":"Queries Simple SQL statements In many cases, the SQL query is intended to be executed only once, which means that statement parsing and execution can go together. The session class provides a special once member, which triggers parsing and execution of such one-time statements: sql.once << \"drop table persons\"; For shorter syntax, the following form is also allowed: sql << \"drop table persons\"; The IOStream-like interface is exactly what it looks like, so that the statement text can be composed of many parts, involving anything that is streamable (including custom classes, if they have appropriate operator<< ): string tableName = \"persons\"; sql << \"drop table \" << tableName; int id = 123; sql << \"delete from companies where id = \" << id; Query transformation In SOCI 3.2.0, query transformation mechanism was introduced. Query transformation is specified as user-defined unary function or callable function object with input parameter of type std::string which returns object of type std::string as well. The query transformation function is registered for current database session using dedicated session::set_query_transformation method. Then, the transformation function is called with query string as argument just before the query is sent to database backend for execution or for preparation. For one-time statements, query transformation is performed before each execution of statement. For prepared statements, query is transformed only once, before preparation, regardless how many times it is executed. A few short examples how to use query transformation: defined as free function: std::string less_than_ten(std::string query) { return query + \" WHERE price < 10\"; } session sql(postgresql, \"dbname=mydb\"); sql.set_query_transformation(less_than_ten); sql << \"DELETE FROM item\"; defined as function object: struct order { order(std::string const& by) : by_(by) {} std::string operator()(std::string const& query) const { return query + \" ORDER BY \" + by_; } std::string by_; }; char const* query = \"SELECT * FROM product\"; sql.set_query_transformation(order(\"price\")); sql << query; sql.set_query_transformation(order(\"id\")); sql << query; defined as lambda function (since C++11): std::string dep = \"sales\"; sql.set_query_transformation( [&dep](std::string const& query) { return query + \" WHERE department = '\" + dep + \"'\"; }); sql << \"SELECT * FROM employee\"; Query transformations enable users with simple mechanism to apply extra requirements to or interact with SQL statement being executed and that is without changing the SQL statement itself which may be passed from different parts of application. For example, the query transformation may be used to: modify or add clauses of SQL statements (i.e. WHERE clause with new condition) prefix table names with new schema to allow namespaces switch validate SQL statements perform sanitization checking for any unverified input apply database-specific features like add optimization hints to SQL statements (i.e. SELECT /*+RULE*/ A FROM C in Oracle 9)","title":"Queries"},{"location":"queries/#queries","text":"","title":"Queries"},{"location":"queries/#simple-sql-statements","text":"In many cases, the SQL query is intended to be executed only once, which means that statement parsing and execution can go together. The session class provides a special once member, which triggers parsing and execution of such one-time statements: sql.once << \"drop table persons\"; For shorter syntax, the following form is also allowed: sql << \"drop table persons\"; The IOStream-like interface is exactly what it looks like, so that the statement text can be composed of many parts, involving anything that is streamable (including custom classes, if they have appropriate operator<< ): string tableName = \"persons\"; sql << \"drop table \" << tableName; int id = 123; sql << \"delete from companies where id = \" << id;","title":"Simple SQL statements"},{"location":"queries/#query-transformation","text":"In SOCI 3.2.0, query transformation mechanism was introduced. Query transformation is specified as user-defined unary function or callable function object with input parameter of type std::string which returns object of type std::string as well. The query transformation function is registered for current database session using dedicated session::set_query_transformation method. Then, the transformation function is called with query string as argument just before the query is sent to database backend for execution or for preparation. For one-time statements, query transformation is performed before each execution of statement. For prepared statements, query is transformed only once, before preparation, regardless how many times it is executed. A few short examples how to use query transformation: defined as free function: std::string less_than_ten(std::string query) { return query + \" WHERE price < 10\"; } session sql(postgresql, \"dbname=mydb\"); sql.set_query_transformation(less_than_ten); sql << \"DELETE FROM item\"; defined as function object: struct order { order(std::string const& by) : by_(by) {} std::string operator()(std::string const& query) const { return query + \" ORDER BY \" + by_; } std::string by_; }; char const* query = \"SELECT * FROM product\"; sql.set_query_transformation(order(\"price\")); sql << query; sql.set_query_transformation(order(\"id\")); sql << query; defined as lambda function (since C++11): std::string dep = \"sales\"; sql.set_query_transformation( [&dep](std::string const& query) { return query + \" WHERE department = '\" + dep + \"'\"; }); sql << \"SELECT * FROM employee\"; Query transformations enable users with simple mechanism to apply extra requirements to or interact with SQL statement being executed and that is without changing the SQL statement itself which may be passed from different parts of application. For example, the query transformation may be used to: modify or add clauses of SQL statements (i.e. WHERE clause with new condition) prefix table names with new schema to allow namespaces switch validate SQL statements perform sanitization checking for any unverified input apply database-specific features like add optimization hints to SQL statements (i.e. SELECT /*+RULE*/ A FROM C in Oracle 9)","title":"Query transformation"},{"location":"quickstart/","text":"Quickstart The following (complete!) example is purposedly provided without any explanation. #include \"soci.h\" #include \"soci-oracle.h\" #include <iostream> #include <istream> #include <ostream> #include <string> #include <exception> using namespace soci; using namespace std; bool get_name(string &name) { cout << \"Enter name: \"; return cin >> name; } int main() { try { session sql(oracle, \"service=mydb user=john password=secret\"); int count; sql << \"select count(*) from phonebook\", into(count); cout << \"We have \" << count << \" entries in the phonebook.\\n\"; string name; while (get_name(name)) { string phone; indicator ind; sql << \"select phone from phonebook where name = :name\", into(phone, ind), use(name); if (ind == i_ok) { cout << \"The phone number is \" << phone << '\\n'; } else { cout << \"There is no phone for \" << name << '\\n'; } } } catch (exception const &e) { cerr << \"Error: \" << e.what() << '\\n'; } }","title":"Getting Started"},{"location":"quickstart/#quickstart","text":"The following (complete!) example is purposedly provided without any explanation. #include \"soci.h\" #include \"soci-oracle.h\" #include <iostream> #include <istream> #include <ostream> #include <string> #include <exception> using namespace soci; using namespace std; bool get_name(string &name) { cout << \"Enter name: \"; return cin >> name; } int main() { try { session sql(oracle, \"service=mydb user=john password=secret\"); int count; sql << \"select count(*) from phonebook\", into(count); cout << \"We have \" << count << \" entries in the phonebook.\\n\"; string name; while (get_name(name)) { string phone; indicator ind; sql << \"select phone from phonebook where name = :name\", into(phone, ind), use(name); if (ind == i_ok) { cout << \"The phone number is \" << phone << '\\n'; } else { cout << \"There is no phone for \" << name << '\\n'; } } } catch (exception const &e) { cerr << \"Error: \" << e.what() << '\\n'; } }","title":"Quickstart"},{"location":"statements/","text":"Statements Prepared statement Consider the following examples: // Example 1. for (int i = 0; i != 100; ++i) { sql << \"insert into numbers(value) values(\" << i << \")\"; } // Example 2. for (int i = 0; i != 100; ++i) { sql << \"insert into numbers(value) values(:val)\", use(i); } Both examples will populate the table numbers with the values from 0 to 99 . The problem is that in both examples, not only the statement execution is repeated 100 times, but also the statement parsing and preparation. This means unnecessary overhead, even if some of the database servers are likely to optimize the second case. In fact, more complicated queries are likely to suffer in terms of lower performance, because finding the optimal execution plan is quite expensive and here it would be needlessly repeated. Statement preparation The following example uses the class statement explicitly, by preparing the statement only once and repeating its execution with changing data (note the use of prepare member of session class): int i; statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(i)); for (i = 0; i != 100; ++i) { st.execute(true); } The true parameter given to the execute method indicates that the actual data exchange is wanted, so that the meaning of the whole example is \"prepare the statement and exchange the data for each value of variable i \". Portability note: The above syntax is supported for all backends, even if some database server does not actually provide this functionality - in which case the library will internally execute the query in a single phase, without really separating the statement preparation from execution. Rowset and iterator The rowset class provides an alternative means of executing queries and accessing results using STL-like iterator interface. The rowset_iterator type is compatible with requirements defined for input iterator category and is available via iterator and const_iterator definitions in the rowset class. The rowset itself can be used only with select queries. The following example creates an instance of the rowset class and binds query results into elements of int type - in this query only one result column is expected. After executing the query the code iterates through the query result using rowset_iterator : rowset<int> rs = (sql.prepare << \"select values from numbers\"); for (rowset<int>::const_iterator it = rs.begin(); it != rs.end(); ++it) { cout << *it << '\\n'; } Another example shows how to retrieve more complex results, where rowset elements are of type row and therefore use dynamic bindings : // person table has 4 columns rowset<row> rs = (sql.prepare << \"select id, firstname, lastname, gender from person\"); // iteration through the resultset: for (rowset<row>::const_iterator it = rs.begin(); it != rs.end(); ++it) { row const& row = *it; // dynamic data extraction from each row: cout << \"Id: \" << row.get<int>(0) << '\\n' << \"Name: \" << row.get<string>(1) << \" \" << row.get<string>(2) << '\\n' << \"Gender: \" << row.get<string>(3) << endl; } The rowset_iterator can be used with standard algorithms as well: rowset<string> rs = (sql.prepare << \"select firstname from person\"); std::copy(rs.begin(), rs.end(), std::ostream_iterator<std::string>(std::cout, \"\\n\")); Above, the query result contains a single column which is bound to rowset element of type of std::string . All records are sent to standard output using the std::copy algorithm. If you need to use the Core interface with rowset , the following example shows how: row r; statement st(sql); st.alloc(); st.prepare(\"select values from numbers\"); st.define_and_bind(); // after define_and_bind and before execute st.exchange_for_rowset(into(r)); st.execute(false); rowset_iterator<row> it(st, r); rowset_iterator<row> end; for (; it != end; ++it) { // ... access *it } Bulk operations When using some databases, further performance improvements may be possible by having the underlying database API group operations together to reduce network roundtrips. SOCI makes such bulk operations possible by supporting std::vector based types. The following example presents how to insert 100 records in 4 batches. It is also important to note, that size of vector remains equal in every batch interaction. This ensures vector is not reallocated and, what's crucial for the bulk trick, new data should be pushed to the vector before every call to statement::execute : // Example 3. void fill_ids(std::vector<int>& ids) { for (std::size_t i = 0; i < ids.size(); ++i) ids[i] = i; // mimics source of a new ID } const int BATCH_SIZE = 25; std::vector<int> ids(BATCH_SIZE); statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(ids)); for (int i = 0; i != 4; ++i) { fill_ids(ids); st.execute(true); } Given batch size is 25, this example should insert 4 x 25 = 100 records. (Of course, the size of the vector that will achieve optimum performance will vary, depending on many environmental factors, such as network speed.) It is also possible to read all the numbers written in the above examples: int i; statement st = (sql.prepare << \"select value from numbers order by value\", into(i)); st.execute(); while (st.fetch()) { cout << i << '\\n'; } In the above example, the execute method is called with the default parameter false . This means that the statement should be executed, but the actual data exchange will be performed later. Further fetch calls perform the actual data retrieval and cursor traversal. The end-of-cursor condition is indicated by the fetch function returning false . The above code example should be treated as an idiomatic way of reading many rows of data, one at a time . It is further possible to select records in batches into std::vector based types, with the size of the vector specifying the number of records to retrieve in each round trip: std::vector<int> valsOut(100); sql << \"select val from numbers\", into(valsOut); Above, the value 100 indicates that no more values should be retrieved, even if it would be otherwise possible. If there are less rows than asked for, the vector will be appropriately down-sized. The statement::execute() and statement::fetch() functions can also be used to repeatedly select all rows returned by a query into a vector based type: const int BATCH_SIZE = 30; std::vector<int> valsOut(BATCH_SIZE); statement st = (sql.prepare << \"select value from numbers\", into(valsOut)); st.execute(); while (st.fetch()) { std::vector<int>::iterator pos; for(pos = valsOut.begin(); pos != valsOut.end(); ++pos) { cout << *pos << '\\n'; } valsOut.resize(BATCH_SIZE); } Assuming there are 100 rows returned by the query, the above code will retrieve and print all of them. Since the output vector was created with size 30, it will take (at least) 4 calls to fetch() to retrieve all 100 values. Each call to fetch() can potentially resize the vector to a size less than its initial size - how often this happens depends on the underlying database implementation. This explains why the resize(BATCH_SIZE) operation is needed - it is there to ensure that each time the fetch() is called, the vector is ready to accept the next bunch of values. Without this operation, the vector might be getting smaller with subsequent iterations of the loop, forcing more iterations to be performed (because all rows will be read anyway), than really needed. Note the following details about the above examples: After performing fetch() , the vector's size might be less than requested, but fetch() returning true means that there was at least one row retrieved. It is forbidden to manually resize the vector to the size higher than it was initially (this can cause the vector to reallocate its internal buffer and the library can lose track of it). Taking these points under consideration, the above code example should be treated as an idiomatic way of reading many rows by bunches of requested size. Portability note Actually, all supported backends guarantee that the requested number of rows will be read with each fetch and that the vector will never be down-sized, unless for the last fetch, when the end of rowset condition is met. This means that the manual vector resizing is in practice not needed - the vector will keep its size until the end of rowset. The above idiom, however, is provided with future backends in mind, where the constant size of the vector might be too expensive to guarantee and where allowing fetch to down-size the vector even before reaching the end of rowset might buy some performance gains. Statement caching Some backends have some facilities to improve statement parsing and compilation to limit overhead when creating commonly used query. But for backends that does not support this kind optimization you can keep prepared statement and use it later with new references. To do such, prepare a statement as usual, you have to use exchange to bind new variables to statement object, then execute statement and finish by cleaning bound references with bind_clean_up . sql << \"CREATE TABLE test(a INTEGER)\"; { // prepare statement soci::statement stmt = (db.prepare << \"INSERT INTO numbers(value) VALUES(:val)\"); { // first insert int a0 = 0; // update reference stmt.exchange(soci::use(a0)); stmt.define_and_bind(); stmt.execute(true); stmt.bind_clean_up(); } { // come later, second insert int a1 = 1; // update reference stmt.exchange(soci::use(a1)); stmt.define_and_bind(); stmt.execute(true); stmt.bind_clean_up(); } } { std::vector<int> v(10); db << \"SELECT value FROM numbers\", soci::into(v); for (int i = 0; i < v.size(); ++i) std::cout << \"value \" << i << \": \" << v[i] << std::endl; }","title":"Statements"},{"location":"statements/#statements","text":"","title":"Statements"},{"location":"statements/#prepared-statement","text":"Consider the following examples: // Example 1. for (int i = 0; i != 100; ++i) { sql << \"insert into numbers(value) values(\" << i << \")\"; } // Example 2. for (int i = 0; i != 100; ++i) { sql << \"insert into numbers(value) values(:val)\", use(i); } Both examples will populate the table numbers with the values from 0 to 99 . The problem is that in both examples, not only the statement execution is repeated 100 times, but also the statement parsing and preparation. This means unnecessary overhead, even if some of the database servers are likely to optimize the second case. In fact, more complicated queries are likely to suffer in terms of lower performance, because finding the optimal execution plan is quite expensive and here it would be needlessly repeated.","title":"Prepared statement"},{"location":"statements/#statement-preparation","text":"The following example uses the class statement explicitly, by preparing the statement only once and repeating its execution with changing data (note the use of prepare member of session class): int i; statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(i)); for (i = 0; i != 100; ++i) { st.execute(true); } The true parameter given to the execute method indicates that the actual data exchange is wanted, so that the meaning of the whole example is \"prepare the statement and exchange the data for each value of variable i \".","title":"Statement preparation"},{"location":"statements/#portability-note","text":"The above syntax is supported for all backends, even if some database server does not actually provide this functionality - in which case the library will internally execute the query in a single phase, without really separating the statement preparation from execution.","title":"Portability note:"},{"location":"statements/#rowset-and-iterator","text":"The rowset class provides an alternative means of executing queries and accessing results using STL-like iterator interface. The rowset_iterator type is compatible with requirements defined for input iterator category and is available via iterator and const_iterator definitions in the rowset class. The rowset itself can be used only with select queries. The following example creates an instance of the rowset class and binds query results into elements of int type - in this query only one result column is expected. After executing the query the code iterates through the query result using rowset_iterator : rowset<int> rs = (sql.prepare << \"select values from numbers\"); for (rowset<int>::const_iterator it = rs.begin(); it != rs.end(); ++it) { cout << *it << '\\n'; } Another example shows how to retrieve more complex results, where rowset elements are of type row and therefore use dynamic bindings : // person table has 4 columns rowset<row> rs = (sql.prepare << \"select id, firstname, lastname, gender from person\"); // iteration through the resultset: for (rowset<row>::const_iterator it = rs.begin(); it != rs.end(); ++it) { row const& row = *it; // dynamic data extraction from each row: cout << \"Id: \" << row.get<int>(0) << '\\n' << \"Name: \" << row.get<string>(1) << \" \" << row.get<string>(2) << '\\n' << \"Gender: \" << row.get<string>(3) << endl; } The rowset_iterator can be used with standard algorithms as well: rowset<string> rs = (sql.prepare << \"select firstname from person\"); std::copy(rs.begin(), rs.end(), std::ostream_iterator<std::string>(std::cout, \"\\n\")); Above, the query result contains a single column which is bound to rowset element of type of std::string . All records are sent to standard output using the std::copy algorithm. If you need to use the Core interface with rowset , the following example shows how: row r; statement st(sql); st.alloc(); st.prepare(\"select values from numbers\"); st.define_and_bind(); // after define_and_bind and before execute st.exchange_for_rowset(into(r)); st.execute(false); rowset_iterator<row> it(st, r); rowset_iterator<row> end; for (; it != end; ++it) { // ... access *it }","title":"Rowset and iterator"},{"location":"statements/#bulk-operations","text":"When using some databases, further performance improvements may be possible by having the underlying database API group operations together to reduce network roundtrips. SOCI makes such bulk operations possible by supporting std::vector based types. The following example presents how to insert 100 records in 4 batches. It is also important to note, that size of vector remains equal in every batch interaction. This ensures vector is not reallocated and, what's crucial for the bulk trick, new data should be pushed to the vector before every call to statement::execute : // Example 3. void fill_ids(std::vector<int>& ids) { for (std::size_t i = 0; i < ids.size(); ++i) ids[i] = i; // mimics source of a new ID } const int BATCH_SIZE = 25; std::vector<int> ids(BATCH_SIZE); statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(ids)); for (int i = 0; i != 4; ++i) { fill_ids(ids); st.execute(true); } Given batch size is 25, this example should insert 4 x 25 = 100 records. (Of course, the size of the vector that will achieve optimum performance will vary, depending on many environmental factors, such as network speed.) It is also possible to read all the numbers written in the above examples: int i; statement st = (sql.prepare << \"select value from numbers order by value\", into(i)); st.execute(); while (st.fetch()) { cout << i << '\\n'; } In the above example, the execute method is called with the default parameter false . This means that the statement should be executed, but the actual data exchange will be performed later. Further fetch calls perform the actual data retrieval and cursor traversal. The end-of-cursor condition is indicated by the fetch function returning false . The above code example should be treated as an idiomatic way of reading many rows of data, one at a time . It is further possible to select records in batches into std::vector based types, with the size of the vector specifying the number of records to retrieve in each round trip: std::vector<int> valsOut(100); sql << \"select val from numbers\", into(valsOut); Above, the value 100 indicates that no more values should be retrieved, even if it would be otherwise possible. If there are less rows than asked for, the vector will be appropriately down-sized. The statement::execute() and statement::fetch() functions can also be used to repeatedly select all rows returned by a query into a vector based type: const int BATCH_SIZE = 30; std::vector<int> valsOut(BATCH_SIZE); statement st = (sql.prepare << \"select value from numbers\", into(valsOut)); st.execute(); while (st.fetch()) { std::vector<int>::iterator pos; for(pos = valsOut.begin(); pos != valsOut.end(); ++pos) { cout << *pos << '\\n'; } valsOut.resize(BATCH_SIZE); } Assuming there are 100 rows returned by the query, the above code will retrieve and print all of them. Since the output vector was created with size 30, it will take (at least) 4 calls to fetch() to retrieve all 100 values. Each call to fetch() can potentially resize the vector to a size less than its initial size - how often this happens depends on the underlying database implementation. This explains why the resize(BATCH_SIZE) operation is needed - it is there to ensure that each time the fetch() is called, the vector is ready to accept the next bunch of values. Without this operation, the vector might be getting smaller with subsequent iterations of the loop, forcing more iterations to be performed (because all rows will be read anyway), than really needed. Note the following details about the above examples: After performing fetch() , the vector's size might be less than requested, but fetch() returning true means that there was at least one row retrieved. It is forbidden to manually resize the vector to the size higher than it was initially (this can cause the vector to reallocate its internal buffer and the library can lose track of it). Taking these points under consideration, the above code example should be treated as an idiomatic way of reading many rows by bunches of requested size.","title":"Bulk operations"},{"location":"statements/#portability-note_1","text":"Actually, all supported backends guarantee that the requested number of rows will be read with each fetch and that the vector will never be down-sized, unless for the last fetch, when the end of rowset condition is met. This means that the manual vector resizing is in practice not needed - the vector will keep its size until the end of rowset. The above idiom, however, is provided with future backends in mind, where the constant size of the vector might be too expensive to guarantee and where allowing fetch to down-size the vector even before reaching the end of rowset might buy some performance gains.","title":"Portability note"},{"location":"statements/#statement-caching","text":"Some backends have some facilities to improve statement parsing and compilation to limit overhead when creating commonly used query. But for backends that does not support this kind optimization you can keep prepared statement and use it later with new references. To do such, prepare a statement as usual, you have to use exchange to bind new variables to statement object, then execute statement and finish by cleaning bound references with bind_clean_up . sql << \"CREATE TABLE test(a INTEGER)\"; { // prepare statement soci::statement stmt = (db.prepare << \"INSERT INTO numbers(value) VALUES(:val)\"); { // first insert int a0 = 0; // update reference stmt.exchange(soci::use(a0)); stmt.define_and_bind(); stmt.execute(true); stmt.bind_clean_up(); } { // come later, second insert int a1 = 1; // update reference stmt.exchange(soci::use(a1)); stmt.define_and_bind(); stmt.execute(true); stmt.bind_clean_up(); } } { std::vector<int> v(10); db << \"SELECT value FROM numbers\", soci::into(v); for (int i = 0; i < v.size(); ++i) std::cout << \"value \" << i << \": \" << v[i] << std::endl; }","title":"Statement caching"},{"location":"structure/","text":"Structure The picture below presents the structure of the library, together with its clients and servers. The boxes filled with cyan represent components that are part of the library distribution. The SOCI library is extensible in the following ways: More backends can be added to target various database servers. More interfaces can be defined on top of common backend interface. Other languages can use the simple interface , which was designed specifically for the \"C\" calling convention to ensure easy binding. The core part of the library and the backend interface definition are placed in the core directory of the library distribution. The soci-backend.h file is an internal abstract interface to the actual backends, which are needed to perform operations on the given database server. Normally, the C++ client program needs to interface with the soci.h header and the header(s) relevant to the given backend(s) (for example, soci-oracle.h ), although with dynamic backend loading this can be avoided. It is possible for the same program to use many backends at the same time. Everything in SOCI is declared in the namespace soci . All code examples presented in this documentation assume that your code begins with something like: #include <soci/soci.h> // other includes if necessary using namespace soci; // ... Note: In simple programs, #include for the relevant backend is needed only in the file where the session object is created with explicit name of the backend factory. The example program on the previous page shows the appropriate #include directive for the Oracle backend. It is also possible to name backends at run-time as part of the connection string, in which case no backend-specific #include directive is necessary.","title":"Library Structure"},{"location":"structure/#structure","text":"The picture below presents the structure of the library, together with its clients and servers. The boxes filled with cyan represent components that are part of the library distribution. The SOCI library is extensible in the following ways: More backends can be added to target various database servers. More interfaces can be defined on top of common backend interface. Other languages can use the simple interface , which was designed specifically for the \"C\" calling convention to ensure easy binding. The core part of the library and the backend interface definition are placed in the core directory of the library distribution. The soci-backend.h file is an internal abstract interface to the actual backends, which are needed to perform operations on the given database server. Normally, the C++ client program needs to interface with the soci.h header and the header(s) relevant to the given backend(s) (for example, soci-oracle.h ), although with dynamic backend loading this can be avoided. It is possible for the same program to use many backends at the same time. Everything in SOCI is declared in the namespace soci . All code examples presented in this documentation assume that your code begins with something like: #include <soci/soci.h> // other includes if necessary using namespace soci; // ... Note: In simple programs, #include for the relevant backend is needed only in the file where the session object is created with explicit name of the backend factory. The example program on the previous page shows the appropriate #include directive for the Oracle backend. It is also possible to name backends at run-time as part of the connection string, in which case no backend-specific #include directive is necessary.","title":"Structure"},{"location":"transactions/","text":"Transactions The SOCI library provides the following members of the session class for transaction management: void begin(); void commit(); void rollback(); In addition to the above there is a RAII wrapper that allows to associate the transaction with the given scope of code: class transaction { public: explicit transaction(session & sql); ~transaction(); void commit(); void rollback(); private: // ... }; The object of class transaction will roll back automatically when the object is destroyed (usually as a result of leaving the scope) and when the transaction was not explicitly committed before that. A typical usage pattern for this class might be: { transaction tr(sql); sql << \"insert into ...\"; sql << \"more sql queries ...\"; // ... tr.commit(); } With the above pattern the transaction is committed only when the code successfully reaches the end of block. If some exception is thrown before that, the scope will be left without reaching the final statement and the transaction object will automatically roll back in its destructor.","title":"Transactions"},{"location":"transactions/#transactions","text":"The SOCI library provides the following members of the session class for transaction management: void begin(); void commit(); void rollback(); In addition to the above there is a RAII wrapper that allows to associate the transaction with the given scope of code: class transaction { public: explicit transaction(session & sql); ~transaction(); void commit(); void rollback(); private: // ... }; The object of class transaction will roll back automatically when the object is destroyed (usually as a result of leaving the scope) and when the transaction was not explicitly committed before that. A typical usage pattern for this class might be: { transaction tr(sql); sql << \"insert into ...\"; sql << \"more sql queries ...\"; // ... tr.commit(); } With the above pattern the transaction is committed only when the code successfully reaches the end of block. If some exception is thrown before that, the scope will be left without reaching the final statement and the transaction object will automatically roll back in its destructor.","title":"Transactions"},{"location":"types/","text":"Data Types Static binding The static binding for types is most useful when the types used in the database are known at compile time - this was already presented above with the help of into and use functions. The following types are currently supported for use with into and use expressions: char (for character values) short , int , unsigned long , long long , double (for numeric values) std::string (for string values) std::tm (for datetime values) soci::statement (for nested statements and PL/SQL cursors) soci::blob (for Binary Large OBjects) soci::row_id (for row identifiers) See the test code that accompanies the library to see how each of these types is used. Static binding for bulk operations Bulk inserts, updates, and selects are supported through the following std::vector based into and use types: std::vector<char> std::vector<short> std::vector<int> std::vector<unsigned long> std::vector<long long> std::vector<double> std::vector<std::string> std::vector<std::tm> Use of the vector based types mirrors that of the standard types, with the size of the vector used to specify the number of records to process at a time. See below for examples. Bulk operations are supported also for std::vector s of the user-provided types that have appropriate conversion routines defines. Dynamic binding For certain applications it is desirable to be able to select data from arbitrarily structured tables (e.g. via \" select * from ... \") and format the resulting data based upon its type. SOCI supports binding dynamic resultset through the soci::row and soci::column_properties classes. Data is selected into a row object, which holds column_properties objects describing the attributes of data contained in each column. Once the data type for each column is known, the data can be formatted appropriately. For example, the code below creates an XML document from a selected row of data from an arbitrary table: row r; sql << \"select * from some_table\", into(r); std::ostringstream doc; doc << \"<row>\" << std::endl; for(std::size_t i = 0; i != r.size(); ++i) { const column_properties & props = r.get_properties(i); doc << '<' << props.get_name() << '>'; switch(props.get_data_type()) { case dt_string: doc << r.get<std::string>(i); break; case dt_double: doc << r.get<double>(i); break; case dt_integer: doc << r.get<int>(i); break; case dt_long_long: doc << r.get<long long>(i); break; case dt_unsigned_long_long: doc << r.get<unsigned long long>(i); break; case dt_date: std::tm when = r.get<std::tm>(i); doc << asctime(&when); break; } doc << \"</\" << props.get_name() << '>' << std::endl; } doc << \"</row>\"; The type T parameter that should be passed to row::get<T>() depends on the SOCI data type that is returned from column_properties::get_data_type() . row::get<T>() throws an exception of type std::bad_cast if an incorrect type T is requested. SOCI Data Type row::get<T> specialization dt_double double dt_integer int dt_long_long long long dt_unsigned_long_long unsigned long long dt_string std::string dt_date std::tm The mapping of underlying database column types to SOCI datatypes is database specific. See the backend documentation for details. The row also provides access to indicators for each column: row r; sql << \"select name from some_table where id = 1\", into(r); if (r.get_indicator(0) != soci::i_null) { std::cout << r.get<std::string>(0); } It is also possible to extract data from the row object using its stream-like interface, where each extracted variable should have matching type respective to its position in the chain: row r; sql << \"select name, address, age from persons where id = 123\", into(r); string name, address; int age; r >> name >> address >> age; Note, however, that this interface is not compatible with the standard std::istream class and that it is only possible to extract a single row at a time - for \"safety\" reasons the row boundary is preserved and it is necessary to perform the fetch operation explicitly for each consecutive row. User-defined C++ types SOCI can be easily extended with support for user-defined datatypes. The extension mechanism relies on appropriate specialization of the type_conversion structure that converts to and from one of the following SOCI base types: double int long long unsigned long long std::string char std::tm There are three required class members for a valid type_conversion specialization: the base_type type definition, aliasing either one of the base types or another ser-defined type the from_base() static member function, converting from the base type the to_base() static member function, converting to the base type Note that no database-specific code is required to define user conversion. The following example shows how the user can extend SOCI to support his own type MyInt , which here is some wrapper for the fundamental int type: class MyInt { public: MyInt() {} MyInt(int i) : i_(i) {} void set(int i) { i_ = i; } int get() const { return i_; } private: int i_; }; namespace soci { template <> struct type_conversion<MyInt> { typedef int base_type; static void from_base(int i, indicator ind, MyInt & mi) { if (ind == i_null) { throw soci_error(\"Null value not allowed for this type\"); } mi.set(i); } static void to_base(const MyInt & mi, int & i, indicator & ind) { i = mi.get(); ind = i_ok; } }; } The above specialization for soci::type_conversion<MyInt> is enough to enable the following: MyInt i; sql << \"select count(*) from person\", into(i); cout << \"We have \" << i.get() << \" persons in the database.\\n\"; Note that there is a number of types from the Boost library integrated with SOCI out of the box, see Integration with Boost for complete description. Use these as examples of conversions for more complext data types. Another possibility to extend SOCI with custom data types is to use the into_type<T> and use_type<T> class templates, which specializations can be user-provided. These specializations need to implement the interface defined by, respectively, the into_type_base and use_type_base classes. Note that when specializing these template classes the only convention is that when the indicator variable is used (see below), it should appear in the second position. Please refer to the library source code to see how this is done for the standard types. Object-Relational Mapping SOCI provides a class called values specifically to enable object-relational mapping via type_conversion specializations. For example, the following code maps a Person object to and from a database table containing columns \"ID\" , \"FIRST_NAME\" , \"LAST_NAME\" , and \"GENDER\" . Note that the mapping is non-invasive - the Person object itself does not contain any SOCI-specific code: struct Person { int id; std::string firstName; std::string lastName; std::string gender; }; namespace soci { template<> struct type_conversion<Person> { typedef values base_type; static void from_base(values const & v, indicator /* ind */, Person & p) { p.id = v.get<int>(\"ID\"); p.firstName = v.get<std::string>(\"FIRST_NAME\"); p.lastName = v.get<std::string>(\"LAST_NAME\"); // p.gender will be set to the default value \"unknown\" // when the column is null: p.gender = v.get<std::string>(\"GENDER\", \"unknown\"); // alternatively, the indicator can be tested directly: // if (v.indicator(\"GENDER\") == i_null) // { // p.gender = \"unknown\"; // } // else // { // p.gender = v.get<std::string>(\"GENDER\"); // } } static void to_base(const Person & p, values & v, indicator & ind) { v.set(\"ID\", p.id); v.set(\"FIRST_NAME\", p.firstName); v.set(\"LAST_NAME\", p.lastName); v.set(\"GENDER\", p.gender, p.gender.empty() ? i_null : i_ok); ind = i_ok; } }; } With the above type_conversion specialization in place, it is possible to use Person directly with SOCI: session sql(oracle, \"service=db1 user=scott password=tiger\"); Person p; p.id = 1; p.lastName = \"Smith\"; p.firstName = \"Pat\"; sql << \"insert into person(id, first_name, last_name) \" \"values(:ID, :FIRST_NAME, :LAST_NAME)\", use(p); Person p1; sql << \"select * from person\", into(p1); assert(p1.id == 1); assert(p1.firstName + p.lastName == \"PatSmith\"); assert(p1.gender == \"unknown\"); p.firstName = \"Patricia\"; sql << \"update person set first_name = :FIRST_NAME \" \"where id = :ID\", use(p); Note: The values class is currently not suited for use outside of type_conversion specializations. It is specially designed to facilitate object-relational mapping when used as shown above.","title":"Data Types"},{"location":"types/#data-types","text":"","title":"Data Types"},{"location":"types/#static-binding","text":"The static binding for types is most useful when the types used in the database are known at compile time - this was already presented above with the help of into and use functions. The following types are currently supported for use with into and use expressions: char (for character values) short , int , unsigned long , long long , double (for numeric values) std::string (for string values) std::tm (for datetime values) soci::statement (for nested statements and PL/SQL cursors) soci::blob (for Binary Large OBjects) soci::row_id (for row identifiers) See the test code that accompanies the library to see how each of these types is used.","title":"Static binding"},{"location":"types/#static-binding-for-bulk-operations","text":"Bulk inserts, updates, and selects are supported through the following std::vector based into and use types: std::vector<char> std::vector<short> std::vector<int> std::vector<unsigned long> std::vector<long long> std::vector<double> std::vector<std::string> std::vector<std::tm> Use of the vector based types mirrors that of the standard types, with the size of the vector used to specify the number of records to process at a time. See below for examples. Bulk operations are supported also for std::vector s of the user-provided types that have appropriate conversion routines defines.","title":"Static binding for bulk operations"},{"location":"types/#dynamic-binding","text":"For certain applications it is desirable to be able to select data from arbitrarily structured tables (e.g. via \" select * from ... \") and format the resulting data based upon its type. SOCI supports binding dynamic resultset through the soci::row and soci::column_properties classes. Data is selected into a row object, which holds column_properties objects describing the attributes of data contained in each column. Once the data type for each column is known, the data can be formatted appropriately. For example, the code below creates an XML document from a selected row of data from an arbitrary table: row r; sql << \"select * from some_table\", into(r); std::ostringstream doc; doc << \"<row>\" << std::endl; for(std::size_t i = 0; i != r.size(); ++i) { const column_properties & props = r.get_properties(i); doc << '<' << props.get_name() << '>'; switch(props.get_data_type()) { case dt_string: doc << r.get<std::string>(i); break; case dt_double: doc << r.get<double>(i); break; case dt_integer: doc << r.get<int>(i); break; case dt_long_long: doc << r.get<long long>(i); break; case dt_unsigned_long_long: doc << r.get<unsigned long long>(i); break; case dt_date: std::tm when = r.get<std::tm>(i); doc << asctime(&when); break; } doc << \"</\" << props.get_name() << '>' << std::endl; } doc << \"</row>\"; The type T parameter that should be passed to row::get<T>() depends on the SOCI data type that is returned from column_properties::get_data_type() . row::get<T>() throws an exception of type std::bad_cast if an incorrect type T is requested. SOCI Data Type row::get<T> specialization dt_double double dt_integer int dt_long_long long long dt_unsigned_long_long unsigned long long dt_string std::string dt_date std::tm The mapping of underlying database column types to SOCI datatypes is database specific. See the backend documentation for details. The row also provides access to indicators for each column: row r; sql << \"select name from some_table where id = 1\", into(r); if (r.get_indicator(0) != soci::i_null) { std::cout << r.get<std::string>(0); } It is also possible to extract data from the row object using its stream-like interface, where each extracted variable should have matching type respective to its position in the chain: row r; sql << \"select name, address, age from persons where id = 123\", into(r); string name, address; int age; r >> name >> address >> age; Note, however, that this interface is not compatible with the standard std::istream class and that it is only possible to extract a single row at a time - for \"safety\" reasons the row boundary is preserved and it is necessary to perform the fetch operation explicitly for each consecutive row.","title":"Dynamic binding"},{"location":"types/#user-defined-c-types","text":"SOCI can be easily extended with support for user-defined datatypes. The extension mechanism relies on appropriate specialization of the type_conversion structure that converts to and from one of the following SOCI base types: double int long long unsigned long long std::string char std::tm There are three required class members for a valid type_conversion specialization: the base_type type definition, aliasing either one of the base types or another ser-defined type the from_base() static member function, converting from the base type the to_base() static member function, converting to the base type Note that no database-specific code is required to define user conversion. The following example shows how the user can extend SOCI to support his own type MyInt , which here is some wrapper for the fundamental int type: class MyInt { public: MyInt() {} MyInt(int i) : i_(i) {} void set(int i) { i_ = i; } int get() const { return i_; } private: int i_; }; namespace soci { template <> struct type_conversion<MyInt> { typedef int base_type; static void from_base(int i, indicator ind, MyInt & mi) { if (ind == i_null) { throw soci_error(\"Null value not allowed for this type\"); } mi.set(i); } static void to_base(const MyInt & mi, int & i, indicator & ind) { i = mi.get(); ind = i_ok; } }; } The above specialization for soci::type_conversion<MyInt> is enough to enable the following: MyInt i; sql << \"select count(*) from person\", into(i); cout << \"We have \" << i.get() << \" persons in the database.\\n\"; Note that there is a number of types from the Boost library integrated with SOCI out of the box, see Integration with Boost for complete description. Use these as examples of conversions for more complext data types. Another possibility to extend SOCI with custom data types is to use the into_type<T> and use_type<T> class templates, which specializations can be user-provided. These specializations need to implement the interface defined by, respectively, the into_type_base and use_type_base classes. Note that when specializing these template classes the only convention is that when the indicator variable is used (see below), it should appear in the second position. Please refer to the library source code to see how this is done for the standard types.","title":"User-defined C++ types"},{"location":"types/#object-relational-mapping","text":"SOCI provides a class called values specifically to enable object-relational mapping via type_conversion specializations. For example, the following code maps a Person object to and from a database table containing columns \"ID\" , \"FIRST_NAME\" , \"LAST_NAME\" , and \"GENDER\" . Note that the mapping is non-invasive - the Person object itself does not contain any SOCI-specific code: struct Person { int id; std::string firstName; std::string lastName; std::string gender; }; namespace soci { template<> struct type_conversion<Person> { typedef values base_type; static void from_base(values const & v, indicator /* ind */, Person & p) { p.id = v.get<int>(\"ID\"); p.firstName = v.get<std::string>(\"FIRST_NAME\"); p.lastName = v.get<std::string>(\"LAST_NAME\"); // p.gender will be set to the default value \"unknown\" // when the column is null: p.gender = v.get<std::string>(\"GENDER\", \"unknown\"); // alternatively, the indicator can be tested directly: // if (v.indicator(\"GENDER\") == i_null) // { // p.gender = \"unknown\"; // } // else // { // p.gender = v.get<std::string>(\"GENDER\"); // } } static void to_base(const Person & p, values & v, indicator & ind) { v.set(\"ID\", p.id); v.set(\"FIRST_NAME\", p.firstName); v.set(\"LAST_NAME\", p.lastName); v.set(\"GENDER\", p.gender, p.gender.empty() ? i_null : i_ok); ind = i_ok; } }; } With the above type_conversion specialization in place, it is possible to use Person directly with SOCI: session sql(oracle, \"service=db1 user=scott password=tiger\"); Person p; p.id = 1; p.lastName = \"Smith\"; p.firstName = \"Pat\"; sql << \"insert into person(id, first_name, last_name) \" \"values(:ID, :FIRST_NAME, :LAST_NAME)\", use(p); Person p1; sql << \"select * from person\", into(p1); assert(p1.id == 1); assert(p1.firstName + p.lastName == \"PatSmith\"); assert(p1.gender == \"unknown\"); p.firstName = \"Patricia\"; sql << \"update person set first_name = :FIRST_NAME \" \"where id = :ID\", use(p); Note: The values class is currently not suited for use outside of type_conversion specializations. It is specially designed to facilitate object-relational mapping when used as shown above.","title":"Object-Relational Mapping"},{"location":"utilities/","text":"Utilities SOCI provides a portable abstraction for selection of database queries. DDL SOCI supports some basic methods to construct portable DDL queries. That is, instead of writing explicit SQL statement for creating or modifying tables, it is possible to use dedicated SOCI functions, which prepare appropriate DDL statements behind the scenes, thus enabling the user application to create basic database structures in a way that is portable across different database servers. Note that the actual support for these functions depends on the actual backend implementation. It is possible to create a new table in a single statement: sql.create_table(\"t1\").column(\"i\", soci::dt_integer).column(\"j\", soci::dt_integer); Above, table \"t1\" will be created with two columns (\"i\", \"j\") of type integer. It is also possible to build similar statements piece by piece, which is useful if the table structure is computed dynamically: { soci::ddl_type ddl = sql.create_table(\"t2\"); ddl.column(\"i\", soci::dt_integer); ddl.column(\"j\", soci::dt_integer); ddl.column(\"k\", soci::dt_integer)(\"not null\"); ddl.primary_key(\"t2_pk\", \"j\"); } The actual statement is executed at the end of above block, when the ddl object goes out of scope. The \"not null\" constraint was added to the definition of column \"k\" explicitly and in fact any piece of SQL can be inserted this way - with the obvious caveat of having limited portability (the \"not null\" piece seems to be universaly portable). Columns can be added to and dropped from already existing tables as well: sql.add_column(\"t1\", \"k\", soci::dt_integer); // or with constraint: //sql.add_column(\"t1\", \"k\", soci::dt_integer)(\"not null\"); sql.drop_column(\"t1\", \"i\"); If needed, precision and scale can be defined with additional integer arguments to functions that create columns: sql.add_column(\"t1\", \"s\", soci::dt_string, precision); sql.add_column(\"t1\", \"d\", soci::dt_double, precision, scale); Tables with foreign keys to each other can be also created: { soci::ddl_type ddl = sql.create_table(\"t3\"); ddl.column(\"x\", soci::dt_integer); ddl.column(\"y\", soci::dt_integer); ddl.foreign_key(\"t3_fk\", \"x\", \"t2\", \"j\"); } Tables can be dropped, too: sql.drop_table(\"t1\"); sql.drop_table(\"t3\"); sql.drop_table(\"t2\"); Note that due to the differences in the set of types that are actually supported on the target database server, the type mappings, as well as precision and scales, might be different, even in the way that makes them impossible to portably recover with metadata queries. In the category of portability utilities, the following functions are also available: sql.empty_blob() the above call returns the string containing expression that represents an empty BLOB value in the given target backend. This expression can be used as part of a bigger SQL statement, for example: sql << \"insert into my_table (x) values (\" + sql.empty_blob() + \")\"; and: sql.nvl() the above call returns the string containing the name of the SQL function that implements the NVL or COALESCE operation in the given target backend, for example: sql << \"select name, \" + sql.nvl() + \"(phone, \\'UNKNOWN\\') from phone_book\"; Note: empty_blob and nvl are implemented in Oracle, PostgreSQL and SQLite3 backends; for other backends their behaviour is as for PostgreSQL. DML Only two related functions are currently available in this category: get_dummy_from_clause() can be used to construct select statements that don't operate on any table in a portable way, as while some databases allow simply omitting the from clause in this case, others -- e.g. Oracle -- still require providing some syntactically valid from clause even if it is not used. To use this function, simply append the result of this function to the statement: double databasePi; session << (\"select 4*atan(1)\" + session.get_dummy_from_clause()), into(databasePi); If just the name of the dummy table is needed, and not the full clause, you can use get_dummy_from_table() to obtain it. Notice that both functions require the session to be connected as their result depends on the database it is connected to. Database Metadata It is possible to portably query the database server to obtain basic metadata information. In order to get the list of table names in the current schema: std::vector<std::string> names(100); sql.get_table_names(), into(names); alternatively: std::string name; soci::statement st = (sql.prepare_table_names(), into(name)); st.execute(); while (st.fetch()) { // ... } Similarly, to get the description of all columns in the given table: soci::column_info ci; soci::statement st = (sql.prepare_column_descriptions(table_name), into(ci)); st.execute(); while (st.fetch()) { // ci fields describe each column in turn }","title":"Utilities"},{"location":"utilities/#utilities","text":"SOCI provides a portable abstraction for selection of database queries.","title":"Utilities"},{"location":"utilities/#ddl","text":"SOCI supports some basic methods to construct portable DDL queries. That is, instead of writing explicit SQL statement for creating or modifying tables, it is possible to use dedicated SOCI functions, which prepare appropriate DDL statements behind the scenes, thus enabling the user application to create basic database structures in a way that is portable across different database servers. Note that the actual support for these functions depends on the actual backend implementation. It is possible to create a new table in a single statement: sql.create_table(\"t1\").column(\"i\", soci::dt_integer).column(\"j\", soci::dt_integer); Above, table \"t1\" will be created with two columns (\"i\", \"j\") of type integer. It is also possible to build similar statements piece by piece, which is useful if the table structure is computed dynamically: { soci::ddl_type ddl = sql.create_table(\"t2\"); ddl.column(\"i\", soci::dt_integer); ddl.column(\"j\", soci::dt_integer); ddl.column(\"k\", soci::dt_integer)(\"not null\"); ddl.primary_key(\"t2_pk\", \"j\"); } The actual statement is executed at the end of above block, when the ddl object goes out of scope. The \"not null\" constraint was added to the definition of column \"k\" explicitly and in fact any piece of SQL can be inserted this way - with the obvious caveat of having limited portability (the \"not null\" piece seems to be universaly portable). Columns can be added to and dropped from already existing tables as well: sql.add_column(\"t1\", \"k\", soci::dt_integer); // or with constraint: //sql.add_column(\"t1\", \"k\", soci::dt_integer)(\"not null\"); sql.drop_column(\"t1\", \"i\"); If needed, precision and scale can be defined with additional integer arguments to functions that create columns: sql.add_column(\"t1\", \"s\", soci::dt_string, precision); sql.add_column(\"t1\", \"d\", soci::dt_double, precision, scale); Tables with foreign keys to each other can be also created: { soci::ddl_type ddl = sql.create_table(\"t3\"); ddl.column(\"x\", soci::dt_integer); ddl.column(\"y\", soci::dt_integer); ddl.foreign_key(\"t3_fk\", \"x\", \"t2\", \"j\"); } Tables can be dropped, too: sql.drop_table(\"t1\"); sql.drop_table(\"t3\"); sql.drop_table(\"t2\"); Note that due to the differences in the set of types that are actually supported on the target database server, the type mappings, as well as precision and scales, might be different, even in the way that makes them impossible to portably recover with metadata queries. In the category of portability utilities, the following functions are also available: sql.empty_blob() the above call returns the string containing expression that represents an empty BLOB value in the given target backend. This expression can be used as part of a bigger SQL statement, for example: sql << \"insert into my_table (x) values (\" + sql.empty_blob() + \")\"; and: sql.nvl() the above call returns the string containing the name of the SQL function that implements the NVL or COALESCE operation in the given target backend, for example: sql << \"select name, \" + sql.nvl() + \"(phone, \\'UNKNOWN\\') from phone_book\"; Note: empty_blob and nvl are implemented in Oracle, PostgreSQL and SQLite3 backends; for other backends their behaviour is as for PostgreSQL.","title":"DDL"},{"location":"utilities/#dml","text":"Only two related functions are currently available in this category: get_dummy_from_clause() can be used to construct select statements that don't operate on any table in a portable way, as while some databases allow simply omitting the from clause in this case, others -- e.g. Oracle -- still require providing some syntactically valid from clause even if it is not used. To use this function, simply append the result of this function to the statement: double databasePi; session << (\"select 4*atan(1)\" + session.get_dummy_from_clause()), into(databasePi); If just the name of the dummy table is needed, and not the full clause, you can use get_dummy_from_table() to obtain it. Notice that both functions require the session to be connected as their result depends on the database it is connected to.","title":"DML"},{"location":"utilities/#database-metadata","text":"It is possible to portably query the database server to obtain basic metadata information. In order to get the list of table names in the current schema: std::vector<std::string> names(100); sql.get_table_names(), into(names); alternatively: std::string name; soci::statement st = (sql.prepare_table_names(), into(name)); st.execute(); while (st.fetch()) { // ... } Similarly, to get the description of all columns in the given table: soci::column_info ci; soci::statement st = (sql.prepare_column_descriptions(table_name), into(ci)); st.execute(); while (st.fetch()) { // ci fields describe each column in turn }","title":"Database Metadata"},{"location":"vagrant/","text":"Vagrant SOCI Vagrant used to build and provision virtual environments for hassle-free SOCI development. Features Ubuntu 14.04 (Trusty) virtual machine Multi-machine set-up with three VMs: soci , oracle , db2 . Support networking between the configured machines. soci.vm : hostname: vmsoci.local build essentials core dependencies backend dependencies FOSS databases installed with sample soci user and instance pre-configured during provision, automatically clones and builds SOCI from master branch. db2.vm : hostname: vmdb2.local IBM DB2 Express-C 9.7 installed from archive.canonical.com packages. oracle.vm : TODO : provision with Oracle XE SOCI local git repository (aka $SOCI_HOME ) is automatically shared on host and all guest machines. Prerequisites Speedy broadband, time and coffee. Recommended 4GB or much more RAM (tested with 16GB only). SOCI DB2 backend The soci.vm will be configured properly to build the DB2 backend only if it is provisioned with complete DB2 CLI client (libraries and headers). You need to download \"IBM Data Server Driver Package (DS Driver)\" manually and make it visible to Vagrant: Go to IBM Data Server Client Packages . Download \"IBM Data Server Driver Package (DS Driver)\". Copy the package to ${SOCI_HOME}/tmp directory, on host machine. Usage Below, simple and easy development workflow with Vagrant is outlined: Boot vagrant up or boot VMs selectively: vagrant up {soci|db2} First time you run it, be patient as Vagrant downloads VM box and provisions it installing all the necessary packages. You can SSH into the machine vagrant ssh {soci|db2} Run git commands can either from host or VM soci (once connected via SSH) cd /vagrant # aka $SOCI_HOME git pull origin master You can edit source code on both, on host or VM soci . For example, edit in your favourite editor on host machine, then build, run, test and debug on guest machine from command line. Alternatively, edit and build on host machine using your favourite IDE, then test and debug connecting to DBs on guest machines via network. Build on VM soci vagrant ssh soci cd /vagrant # aka $SOCI_HOME cd soci-build # aka $SOCI_BUILD make You can also execute the build.h script provided to run CMake and make vagrant ssh soci cd $SOCI_BUILD /vagrant/scripts/vagrant/build.sh Debug, only on VM soci , for example, with gdb or remotely Visual Studio 2017. Teardown vagrant {suspend|halt|destroy} {soci|db2} Check Vagrant command-line interface for complete list of commands. Environment variables All variables available to the vagrant user on the VMs are defined in and sourced from /vagrant/scripts/vagrant/common.env : SOCI_HOME where SOCI master is cloned ( /vagrant on VM soci ) SOCI_BUILD where CMake generates build configuration ( /home/vagrant/soci-build on VM soci ) SOCI_HOST network accessible VM soci hostname ( ping vmsoci.local ) SOCI_USER default database user and database name SOCI_PASS default database password for both, SOCI_USER and root/sysdba of particular database. SOCI_DB2_HOST network accessible VM db2 hostname ( ping vmdb2.local ) SOCI_DB2_USER admin username to DB2 instance. SOCI_DB2_USER admin password to DB2 instance. Note, those variables are also used by provision scripts to set up databases. Troubleshooting Analyze vagrant up output. On Windows, prefer vagrant ssh from inside MinGW Shell where ssh.exe is available or learn how to use Vagrant with PuTTY. If you modify any of scripts/vagrant/*.sh scripts, ensure they have unified end-of-line characters to LF only. Otherwise, provisioning steps may fail.","title":"Vagrant"},{"location":"vagrant/#vagrant-soci","text":"Vagrant used to build and provision virtual environments for hassle-free SOCI development.","title":"Vagrant SOCI"},{"location":"vagrant/#features","text":"Ubuntu 14.04 (Trusty) virtual machine Multi-machine set-up with three VMs: soci , oracle , db2 . Support networking between the configured machines. soci.vm : hostname: vmsoci.local build essentials core dependencies backend dependencies FOSS databases installed with sample soci user and instance pre-configured during provision, automatically clones and builds SOCI from master branch. db2.vm : hostname: vmdb2.local IBM DB2 Express-C 9.7 installed from archive.canonical.com packages. oracle.vm : TODO : provision with Oracle XE SOCI local git repository (aka $SOCI_HOME ) is automatically shared on host and all guest machines.","title":"Features"},{"location":"vagrant/#prerequisites","text":"Speedy broadband, time and coffee. Recommended 4GB or much more RAM (tested with 16GB only).","title":"Prerequisites"},{"location":"vagrant/#soci-db2-backend","text":"The soci.vm will be configured properly to build the DB2 backend only if it is provisioned with complete DB2 CLI client (libraries and headers). You need to download \"IBM Data Server Driver Package (DS Driver)\" manually and make it visible to Vagrant: Go to IBM Data Server Client Packages . Download \"IBM Data Server Driver Package (DS Driver)\". Copy the package to ${SOCI_HOME}/tmp directory, on host machine.","title":"SOCI DB2 backend"},{"location":"vagrant/#usage","text":"Below, simple and easy development workflow with Vagrant is outlined: Boot vagrant up or boot VMs selectively: vagrant up {soci|db2} First time you run it, be patient as Vagrant downloads VM box and provisions it installing all the necessary packages. You can SSH into the machine vagrant ssh {soci|db2} Run git commands can either from host or VM soci (once connected via SSH) cd /vagrant # aka $SOCI_HOME git pull origin master You can edit source code on both, on host or VM soci . For example, edit in your favourite editor on host machine, then build, run, test and debug on guest machine from command line. Alternatively, edit and build on host machine using your favourite IDE, then test and debug connecting to DBs on guest machines via network. Build on VM soci vagrant ssh soci cd /vagrant # aka $SOCI_HOME cd soci-build # aka $SOCI_BUILD make You can also execute the build.h script provided to run CMake and make vagrant ssh soci cd $SOCI_BUILD /vagrant/scripts/vagrant/build.sh Debug, only on VM soci , for example, with gdb or remotely Visual Studio 2017. Teardown vagrant {suspend|halt|destroy} {soci|db2} Check Vagrant command-line interface for complete list of commands.","title":"Usage"},{"location":"vagrant/#environment-variables","text":"All variables available to the vagrant user on the VMs are defined in and sourced from /vagrant/scripts/vagrant/common.env : SOCI_HOME where SOCI master is cloned ( /vagrant on VM soci ) SOCI_BUILD where CMake generates build configuration ( /home/vagrant/soci-build on VM soci ) SOCI_HOST network accessible VM soci hostname ( ping vmsoci.local ) SOCI_USER default database user and database name SOCI_PASS default database password for both, SOCI_USER and root/sysdba of particular database. SOCI_DB2_HOST network accessible VM db2 hostname ( ping vmdb2.local ) SOCI_DB2_USER admin username to DB2 instance. SOCI_DB2_USER admin password to DB2 instance. Note, those variables are also used by provision scripts to set up databases.","title":"Environment variables"},{"location":"vagrant/#troubleshooting","text":"Analyze vagrant up output. On Windows, prefer vagrant ssh from inside MinGW Shell where ssh.exe is available or learn how to use Vagrant with PuTTY. If you modify any of scripts/vagrant/*.sh scripts, ensure they have unified end-of-line characters to LF only. Otherwise, provisioning steps may fail.","title":"Troubleshooting"},{"location":"api/backend/","text":"Backends reference This part of the documentation is provided for those who want towrite (and contribute!) their own backends. It is anyway recommendedthat authors of new backend see the code of some existing backend forhints on how things are really done. The backend interface is a set of base classes that the actual backendsare supposed to specialize. The main SOCI interface uses only theinterface and respecting the protocol (for example, the order of function calls) described here. Note that both the interface and theprotocol were initially designed with the Oracle database in mind, which means that whereas it is quite natural with respect to the way Oracle API (OCI) works, it might impose some implementation burden on otherbackends, where things are done differently and therefore have to beadjusted, cached, converted, etc. The interface to the common SOCI interface is defined in the core/soci-backend.h header file. This file is dissected below. All names are defined in either soci or soci::details namespace. // data types, as seen by the user enum data_type { dt_string, dt_date, dt_double, dt_integer, dt_long_long, dt_unsigned_long_long }; // the enum type for indicator variables enum indicator { i_ok, i_null, i_truncated }; // data types, as used to describe exchange format enum exchange_type { x_char, x_stdstring, x_short, x_integer, x_long_long, x_unsigned_long_long, x_double, x_stdtm, x_statement, x_rowid, x_blob }; struct cstring_descriptor { cstring_descriptor(char * str, std::size_t bufSize) : str_(str), bufSize_(bufSize) {} char * str_; std::size_t bufSize_; }; // actually in error.h: class soci_error : public std::runtime_error { public: soci_error(std::string const & msg); }; The data_type enumeration type defines all types that form the core type support for SOCI. The enum itself can be used by clients when dealing with dynamic rowset description. The indicator enumeration type defines all recognized states of data. The i_truncated state is provided for the case where the string is retrieved from the database into the char buffer that is not long enough to hold the whole value. The exchange_type enumeration type defines all possible types that can be used with the into and use elements. The cstring_descriptor is a helper class that allows to store the address of char buffer together with its size. The objects of this class are passed to the backend when the x_cstring type is involved. The soci_error class is an exception type used for database-related (and also usage-related) errors. The backends should throw exceptions of this or derived type only. class standard_into_type_backend { public: standard_into_type_backend() {} virtual ~standard_into_type_backend() {} virtual void define_by_pos(int& position, void* data, exchange_type type) = 0; virtual void pre_fetch() = 0; virtual void post_fetch(bool gotData, bool calledFromFetch, indicator* ind) = 0; virtual void clean_up() = 0; }; The standard_into_type_back_end class implements the dynamic interactions with the simple (non-bulk) into elements. The objects of this class (or, rather, of the derived class implemented by the actual backend) are created by the statement object when the into element is bound - in terms of lifetime management, statement is the master of this class. define_by_pos - Called when the into element is bound, once and before the statement is executed. The data pointer points to the variable used for into element (or to the cstring_descriptor object, which is artificially created when the plain char buffer is used for data exchange). The position parameter is a \"column number\", assigned by the library. The backend should increase this parameter, according to the number of fields actually taken (usually 1). pre_fetch - Called before each row is fetched. post_fetch - Called after each row is fetched. The gotData parameter is true if the fetch operation really retrievedsome data and false otherwise; calledFromFetch is true when the call is from the fetch operation and false if it is from the execute operation (this is also the case for simple, one-time queries). In particular, (calledFromFetch && !gotData) indicates that there is an end-of-rowset condition. ind points to the indicator provided by the user, or is NULL , if there is no indicator. clean_up - Called once when the statement is destroyed. The intended use of pre_fetch and post_fetch functions is to manage any internal buffer and/or data conversion foreach value retrieved from the database. If the given server supportsbinary data transmission and the data format for the given type agreeswith what is used on the client machine, then these two functions neednot do anything; otherwise buffer management and data conversionsshould go there. class vector_into_type_backend { public: vector_into_type_backend() {} virtual ~vector_into_type_backend() {} virtual void define_by_pos(int& position, void* data, exchange_type type) = 0; virtual void pre_fetch() = 0; virtual void post_fetch(bool gotData, indicator* ind) = 0; virtual void resize(std::size_t sz) = 0; virtual std::size_t size() = 0; virtual void clean_up() = 0; }; The vector_into_type_back_end has similar structure and purpose as the previous one, but is used for vectors (bulk data retrieval). The data pointer points to the variable of type std::vector<T>; (and not to its internal buffer), resize is supposed to really resize the user-provided vector and size is supposed to return the current size of this vector. The important difference with regard to the previous class is that ind points (if not NULL ) to the beginning of the array of indicators. The backend should fill this array according to the actual state of the retrieved data. bind_by_pos - Called for each use element, once and before the statement is executed - for those use elements that do not provide explicit names for parameter binding. The meaning of parameters is same as in previous classes. bind_by_name - Called for those use elements that provide the explicit name. pre_use - Called before the data is transmitted to the server (this means before the statement is executed, which can happen many times for the prepared statement). ind points to the indicator provided by the user (or is NULL ). post_use - Called after statement execution. gotData and ind have the same meaning as in standard_into_type_back_end::post_fetch , and this can be used by those backends whose respective servers support two-way data exchange (like in/out parameters in stored procedures). The intended use for pre_use and post_use methods is to manage any internal buffers and/or data conversion. They can be called many times with the same statement. class vector_use_type_backend { public: virtual ~vector_use_type_backend() {} virtual void bind_by_pos(int& position, void* data, exchange_type type) = 0; virtual void bind_by_name(std::string const& name, void* data, exchange_type type) = 0; virtual void pre_use(indicator const* ind) = 0; virtual std::size_t size() = 0; virtual void clean_up() = 0; }; Objects of this type (or rather of type derived from this one) are used to implement interactions with user-provided vector (bulk) use elements and are managed by the statement object. The data pointer points to the whole vector object provided by the user (and not to its internal buffer); ind points to the beginning of the array of indicators (or is NULL ). The meaning of this interface is analogous to those presented above. class statement_backend { public: statement_backend() {} virtual ~statement_backend() {} virtual void alloc() = 0; virtual void clean_up() = 0; virtual void prepare(std::string const& query, statement_type eType) = 0; enum exec_fetch_result { ef_success, ef_no_data }; virtual exec_fetch_result execute(int number) = 0; virtual exec_fetch_result fetch(int number) = 0; virtual long long get_affected_rows() = 0; virtual int get_number_of_rows() = 0; virtual std::string rewrite_for_procedure_call(std::string const& query) = 0; virtual int prepare_for_describe() = 0; virtual void describe_column(int colNum, data_type& dtype, std::string& column_name) = 0; virtual standard_into_type_backend* make_into_type_backend() = 0; virtual standard_use_type_backend* make_use_type_backend() = 0; virtual vector_into_type_backend* make_vector_into_type_backend() = 0; virtual vector_use_type_backend* make_vector_use_type_backend() = 0; }; The statement_backend type implements the internals of the statement objects. The objects of this class are created by the session object. alloc - Called once to allocate everything that is needed for the statement to work correctly. clean_up - Supposed to clean up the resources, called once. prepare - Called once with the text of the SQL query. For servers that support explicit query preparation, this is the place to do it. execute - Called to execute the query; if number is zero, the intent is not to exchange data with the user-provided objects ( into and use elements); positive values mean the number of rows to exchange (more than 1 is used only for bulk operations). fetch - Called to fetch next bunch of rows; number is positive and determines the requested number of rows (more than 1 is used only for bulk operations). get_affected_rows - Called to determine the actual number of rows affected by data modifying statement. get_number_of_rows - Called to determine the actual number of rows retrieved by the previous call to execute or fetch . rewrite_for_procedure_call - Used when the procedure is used instead of statement , to call the stored procedure. This function should rewrite the SQL query (if necessary) to the form that will allow to execute the given procedure. prepare_for_describe - Called once when the into element is used with the row type, which means that dynamic rowset description should be performed. It is supposed to do whatever is needed to later describe the column properties and should return the number of columns. describe_column - Called once for each column (column numbers - colNum - start from 1), should fill its parameters according to the column properties. make_into_type_backend , make_use_type_backend , make_vector_into_type_backend , make_vector_use_type_backend - Called once for each into or use element, to create the objects of appropriate classes (described above). Notes: Whether the query is executed using the simple one-time syntax or is prepared, the alloc , prepare and execute functions are always called, in this order. All into and use elements are bound (their define_by_pos or bind_by_pos / bind_by_name functions are called) between statement preparation and execution. class rowid_backend { public: virtual ~rowid_backend() {} }; The rowid_backend class is a hook for the backends to provide their own state for the row identifier. It has no functions, since the only portable interaction with the row identifier object is to use it with into and use elements. class blob_backend { public: virtual ~blob_backend() {} virtual std::size_t get_len() = 0; virtual std::size_t read(std::size_t offset, char * buf, std::size_t toRead) = 0; virtual std::size_t write(std::size_t offset, char const * buf, std::size_t toWrite) = 0; virtual std::size_t append(char const * buf, std::size_t toWrite) = 0; virtual void trim(std::size_t newLen) = 0; }; The blob_backend interface provides the entry points for the blob methods. class session_backend { public: virtual ~session_backend() {} virtual void begin() = 0; virtual void commit() = 0; virtual void rollback() = 0; virtual bool get_next_sequence_value(session&, std::string const&, long long&); virtual bool get_last_insert_id(session&, std::string const&, long long&); virtual std::string get_backend_name() const = 0; virtual statement_backend * make_statement_backend() = 0; virtual rowid_backend * make_rowid_backend() = 0; virtual blob_backend * make_blob_backend() = 0; }; The object of the class derived from session_backend implements the internals of the session object. begin , commit , rollback - Forward-called when the same functions of session are called by user. get_next_sequence_value , get_last_insert_id - Called to retrieve sequences or auto-generated values and every backend should define at least one of them to allow the code using auto-generated values to work. make_statement_backend , make_rowid_backend , make_blob_backend - Called to create respective implementations for the statement , rowid and blob classes. struct backend_factory { virtual ~backend_factory() {} virtual details::session_backend * make_session( std::string const& connectString) const = 0; }; The backend_factory is a base class for backend-provided factory class that is able to create valid sessions. The connectString parameter passed to make_session is provided here by the session constructor and contains only the backend-related parameters, without the backend name (if the dynamic backend loading is used). The actual backend factory object is supposed to be provided by the backend implementation and declared in its header file. In addition to this, the factory_ABC function with the \"C\" calling convention and returning the pointer to concrete factory object should be provided, where ABC is the backend name. The following example is taken from soci-postgresql.h , which declares entities of the PostgreSQL backend: struct postgresql_backend_factory : backend_factory { virtual postgresql_session_backend* make_session( std::string const& connectString) const; }; extern postgresql_backend_factory const postgresql; extern \"C\" { // for dynamic backend loading backend_factory const * factory_postgresql(); } // extern \"C\" With the above declarations, it is enough to pass the postgresql factory name to the constructor of the session object, which will use this factory to create concrete implementations for any other objects that are needed, with the help of appropriate make_XYZ functions. Alternatively, the factory_postgresql function will be called automatically by the backend loader if the backend name is provided at run-time instead. Note that the backend source code is placed in the backends/*name* directory (for example, backends/oracle ) and the test driver is in backends/*name*/test . There is also backends/empty directory provided as a skeleton for development of new backends and their tests. It is recommended that all backends respect naming conventions by just appending their name to the base-class names. The backend name used for the global factory object should clearly identify the given database engine, like oracle , postgresql , mysql , and so on.","title":"Backend API"},{"location":"api/backend/#backends-reference","text":"This part of the documentation is provided for those who want towrite (and contribute!) their own backends. It is anyway recommendedthat authors of new backend see the code of some existing backend forhints on how things are really done. The backend interface is a set of base classes that the actual backendsare supposed to specialize. The main SOCI interface uses only theinterface and respecting the protocol (for example, the order of function calls) described here. Note that both the interface and theprotocol were initially designed with the Oracle database in mind, which means that whereas it is quite natural with respect to the way Oracle API (OCI) works, it might impose some implementation burden on otherbackends, where things are done differently and therefore have to beadjusted, cached, converted, etc. The interface to the common SOCI interface is defined in the core/soci-backend.h header file. This file is dissected below. All names are defined in either soci or soci::details namespace. // data types, as seen by the user enum data_type { dt_string, dt_date, dt_double, dt_integer, dt_long_long, dt_unsigned_long_long }; // the enum type for indicator variables enum indicator { i_ok, i_null, i_truncated }; // data types, as used to describe exchange format enum exchange_type { x_char, x_stdstring, x_short, x_integer, x_long_long, x_unsigned_long_long, x_double, x_stdtm, x_statement, x_rowid, x_blob }; struct cstring_descriptor { cstring_descriptor(char * str, std::size_t bufSize) : str_(str), bufSize_(bufSize) {} char * str_; std::size_t bufSize_; }; // actually in error.h: class soci_error : public std::runtime_error { public: soci_error(std::string const & msg); }; The data_type enumeration type defines all types that form the core type support for SOCI. The enum itself can be used by clients when dealing with dynamic rowset description. The indicator enumeration type defines all recognized states of data. The i_truncated state is provided for the case where the string is retrieved from the database into the char buffer that is not long enough to hold the whole value. The exchange_type enumeration type defines all possible types that can be used with the into and use elements. The cstring_descriptor is a helper class that allows to store the address of char buffer together with its size. The objects of this class are passed to the backend when the x_cstring type is involved. The soci_error class is an exception type used for database-related (and also usage-related) errors. The backends should throw exceptions of this or derived type only. class standard_into_type_backend { public: standard_into_type_backend() {} virtual ~standard_into_type_backend() {} virtual void define_by_pos(int& position, void* data, exchange_type type) = 0; virtual void pre_fetch() = 0; virtual void post_fetch(bool gotData, bool calledFromFetch, indicator* ind) = 0; virtual void clean_up() = 0; }; The standard_into_type_back_end class implements the dynamic interactions with the simple (non-bulk) into elements. The objects of this class (or, rather, of the derived class implemented by the actual backend) are created by the statement object when the into element is bound - in terms of lifetime management, statement is the master of this class. define_by_pos - Called when the into element is bound, once and before the statement is executed. The data pointer points to the variable used for into element (or to the cstring_descriptor object, which is artificially created when the plain char buffer is used for data exchange). The position parameter is a \"column number\", assigned by the library. The backend should increase this parameter, according to the number of fields actually taken (usually 1). pre_fetch - Called before each row is fetched. post_fetch - Called after each row is fetched. The gotData parameter is true if the fetch operation really retrievedsome data and false otherwise; calledFromFetch is true when the call is from the fetch operation and false if it is from the execute operation (this is also the case for simple, one-time queries). In particular, (calledFromFetch && !gotData) indicates that there is an end-of-rowset condition. ind points to the indicator provided by the user, or is NULL , if there is no indicator. clean_up - Called once when the statement is destroyed. The intended use of pre_fetch and post_fetch functions is to manage any internal buffer and/or data conversion foreach value retrieved from the database. If the given server supportsbinary data transmission and the data format for the given type agreeswith what is used on the client machine, then these two functions neednot do anything; otherwise buffer management and data conversionsshould go there. class vector_into_type_backend { public: vector_into_type_backend() {} virtual ~vector_into_type_backend() {} virtual void define_by_pos(int& position, void* data, exchange_type type) = 0; virtual void pre_fetch() = 0; virtual void post_fetch(bool gotData, indicator* ind) = 0; virtual void resize(std::size_t sz) = 0; virtual std::size_t size() = 0; virtual void clean_up() = 0; }; The vector_into_type_back_end has similar structure and purpose as the previous one, but is used for vectors (bulk data retrieval). The data pointer points to the variable of type std::vector<T>; (and not to its internal buffer), resize is supposed to really resize the user-provided vector and size is supposed to return the current size of this vector. The important difference with regard to the previous class is that ind points (if not NULL ) to the beginning of the array of indicators. The backend should fill this array according to the actual state of the retrieved data. bind_by_pos - Called for each use element, once and before the statement is executed - for those use elements that do not provide explicit names for parameter binding. The meaning of parameters is same as in previous classes. bind_by_name - Called for those use elements that provide the explicit name. pre_use - Called before the data is transmitted to the server (this means before the statement is executed, which can happen many times for the prepared statement). ind points to the indicator provided by the user (or is NULL ). post_use - Called after statement execution. gotData and ind have the same meaning as in standard_into_type_back_end::post_fetch , and this can be used by those backends whose respective servers support two-way data exchange (like in/out parameters in stored procedures). The intended use for pre_use and post_use methods is to manage any internal buffers and/or data conversion. They can be called many times with the same statement. class vector_use_type_backend { public: virtual ~vector_use_type_backend() {} virtual void bind_by_pos(int& position, void* data, exchange_type type) = 0; virtual void bind_by_name(std::string const& name, void* data, exchange_type type) = 0; virtual void pre_use(indicator const* ind) = 0; virtual std::size_t size() = 0; virtual void clean_up() = 0; }; Objects of this type (or rather of type derived from this one) are used to implement interactions with user-provided vector (bulk) use elements and are managed by the statement object. The data pointer points to the whole vector object provided by the user (and not to its internal buffer); ind points to the beginning of the array of indicators (or is NULL ). The meaning of this interface is analogous to those presented above. class statement_backend { public: statement_backend() {} virtual ~statement_backend() {} virtual void alloc() = 0; virtual void clean_up() = 0; virtual void prepare(std::string const& query, statement_type eType) = 0; enum exec_fetch_result { ef_success, ef_no_data }; virtual exec_fetch_result execute(int number) = 0; virtual exec_fetch_result fetch(int number) = 0; virtual long long get_affected_rows() = 0; virtual int get_number_of_rows() = 0; virtual std::string rewrite_for_procedure_call(std::string const& query) = 0; virtual int prepare_for_describe() = 0; virtual void describe_column(int colNum, data_type& dtype, std::string& column_name) = 0; virtual standard_into_type_backend* make_into_type_backend() = 0; virtual standard_use_type_backend* make_use_type_backend() = 0; virtual vector_into_type_backend* make_vector_into_type_backend() = 0; virtual vector_use_type_backend* make_vector_use_type_backend() = 0; }; The statement_backend type implements the internals of the statement objects. The objects of this class are created by the session object. alloc - Called once to allocate everything that is needed for the statement to work correctly. clean_up - Supposed to clean up the resources, called once. prepare - Called once with the text of the SQL query. For servers that support explicit query preparation, this is the place to do it. execute - Called to execute the query; if number is zero, the intent is not to exchange data with the user-provided objects ( into and use elements); positive values mean the number of rows to exchange (more than 1 is used only for bulk operations). fetch - Called to fetch next bunch of rows; number is positive and determines the requested number of rows (more than 1 is used only for bulk operations). get_affected_rows - Called to determine the actual number of rows affected by data modifying statement. get_number_of_rows - Called to determine the actual number of rows retrieved by the previous call to execute or fetch . rewrite_for_procedure_call - Used when the procedure is used instead of statement , to call the stored procedure. This function should rewrite the SQL query (if necessary) to the form that will allow to execute the given procedure. prepare_for_describe - Called once when the into element is used with the row type, which means that dynamic rowset description should be performed. It is supposed to do whatever is needed to later describe the column properties and should return the number of columns. describe_column - Called once for each column (column numbers - colNum - start from 1), should fill its parameters according to the column properties. make_into_type_backend , make_use_type_backend , make_vector_into_type_backend , make_vector_use_type_backend - Called once for each into or use element, to create the objects of appropriate classes (described above). Notes: Whether the query is executed using the simple one-time syntax or is prepared, the alloc , prepare and execute functions are always called, in this order. All into and use elements are bound (their define_by_pos or bind_by_pos / bind_by_name functions are called) between statement preparation and execution. class rowid_backend { public: virtual ~rowid_backend() {} }; The rowid_backend class is a hook for the backends to provide their own state for the row identifier. It has no functions, since the only portable interaction with the row identifier object is to use it with into and use elements. class blob_backend { public: virtual ~blob_backend() {} virtual std::size_t get_len() = 0; virtual std::size_t read(std::size_t offset, char * buf, std::size_t toRead) = 0; virtual std::size_t write(std::size_t offset, char const * buf, std::size_t toWrite) = 0; virtual std::size_t append(char const * buf, std::size_t toWrite) = 0; virtual void trim(std::size_t newLen) = 0; }; The blob_backend interface provides the entry points for the blob methods. class session_backend { public: virtual ~session_backend() {} virtual void begin() = 0; virtual void commit() = 0; virtual void rollback() = 0; virtual bool get_next_sequence_value(session&, std::string const&, long long&); virtual bool get_last_insert_id(session&, std::string const&, long long&); virtual std::string get_backend_name() const = 0; virtual statement_backend * make_statement_backend() = 0; virtual rowid_backend * make_rowid_backend() = 0; virtual blob_backend * make_blob_backend() = 0; }; The object of the class derived from session_backend implements the internals of the session object. begin , commit , rollback - Forward-called when the same functions of session are called by user. get_next_sequence_value , get_last_insert_id - Called to retrieve sequences or auto-generated values and every backend should define at least one of them to allow the code using auto-generated values to work. make_statement_backend , make_rowid_backend , make_blob_backend - Called to create respective implementations for the statement , rowid and blob classes. struct backend_factory { virtual ~backend_factory() {} virtual details::session_backend * make_session( std::string const& connectString) const = 0; }; The backend_factory is a base class for backend-provided factory class that is able to create valid sessions. The connectString parameter passed to make_session is provided here by the session constructor and contains only the backend-related parameters, without the backend name (if the dynamic backend loading is used). The actual backend factory object is supposed to be provided by the backend implementation and declared in its header file. In addition to this, the factory_ABC function with the \"C\" calling convention and returning the pointer to concrete factory object should be provided, where ABC is the backend name. The following example is taken from soci-postgresql.h , which declares entities of the PostgreSQL backend: struct postgresql_backend_factory : backend_factory { virtual postgresql_session_backend* make_session( std::string const& connectString) const; }; extern postgresql_backend_factory const postgresql; extern \"C\" { // for dynamic backend loading backend_factory const * factory_postgresql(); } // extern \"C\" With the above declarations, it is enough to pass the postgresql factory name to the constructor of the session object, which will use this factory to create concrete implementations for any other objects that are needed, with the help of appropriate make_XYZ functions. Alternatively, the factory_postgresql function will be called automatically by the backend loader if the backend name is provided at run-time instead. Note that the backend source code is placed in the backends/*name* directory (for example, backends/oracle ) and the test driver is in backends/*name*/test . There is also backends/empty directory provided as a skeleton for development of new backends and their tests. It is recommended that all backends respect naming conventions by just appending their name to the base-class names. The backend name used for the global factory object should clearly identify the given database engine, like oracle , postgresql , mysql , and so on.","title":"Backends reference"},{"location":"api/client/","text":"API Reference The core client interface is a set of classes and free functions declared in the soci.h header file. All names are dbeclared in the soci namespace. There are also additional names declared in the soci::details namespace, but they are not supposed to be directly used by the users of the library and are therefore not documented here. When such types are used in the declarations that are part of the \"public\" interface, they are replaced by \"IT\", which means \"internal type\". Types related to the backend interface are named here. Commonly used types The following types are commonly used in the rest of the interface: // data types, as seen by the user enum data_type { dt_string, dt_date, dt_double, dt_integer, dt_long_long, dt_unsigned_long_long }; // the enum type for indicator variables enum indicator { i_ok, i_null, i_truncated }; // the type used for reporting exceptions class soci_error : public std::runtime_error { /* ... */ }; The data_type type defines the basic SOCI data types. User provided data types need to be associated with one of these basic types. The indicator type defines the possible states of data. The soci_error type is used for error reporting. class session The session class encapsulates the connection to the database. class session { public: session(); explicit session(connection_parameters const & parameters); session(backend_factory const & factory, std::string const & connectString); session(std::string const & backendName, std::string const & connectString); explicit session(std::string const & connectString); explicit session(connection_pool & pool); ~session(); void open(backend_factory const & factory, std::string const & connectString); void open(std::string const & backendName, std::string const & connectString); void open(std::string const & connectString); void close(); void reconnect(); void begin(); void commit(); void rollback(); *IT* once; *IT* prepare; template <typename T> *IT* operator<<(T const & t); bool got_data() const; bool get_next_sequence_value(std::string const & sequence, long long & value); bool get_last_insert_id(std::string const & table, long long & value); std::ostringstream & get_query_stream(); void set_log_stream(std::ostream * s); std::ostream * get_log_stream() const; std::string get_last_query() const; void uppercase_column_names(bool forceToUpper); std::string get_dummy_from_table() const; std::string get_dummy_from_clause() const; details::session_backend * get_backend(); std::string get_backend_name() const; }; This class contains the following members: Various constructors. The default one creates the session in the disconnected state. The others expect the backend factory object, or the backend name, or the URL-like composed connection string or the special parameters object containing both the backend and the connection string as well as possibly other connection options. The last constructor creates a session proxy associated with the session that is available in the given pool and releases it back to the pool when its lifetime ends. Example: session sql(postgresql, \"dbname=mydb\"); session sql(\"postgresql\", \"dbname=mydb\"); session sql(\"postgresql://dbname=mydb\"); The constructors that take backend name as string load the shared library (if not yet loaded) with name computed as libsoci_ABC.so (or libsoci_ABC.dll on Windows) where ABC is the given backend name. open , close and reconnect functions for reusing the same session object many times; the reconnect function attempts to establish the connection with the same parameters as most recently used with constructor or open . The arguments for open are treated in the same way as for constructors. begin , commit and rollback functions for transaction control. once member, which is used for performing instant queries that do not need to be separately prepared. Example: sql.once << \"drop table persons\"; prepare member, which is used for statement preparation - the result of the statement preparation must be provided to the constructor of the statement class. Example: int i; statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(i)); operator<< that is a shortcut forwarder to the equivalent operator of the once member. Example: sql << \"drop table persons\"; got_data returns true if the last executed query had non-empty result. get_next_sequence_value returns true if the next value of the sequence with the specified name was generated and returned in its second argument. Unless you can be sure that your program will use only databases that support sequences, consider using this method in conjunction with get_last_insert_id() as explained in \"Working with sequences\" section. get_last_insert_id returns true if it could retrieve the last value automatically generated by the database for an auto-incremented field. Notice that although this method takes the table name, for some databases, such as Microsoft SQL Server and SQLite, this value is actually global, so you should attempt to retrieve it immediately after performing an insertion. get_query_stream provides direct access to the stream object that is used to accumulate the query text and exists in particular to allow the user to imbue specific locale to this stream. set_log_stream and get_log_stream functions for setting and getting the current stream object used for basic query logging. By default, it is NULL , which means no logging The string value that is actually logged into the stream is one-line verbatim copy of the query string provided by the user, without including any data from the use elements. The query is logged exactly once, before the preparation step. get_last_query retrieves the text of the last used query. uppercase_column_names allows to force all column names to uppercase in dynamic row description; this function is particularly useful for portability, since various database servers report column names differently (some preserve case, some change it). get_dummy_from_table and get_dummy_from_clause() : helpers for writing portable DML statements, see DML helpers for more details. get_backend returns the internal pointer to the concrete backend implementation of the session. This is provided for advanced users that need access to the functionality that is not otherwise available. get_backend_name is a convenience forwarder to the same function of the backend object. See connection and queries for more examples. class connection_parameters The connection_parameters class is a simple container for the backend pointer, connection string and any other connection options. It is used together with session constructor and open() method. class connection_parameters { public: connection_parameters(); connection_parameters(backend_factory const & factory, std::string const & connectString); connection_parameters(std::string const & backendName, std::string const & connectString); explicit connection_parameters(std::string const & fullConnectString); void set_option(const char * name, std::string const & value); bool get_option(const char * name, std::string & value) const }; The methods of this class are: Default constructor is rarely used as it creates an uninitialized object and the only way to initialize it later is to assign another, valid, connection_parameters object to this one. The other constructors correspond to the similar constructors of the session class and specify both the backend, either as a pointer to it or by name, and the connection string. set_option can be used to set the value of an option with the given name. Currently all option values are strings, so if you need to set a numeric option you need to convert it to a string first. If an option with the given name had been already set before, its old value is overwritten. class connection_pool The connection_pool class encapsulates the thread-safe pool of connections and ensures that only one thread at a time has access to any connection that it manages. class connection_pool { public: explicit connection_pool(std::size_t size); ~connection_pool(); session & at(std::size_t pos); std::size_t lease(); bool try_lease(std::size_t & pos, int timeout); void give_back(std::size_t pos); }; The operations of the pool are: Constructor that takes the intended size of the pool. After construction, the pool contains regular session objects in disconnected state. at function that provides direct access to any given entryin the pool. This function is non-synchronized . lease function waits until some entry is available (which means that it is not used) and returns the position of that entry in the pool, marking it as locked . try_lease acts like lease , but allows to set up a time-out (relative, in milliseconds) on waiting. Negative time-out value means no time-out. Returns true if the entry was obtained, in which case its position is written to the pos parametr, and false if no entry was available before the time-out. give_back should be called when the entry on the given position is no longer in use and can be passed to other requesting thread. class transaction The class transaction can be used for associating the transaction with some code scope. It is a RAII wrapper for regular transaction operations that automatically rolls back in its destructor if the transaction was not explicitly committed before. class transaction { public: explicit transaction(session & sql); ~transaction(); void commit(); void rollback(); private: // ... }; Note that objects of this class are not notified of other transaction related operations that might be executed by user code explicitly or hidden inside SQL queries. It is not recommended to mix different ways of managing transactions. function into The function into is used for binding local output data (in other words, it defines where the results of the query are stored). template <typename T> IT into(T & t); template <typename T, typename T1> IT into(T & t, T1 p1); template <typename T> IT into(T & t, indicator & ind); template <typename T, typename T1> IT into(T & t, indicator & ind, T1 p1); template <typename T> IT into(T & t, std::vector<indicator> & ind); Example: int count; sql << \"select count(*) from person\", into(count); See Binding output data for more examples function use The function use is used for binding local input data (in other words, it defines where the parameters of the query come from). template <typename T> *IT* use(T & t); template <typename T, typename T1> *IT* use(T & t, T1 p1); template <typename T> *IT* use(T & t, indicator & ind); template <typename T, typename T1> *IT* use(T & t, indicator & ind, T1 p1); template <typename T> *IT* use(T & t, std::vector<indicator> const & ind); template <typename T, typename T1> *IT* use(T & t, std::vector<indicator> const & ind, T1 p1); Example: int val = 7; sql << \"insert into numbers(val) values(:val)\", use(val); See Binding input data for more examples. class statement The statement class encapsulates the prepared statement. class statement { public: statement(session & s); statement(*IT* const & prep); ~statement(); statement(statement const & other); void operator=(statement const & other); void alloc(); void bind(values & v); void exchange(*IT* const & i); void exchange(*IT* const & u); void clean_up(); void bind_clean_up(); void prepare(std::string const & query); void define_and_bind(); bool execute(bool withDataExchange = false); long long get_affected_rows(); bool fetch(); bool got_data() const; void describe(); void set_row(row * r); void exchange_for_rowset(*IT* const & i); details::statement_backend * get_backend(); }; This class contains the following members: Constructor accepting the session object. This can be used for later query preparation. Example: statement stmt(sql); Constructor accepting the result of using prepare on the session object, see example provided above for the session class. Copy operations. alloc function, which allocates necessary internal resources. bind function, which is used to bind the values object - this is used in the object-relational mapping and normally called automatically. exchange functions for registering the binding of local data - they expect the result of calling the into or use functions and are normally invoked automatically. clean_up function for cleaning up resources, normally called automatically. bind_clean_up function for cleaning up any bound references. It allows to keep statement in cache and reuse it later with new references by calling exchange for each new bind variable. prepare function for preparing the statement for repeated execution. define_and_bind function for actually executing the registered bindings, normally called automatically. execute function for executing the statement. If its parameter is false then there is no data exchange with locally bound variables (this form should be used if later fetch of multiple rows is foreseen). Returns true if there was at least one row of data returned. get_affected_rows function returns the number of rows affected by the last statement. Returns -1 if it's not implemented by the backend being used. fetch function for retrieving the next portion of the result. Returns true if there was new data. got_data return true if the most recent execution returned any rows. describe function for extracting the type information for the result ( Note: no data is exchanged). This is normally called automatically and only when dynamic resultset binding is used. set_row function for associating the statement and row objects, normally called automatically. exchange_for_rowset as a special case for binding rowset objects. get_backend function that returns the internal pointer to the concrete backend implementation of the statement object. This is provided for advanced users that need access to the functionality that is not otherwise available. See Statement preparation and repeated execution for example uses. Most of the functions from the statement class interface are called automatically, but can be also used explicitly. See Interfaces for the description of various way to use this interface. class procedure The procedure class encapsulates the call to the stored procedure and is aimed for higher portability of the client code. class procedure { public: procedure(*IT* const & prep); bool execute(bool withDataExchange = false); bool fetch(); bool got_data() const; }; The constructor expects the result of using prepare on the session object. See Stored procedures for examples. class type_conversion The type_conversion class is a traits class that is supposed to be provided (specialized) by the user for defining conversions to and from one of the basic SOCI types. template <typename T> struct type_conversion { typedef T base_type; static void from_base(base_type const & in, indicator ind, T & out); static void to_base(T const & in, base_type & out, indicator & ind); }; Users are supposed to properly implement the from_base and to_base functions in their specializations of this template class. See Extending SOCI to support custom (user-defined) C++ types . class row The row class encapsulates the data and type information retrieved for the single row when the dynamic rowset binding is used. class row { public: row(); ~row(); void uppercase_column_names(bool forceToUpper); std::size_t size() const; indicator get_indicator(std::size_t pos) const; indicator get_indicator(std::string const & name) const; column_properties const & get_properties (std::size_t pos) const; column_properties const & get_properties (std::string const & name) const; template <typename T> T get(std::size_t pos) const; template <typename T> T get(std::size_t pos, T const & nullValue) const; template <typename T> T get(std::string const & name) const; template <typename T> T get(std::string const & name, T const & nullValue) const; template <typename T> row const & operator>>(T & value) const; void skip(std::size_t num = 1) const; void reset_get_counter() const }; This class contains the following members: Default constructor that allows to declare a row variable. uppercase_column_names - see the same function in the session class. size function that returns the number of columns in the row. get_indicator function that returns the indicator value for the given column (column is specified by position - starting from 0 - or by name). get_properties function that returns the properties of the column given by position (starting from 0) or by name. get functions that return the value of the column given by position or name. If the column contains null, then these functions either return the provided \"default\" nullValue or throw an exception. operator>> for convenience stream-like extraction interface. Subsequent calls to this function are equivalent to calling get with increasing position parameter, starting from the beginning. skip and reset_get_counter allow to change the order of data extraction for the above operator. See Dynamic resultset binding for examples. class column_properties The column_properties class provides the type and name information about the particular column in a rowset. class column_properties { public: std::string get_name() const; data_type get_data_type() const; }; This class contains the following members: get_name function that returns the name of the column. get_data_type that returns the type of the column. See Dynamic resultset binding for examples. class values The values class encapsulates the data and type information and is used for object-relational mapping. class values { public: values(); void uppercase_column_names(bool forceToUpper); indicator get_indicator(std::size_t pos) const; indicator get_indicator(std::string const & name) const; template <typename T> T get(std::size_t pos) const; template <typename T> T get(std::size_t pos, T const & nullValue) const; template <typename T> T get(std::string const & name) const; template <typename T> T get(std::string const & name, T const & nullValue) const; template <typename T> values const & operator>>(T & value) const; void skip(std::size_t num = 1) const; void reset_get_counter() const; template <typename T> void set(std::string const & name, T const & value, indicator indic = i_ok); template <typename T> void set(const T & value, indicator indic = i_ok); template <typename T> values & operator<<(T const & value); }; This class contains the same members as the row class (with the same meaning) plus: set function for storing values in named columns or in subsequent positions. operator<< for convenience. See Object-relational mapping for examples. class blob The blob class encapsulates the \"large object\" functionality. class blob { public: explicit blob(session & s); ~blob(); std::size_t getLen(); std::size_t read(std::size_t offset, char * buf, std::size_t toRead); std::size_t write(std::size_t offset, char const * buf, std::size_t toWrite); std::size_t append(char const * buf, std::size_t toWrite); void trim(std::size_t newLen); details::blob_backend * get_backend(); }; This class contains the following members: Constructor associating the blob object with the session object. get_len function that returns the size of the BLOB object. read function that reads the BLOB data into provided buffer. write function that writes the BLOB data from provided buffer. append function that appends to the existing BLOB data. trim function that truncates the existing data to the new length. get_backend function that returns the internal pointer to the concrete backend implementation of the BLOB object. This is provided for advanced users that need access to the functionality that is not otherwise available. See Large objects (BLOBs) for more discussion. class rowid The rowid class encapsulates the \"row identifier\" object. class rowid { public: explicit rowid(Session & s); ~rowid(); details::rowid_backend * get_backend(); }; This class contains the following members: Constructor associating the rowid object with the session object. get_backend function that returns the internal pointer to the concrete backend implementation of the rowid object. class backend_factory The backend_factory class provides the abstract interface for concrete backend factories. struct backend_factory { virtual details::session_backend * make_session( std::string const & connectString) const = 0; }; The only member of this class is the make_session function that is supposed to create concrete backend implementation of the session object. Objects of this type are declared by each backend and should be provided to the constructor of the session class. In simple programs users do not need to use this class directly, but the example use is: backend_factory & factory = postgresql; std::string connectionParameters = \"dbname=mydb\"; session sql(factory, parameters); Simple Client Interface The simple client interface is provided with other languages in mind, to allow easy integration of the SOCI library with script interpreters and those languages that have the ability to link directly with object files using the \"C\" calling convention. The functionality of this interface is limited and in particular the dynamic rowset description and type conversions are not supported in this release. On the other hand, the important feature of this interface is that it does not require passing pointers to data managed by the user, because all data is handled at the SOCI side. This should make it easier to integrate SOCI with languages that have constrained ability to understand the C type system. Users of this interface need to explicitly #include <soci-simple.h> . typedef void * session_handle; session_handle soci_create_session(char const * connectionString); void soci_destroy_session(session_handle s); void soci_begin(session_handle s); void soci_commit(session_handle s); void soci_rollback(session_handle s); int soci_session_state(session_handle s); char const * soci_session_error_message(session_handle s); The functions above provide the session abstraction with the help of opaque handle. The soci_session_state function returns 1 if there was no error during the most recently executed function and 0 otherwise, in which case the soci_session_error_message can be used to obtain a human-readable error description. Note that the only function that cannot report all errors this way is soci_create_session , which returns NULL if it was not possible to create an internal object representing the session. However, if the proxy object was created, but the connection could not be established for whatever reason, the error message can be obtained in the regular way. typedef void *blob_handle; blob_handle soci_create_blob(session_handle s); void soci_destroy_blob(blob_handle b); int soci_blob_get_len(blob_handle b); int soci_blob_read(blob_handle b, int offset, char *buf, int toRead); int soci_blob_write(blob_handle b, int offset, char const *buf, int toWrite); int soci_blob_append(blob_handle b, char const *buf, int toWrite); int soci_blob_trim(blob_handle b, int newLen); int soci_blob_state(blob_handle b); char const * soci_blob_error_message(blob_handle b); The functions above provide the blob abstraction with the help of opaque handle. The soci_blob_state function returns 1 if there was no error during the most recently executed function and 0 otherwise, in which case the soci_session_error_message can be used to obtain a human-readable error description. For easy error testing, functions soci_blob_read , soci_blob_write , soci_blob_append , and soci_blob_trim return -1 in case of error and soci_session_error_message can be used to obtain a human-readable error description. Note that the only function that cannot report all errors this way is soci_create_blob , which returns NULL if it was not possible to create an internal object representing the blob. typedef void * statement_handle; statement_handle soci_create_statement(session_handle s); void soci_destroy_statement(statement_handle st); int soci_statement_state(statement_handle s); char const * soci_statement_error_message(statement_handle s); The functions above create and destroy the statement object. If the statement cannot be created by the soci_create_statement function, the error condition is set up in the related session object; for all other functions the error condition is set in the statement object itself. int soci_into_string (statement_handle st); int soci_into_int (statement_handle st); int soci_into_long_long(statement_handle st); int soci_into_double (statement_handle st); int soci_into_date (statement_handle st); int soci_into_blob (statement_handle st); int soci_into_string_v (statement_handle st); int soci_into_int_v (statement_handle st); int soci_into_long_long_v(statement_handle st); int soci_into_double_v (statement_handle st); int soci_into_date_v (statement_handle st); These functions create new data items for storing query results ( into elements ). These elements can be later identified by their position, which is counted from 0. For convenience, these function return the position of the currently added element. In case of error, -1 is returned and the error condition is set in the statement object. The _v versions create a vector into elements, which can be used to retrieve whole arrays of results. int soci_get_into_state(statement_handle st, int position); int soci_get_into_state_v(statement_handle st, int position, int index); This function returns 1 if the into element at the given position has non-null value and 0 otherwise. The _v version works with vector elements and expects an array index. char const * soci_get_into_string (statement_handle st, int position); int soci_get_into_int (statement_handle st, int position); long long soci_get_into_long_long(statement_handle st, int position); double soci_get_into_double (statement_handle st, int position); char const * soci_get_into_date (statement_handle st, int position); blob_handle soci_get_into_blob (statement_handle st, int position); char const * soci_get_into_string_v (statement_handle st, int position, int index); int soci_get_into_int_v (statement_handle st, int position, int index); long long soci_get_into_long_long_v(statement_handle st, int position, int index); double soci_get_into_double_v (statement_handle st, int position, int index); char const * soci_get_into_date_v (statement_handle st, int position, int index); The functions above allow to retrieve the current value of the given into element. Note: The date function returns the date value in the \" YYYY MM DD HH mm ss \" string format. void soci_use_string (statement_handle st, char const * name); void soci_use_int (statement_handle st, char const * name); void soci_use_long_long(statement_handle st, char const * name); void soci_use_double (statement_handle st, char const * name); void soci_use_date (statement_handle st, char const * name); void soci_use_blob (statement_handle st, char const * name); void soci_use_string_v (statement_handle st, char const * name); void soci_use_int_v (statement_handle st, char const * name); void soci_use_long_long_v(statement_handle st, char const * name); void soci_use_double_v (statement_handle st, char const * name); void soci_use_date_v (statement_handle st, char const * name); The functions above allow to create new data elements that will be used to provide data to the query ( use elements ). The new elements can be later identified by given name, which must be unique for the given statement. void soci_set_use_state(statement_handle st, char const * name, int state); The soci_set_use_state function allows to set the state of the given use element. If the state parameter is set to non-zero the use element is considered non-null (which is also the default state after creating the use element). int soci_use_get_size_v(statement_handle st); void soci_use_resize_v (statement_handle st, int new_size); These functions get and set the size of vector use elements (see comments for vector into elements above). void soci_set_use_string (statement_handle st, char const * name, char const * val); void soci_set_use_int (statement_handle st, char const * name, int val); void soci_set_use_long_long(statement_handle st, char const * name, long long val); void soci_set_use_double (statement_handle st, char const * name, double val); void soci_set_use_date (statement_handle st, char const * name, char const * val); void soci_set_use_blob (statement_handle st, char const * name, blob_handle blob); void soci_set_use_state_v (statement_handle st, char const * name, int index, int state); void soci_set_use_string_v (statement_handle st, char const * name, int index, char const * val); void soci_set_use_int_v (statement_handle st, char const * name, int index, int val); void soci_set_use_long_long_v(statement_handle st, char const * name, int index, long long val); void soci_set_use_double_v (statement_handle st, char const * name, int index, double val); void soci_set_use_date_v (statement_handle st, char const * name, int index, char const * val); The functions above set the value of the given use element, for both single and vector elements. Note: The expected format for the data values is \" YYYY MM DD HH mm ss \". int soci_get_use_state (statement_handle st, char const * name); char const * soci_get_use_string (statement_handle st, char const * name); int soci_get_use_int (statement_handle st, char const * name); long long soci_get_use_long_long(statement_handle st, char const * name); double soci_get_use_double (statement_handle st, char const * name); char const * soci_get_use_date (statement_handle st, char const * name); blob_handle soci_get_use_blob (statement_handle st, char const * name); These functions allow to inspect the state and value of named use elements. Note: these functions are provide only for single use elements, not for vectors; the rationale for this is that modifiable use elements are not supported for bulk operations. void soci_prepare(statement_handle st, char const * query); int soci_execute(statement_handle st, int withDataExchange); int soci_fetch(statement_handle st); int soci_got_data(statement_handle st); The functions above provide the core execution functionality for the statement object and their meaning is equivalent to the respective functions in the core C++ interface described above.","title":"Client API"},{"location":"api/client/#api-reference","text":"The core client interface is a set of classes and free functions declared in the soci.h header file. All names are dbeclared in the soci namespace. There are also additional names declared in the soci::details namespace, but they are not supposed to be directly used by the users of the library and are therefore not documented here. When such types are used in the declarations that are part of the \"public\" interface, they are replaced by \"IT\", which means \"internal type\". Types related to the backend interface are named here.","title":"API Reference"},{"location":"api/client/#commonly-used-types","text":"The following types are commonly used in the rest of the interface: // data types, as seen by the user enum data_type { dt_string, dt_date, dt_double, dt_integer, dt_long_long, dt_unsigned_long_long }; // the enum type for indicator variables enum indicator { i_ok, i_null, i_truncated }; // the type used for reporting exceptions class soci_error : public std::runtime_error { /* ... */ }; The data_type type defines the basic SOCI data types. User provided data types need to be associated with one of these basic types. The indicator type defines the possible states of data. The soci_error type is used for error reporting.","title":"Commonly used types"},{"location":"api/client/#class-session","text":"The session class encapsulates the connection to the database. class session { public: session(); explicit session(connection_parameters const & parameters); session(backend_factory const & factory, std::string const & connectString); session(std::string const & backendName, std::string const & connectString); explicit session(std::string const & connectString); explicit session(connection_pool & pool); ~session(); void open(backend_factory const & factory, std::string const & connectString); void open(std::string const & backendName, std::string const & connectString); void open(std::string const & connectString); void close(); void reconnect(); void begin(); void commit(); void rollback(); *IT* once; *IT* prepare; template <typename T> *IT* operator<<(T const & t); bool got_data() const; bool get_next_sequence_value(std::string const & sequence, long long & value); bool get_last_insert_id(std::string const & table, long long & value); std::ostringstream & get_query_stream(); void set_log_stream(std::ostream * s); std::ostream * get_log_stream() const; std::string get_last_query() const; void uppercase_column_names(bool forceToUpper); std::string get_dummy_from_table() const; std::string get_dummy_from_clause() const; details::session_backend * get_backend(); std::string get_backend_name() const; }; This class contains the following members: Various constructors. The default one creates the session in the disconnected state. The others expect the backend factory object, or the backend name, or the URL-like composed connection string or the special parameters object containing both the backend and the connection string as well as possibly other connection options. The last constructor creates a session proxy associated with the session that is available in the given pool and releases it back to the pool when its lifetime ends. Example: session sql(postgresql, \"dbname=mydb\"); session sql(\"postgresql\", \"dbname=mydb\"); session sql(\"postgresql://dbname=mydb\"); The constructors that take backend name as string load the shared library (if not yet loaded) with name computed as libsoci_ABC.so (or libsoci_ABC.dll on Windows) where ABC is the given backend name. open , close and reconnect functions for reusing the same session object many times; the reconnect function attempts to establish the connection with the same parameters as most recently used with constructor or open . The arguments for open are treated in the same way as for constructors. begin , commit and rollback functions for transaction control. once member, which is used for performing instant queries that do not need to be separately prepared. Example: sql.once << \"drop table persons\"; prepare member, which is used for statement preparation - the result of the statement preparation must be provided to the constructor of the statement class. Example: int i; statement st = (sql.prepare << \"insert into numbers(value) values(:val)\", use(i)); operator<< that is a shortcut forwarder to the equivalent operator of the once member. Example: sql << \"drop table persons\"; got_data returns true if the last executed query had non-empty result. get_next_sequence_value returns true if the next value of the sequence with the specified name was generated and returned in its second argument. Unless you can be sure that your program will use only databases that support sequences, consider using this method in conjunction with get_last_insert_id() as explained in \"Working with sequences\" section. get_last_insert_id returns true if it could retrieve the last value automatically generated by the database for an auto-incremented field. Notice that although this method takes the table name, for some databases, such as Microsoft SQL Server and SQLite, this value is actually global, so you should attempt to retrieve it immediately after performing an insertion. get_query_stream provides direct access to the stream object that is used to accumulate the query text and exists in particular to allow the user to imbue specific locale to this stream. set_log_stream and get_log_stream functions for setting and getting the current stream object used for basic query logging. By default, it is NULL , which means no logging The string value that is actually logged into the stream is one-line verbatim copy of the query string provided by the user, without including any data from the use elements. The query is logged exactly once, before the preparation step. get_last_query retrieves the text of the last used query. uppercase_column_names allows to force all column names to uppercase in dynamic row description; this function is particularly useful for portability, since various database servers report column names differently (some preserve case, some change it). get_dummy_from_table and get_dummy_from_clause() : helpers for writing portable DML statements, see DML helpers for more details. get_backend returns the internal pointer to the concrete backend implementation of the session. This is provided for advanced users that need access to the functionality that is not otherwise available. get_backend_name is a convenience forwarder to the same function of the backend object. See connection and queries for more examples.","title":"class session"},{"location":"api/client/#class-connection_parameters","text":"The connection_parameters class is a simple container for the backend pointer, connection string and any other connection options. It is used together with session constructor and open() method. class connection_parameters { public: connection_parameters(); connection_parameters(backend_factory const & factory, std::string const & connectString); connection_parameters(std::string const & backendName, std::string const & connectString); explicit connection_parameters(std::string const & fullConnectString); void set_option(const char * name, std::string const & value); bool get_option(const char * name, std::string & value) const }; The methods of this class are: Default constructor is rarely used as it creates an uninitialized object and the only way to initialize it later is to assign another, valid, connection_parameters object to this one. The other constructors correspond to the similar constructors of the session class and specify both the backend, either as a pointer to it or by name, and the connection string. set_option can be used to set the value of an option with the given name. Currently all option values are strings, so if you need to set a numeric option you need to convert it to a string first. If an option with the given name had been already set before, its old value is overwritten.","title":"class connection_parameters"},{"location":"api/client/#class-connection_pool","text":"The connection_pool class encapsulates the thread-safe pool of connections and ensures that only one thread at a time has access to any connection that it manages. class connection_pool { public: explicit connection_pool(std::size_t size); ~connection_pool(); session & at(std::size_t pos); std::size_t lease(); bool try_lease(std::size_t & pos, int timeout); void give_back(std::size_t pos); }; The operations of the pool are: Constructor that takes the intended size of the pool. After construction, the pool contains regular session objects in disconnected state. at function that provides direct access to any given entryin the pool. This function is non-synchronized . lease function waits until some entry is available (which means that it is not used) and returns the position of that entry in the pool, marking it as locked . try_lease acts like lease , but allows to set up a time-out (relative, in milliseconds) on waiting. Negative time-out value means no time-out. Returns true if the entry was obtained, in which case its position is written to the pos parametr, and false if no entry was available before the time-out. give_back should be called when the entry on the given position is no longer in use and can be passed to other requesting thread.","title":"class connection_pool"},{"location":"api/client/#class-transaction","text":"The class transaction can be used for associating the transaction with some code scope. It is a RAII wrapper for regular transaction operations that automatically rolls back in its destructor if the transaction was not explicitly committed before. class transaction { public: explicit transaction(session & sql); ~transaction(); void commit(); void rollback(); private: // ... }; Note that objects of this class are not notified of other transaction related operations that might be executed by user code explicitly or hidden inside SQL queries. It is not recommended to mix different ways of managing transactions.","title":"class transaction"},{"location":"api/client/#function-into","text":"The function into is used for binding local output data (in other words, it defines where the results of the query are stored). template <typename T> IT into(T & t); template <typename T, typename T1> IT into(T & t, T1 p1); template <typename T> IT into(T & t, indicator & ind); template <typename T, typename T1> IT into(T & t, indicator & ind, T1 p1); template <typename T> IT into(T & t, std::vector<indicator> & ind); Example: int count; sql << \"select count(*) from person\", into(count); See Binding output data for more examples","title":"function into"},{"location":"api/client/#function-use","text":"The function use is used for binding local input data (in other words, it defines where the parameters of the query come from). template <typename T> *IT* use(T & t); template <typename T, typename T1> *IT* use(T & t, T1 p1); template <typename T> *IT* use(T & t, indicator & ind); template <typename T, typename T1> *IT* use(T & t, indicator & ind, T1 p1); template <typename T> *IT* use(T & t, std::vector<indicator> const & ind); template <typename T, typename T1> *IT* use(T & t, std::vector<indicator> const & ind, T1 p1); Example: int val = 7; sql << \"insert into numbers(val) values(:val)\", use(val); See Binding input data for more examples.","title":"function use"},{"location":"api/client/#class-statement","text":"The statement class encapsulates the prepared statement. class statement { public: statement(session & s); statement(*IT* const & prep); ~statement(); statement(statement const & other); void operator=(statement const & other); void alloc(); void bind(values & v); void exchange(*IT* const & i); void exchange(*IT* const & u); void clean_up(); void bind_clean_up(); void prepare(std::string const & query); void define_and_bind(); bool execute(bool withDataExchange = false); long long get_affected_rows(); bool fetch(); bool got_data() const; void describe(); void set_row(row * r); void exchange_for_rowset(*IT* const & i); details::statement_backend * get_backend(); }; This class contains the following members: Constructor accepting the session object. This can be used for later query preparation. Example: statement stmt(sql); Constructor accepting the result of using prepare on the session object, see example provided above for the session class. Copy operations. alloc function, which allocates necessary internal resources. bind function, which is used to bind the values object - this is used in the object-relational mapping and normally called automatically. exchange functions for registering the binding of local data - they expect the result of calling the into or use functions and are normally invoked automatically. clean_up function for cleaning up resources, normally called automatically. bind_clean_up function for cleaning up any bound references. It allows to keep statement in cache and reuse it later with new references by calling exchange for each new bind variable. prepare function for preparing the statement for repeated execution. define_and_bind function for actually executing the registered bindings, normally called automatically. execute function for executing the statement. If its parameter is false then there is no data exchange with locally bound variables (this form should be used if later fetch of multiple rows is foreseen). Returns true if there was at least one row of data returned. get_affected_rows function returns the number of rows affected by the last statement. Returns -1 if it's not implemented by the backend being used. fetch function for retrieving the next portion of the result. Returns true if there was new data. got_data return true if the most recent execution returned any rows. describe function for extracting the type information for the result ( Note: no data is exchanged). This is normally called automatically and only when dynamic resultset binding is used. set_row function for associating the statement and row objects, normally called automatically. exchange_for_rowset as a special case for binding rowset objects. get_backend function that returns the internal pointer to the concrete backend implementation of the statement object. This is provided for advanced users that need access to the functionality that is not otherwise available. See Statement preparation and repeated execution for example uses. Most of the functions from the statement class interface are called automatically, but can be also used explicitly. See Interfaces for the description of various way to use this interface.","title":"class statement"},{"location":"api/client/#class-procedure","text":"The procedure class encapsulates the call to the stored procedure and is aimed for higher portability of the client code. class procedure { public: procedure(*IT* const & prep); bool execute(bool withDataExchange = false); bool fetch(); bool got_data() const; }; The constructor expects the result of using prepare on the session object. See Stored procedures for examples.","title":"class procedure"},{"location":"api/client/#class-type_conversion","text":"The type_conversion class is a traits class that is supposed to be provided (specialized) by the user for defining conversions to and from one of the basic SOCI types. template <typename T> struct type_conversion { typedef T base_type; static void from_base(base_type const & in, indicator ind, T & out); static void to_base(T const & in, base_type & out, indicator & ind); }; Users are supposed to properly implement the from_base and to_base functions in their specializations of this template class. See Extending SOCI to support custom (user-defined) C++ types .","title":"class type_conversion"},{"location":"api/client/#class-row","text":"The row class encapsulates the data and type information retrieved for the single row when the dynamic rowset binding is used. class row { public: row(); ~row(); void uppercase_column_names(bool forceToUpper); std::size_t size() const; indicator get_indicator(std::size_t pos) const; indicator get_indicator(std::string const & name) const; column_properties const & get_properties (std::size_t pos) const; column_properties const & get_properties (std::string const & name) const; template <typename T> T get(std::size_t pos) const; template <typename T> T get(std::size_t pos, T const & nullValue) const; template <typename T> T get(std::string const & name) const; template <typename T> T get(std::string const & name, T const & nullValue) const; template <typename T> row const & operator>>(T & value) const; void skip(std::size_t num = 1) const; void reset_get_counter() const }; This class contains the following members: Default constructor that allows to declare a row variable. uppercase_column_names - see the same function in the session class. size function that returns the number of columns in the row. get_indicator function that returns the indicator value for the given column (column is specified by position - starting from 0 - or by name). get_properties function that returns the properties of the column given by position (starting from 0) or by name. get functions that return the value of the column given by position or name. If the column contains null, then these functions either return the provided \"default\" nullValue or throw an exception. operator>> for convenience stream-like extraction interface. Subsequent calls to this function are equivalent to calling get with increasing position parameter, starting from the beginning. skip and reset_get_counter allow to change the order of data extraction for the above operator. See Dynamic resultset binding for examples.","title":"class row"},{"location":"api/client/#class-column_properties","text":"The column_properties class provides the type and name information about the particular column in a rowset. class column_properties { public: std::string get_name() const; data_type get_data_type() const; }; This class contains the following members: get_name function that returns the name of the column. get_data_type that returns the type of the column. See Dynamic resultset binding for examples.","title":"class column_properties"},{"location":"api/client/#class-values","text":"The values class encapsulates the data and type information and is used for object-relational mapping. class values { public: values(); void uppercase_column_names(bool forceToUpper); indicator get_indicator(std::size_t pos) const; indicator get_indicator(std::string const & name) const; template <typename T> T get(std::size_t pos) const; template <typename T> T get(std::size_t pos, T const & nullValue) const; template <typename T> T get(std::string const & name) const; template <typename T> T get(std::string const & name, T const & nullValue) const; template <typename T> values const & operator>>(T & value) const; void skip(std::size_t num = 1) const; void reset_get_counter() const; template <typename T> void set(std::string const & name, T const & value, indicator indic = i_ok); template <typename T> void set(const T & value, indicator indic = i_ok); template <typename T> values & operator<<(T const & value); }; This class contains the same members as the row class (with the same meaning) plus: set function for storing values in named columns or in subsequent positions. operator<< for convenience. See Object-relational mapping for examples.","title":"class values"},{"location":"api/client/#class-blob","text":"The blob class encapsulates the \"large object\" functionality. class blob { public: explicit blob(session & s); ~blob(); std::size_t getLen(); std::size_t read(std::size_t offset, char * buf, std::size_t toRead); std::size_t write(std::size_t offset, char const * buf, std::size_t toWrite); std::size_t append(char const * buf, std::size_t toWrite); void trim(std::size_t newLen); details::blob_backend * get_backend(); }; This class contains the following members: Constructor associating the blob object with the session object. get_len function that returns the size of the BLOB object. read function that reads the BLOB data into provided buffer. write function that writes the BLOB data from provided buffer. append function that appends to the existing BLOB data. trim function that truncates the existing data to the new length. get_backend function that returns the internal pointer to the concrete backend implementation of the BLOB object. This is provided for advanced users that need access to the functionality that is not otherwise available. See Large objects (BLOBs) for more discussion.","title":"class blob"},{"location":"api/client/#class-rowid","text":"The rowid class encapsulates the \"row identifier\" object. class rowid { public: explicit rowid(Session & s); ~rowid(); details::rowid_backend * get_backend(); }; This class contains the following members: Constructor associating the rowid object with the session object. get_backend function that returns the internal pointer to the concrete backend implementation of the rowid object.","title":"class rowid"},{"location":"api/client/#class-backend_factory","text":"The backend_factory class provides the abstract interface for concrete backend factories. struct backend_factory { virtual details::session_backend * make_session( std::string const & connectString) const = 0; }; The only member of this class is the make_session function that is supposed to create concrete backend implementation of the session object. Objects of this type are declared by each backend and should be provided to the constructor of the session class. In simple programs users do not need to use this class directly, but the example use is: backend_factory & factory = postgresql; std::string connectionParameters = \"dbname=mydb\"; session sql(factory, parameters);","title":"class backend_factory"},{"location":"api/client/#simple-client-interface","text":"The simple client interface is provided with other languages in mind, to allow easy integration of the SOCI library with script interpreters and those languages that have the ability to link directly with object files using the \"C\" calling convention. The functionality of this interface is limited and in particular the dynamic rowset description and type conversions are not supported in this release. On the other hand, the important feature of this interface is that it does not require passing pointers to data managed by the user, because all data is handled at the SOCI side. This should make it easier to integrate SOCI with languages that have constrained ability to understand the C type system. Users of this interface need to explicitly #include <soci-simple.h> . typedef void * session_handle; session_handle soci_create_session(char const * connectionString); void soci_destroy_session(session_handle s); void soci_begin(session_handle s); void soci_commit(session_handle s); void soci_rollback(session_handle s); int soci_session_state(session_handle s); char const * soci_session_error_message(session_handle s); The functions above provide the session abstraction with the help of opaque handle. The soci_session_state function returns 1 if there was no error during the most recently executed function and 0 otherwise, in which case the soci_session_error_message can be used to obtain a human-readable error description. Note that the only function that cannot report all errors this way is soci_create_session , which returns NULL if it was not possible to create an internal object representing the session. However, if the proxy object was created, but the connection could not be established for whatever reason, the error message can be obtained in the regular way. typedef void *blob_handle; blob_handle soci_create_blob(session_handle s); void soci_destroy_blob(blob_handle b); int soci_blob_get_len(blob_handle b); int soci_blob_read(blob_handle b, int offset, char *buf, int toRead); int soci_blob_write(blob_handle b, int offset, char const *buf, int toWrite); int soci_blob_append(blob_handle b, char const *buf, int toWrite); int soci_blob_trim(blob_handle b, int newLen); int soci_blob_state(blob_handle b); char const * soci_blob_error_message(blob_handle b); The functions above provide the blob abstraction with the help of opaque handle. The soci_blob_state function returns 1 if there was no error during the most recently executed function and 0 otherwise, in which case the soci_session_error_message can be used to obtain a human-readable error description. For easy error testing, functions soci_blob_read , soci_blob_write , soci_blob_append , and soci_blob_trim return -1 in case of error and soci_session_error_message can be used to obtain a human-readable error description. Note that the only function that cannot report all errors this way is soci_create_blob , which returns NULL if it was not possible to create an internal object representing the blob. typedef void * statement_handle; statement_handle soci_create_statement(session_handle s); void soci_destroy_statement(statement_handle st); int soci_statement_state(statement_handle s); char const * soci_statement_error_message(statement_handle s); The functions above create and destroy the statement object. If the statement cannot be created by the soci_create_statement function, the error condition is set up in the related session object; for all other functions the error condition is set in the statement object itself. int soci_into_string (statement_handle st); int soci_into_int (statement_handle st); int soci_into_long_long(statement_handle st); int soci_into_double (statement_handle st); int soci_into_date (statement_handle st); int soci_into_blob (statement_handle st); int soci_into_string_v (statement_handle st); int soci_into_int_v (statement_handle st); int soci_into_long_long_v(statement_handle st); int soci_into_double_v (statement_handle st); int soci_into_date_v (statement_handle st); These functions create new data items for storing query results ( into elements ). These elements can be later identified by their position, which is counted from 0. For convenience, these function return the position of the currently added element. In case of error, -1 is returned and the error condition is set in the statement object. The _v versions create a vector into elements, which can be used to retrieve whole arrays of results. int soci_get_into_state(statement_handle st, int position); int soci_get_into_state_v(statement_handle st, int position, int index); This function returns 1 if the into element at the given position has non-null value and 0 otherwise. The _v version works with vector elements and expects an array index. char const * soci_get_into_string (statement_handle st, int position); int soci_get_into_int (statement_handle st, int position); long long soci_get_into_long_long(statement_handle st, int position); double soci_get_into_double (statement_handle st, int position); char const * soci_get_into_date (statement_handle st, int position); blob_handle soci_get_into_blob (statement_handle st, int position); char const * soci_get_into_string_v (statement_handle st, int position, int index); int soci_get_into_int_v (statement_handle st, int position, int index); long long soci_get_into_long_long_v(statement_handle st, int position, int index); double soci_get_into_double_v (statement_handle st, int position, int index); char const * soci_get_into_date_v (statement_handle st, int position, int index); The functions above allow to retrieve the current value of the given into element. Note: The date function returns the date value in the \" YYYY MM DD HH mm ss \" string format. void soci_use_string (statement_handle st, char const * name); void soci_use_int (statement_handle st, char const * name); void soci_use_long_long(statement_handle st, char const * name); void soci_use_double (statement_handle st, char const * name); void soci_use_date (statement_handle st, char const * name); void soci_use_blob (statement_handle st, char const * name); void soci_use_string_v (statement_handle st, char const * name); void soci_use_int_v (statement_handle st, char const * name); void soci_use_long_long_v(statement_handle st, char const * name); void soci_use_double_v (statement_handle st, char const * name); void soci_use_date_v (statement_handle st, char const * name); The functions above allow to create new data elements that will be used to provide data to the query ( use elements ). The new elements can be later identified by given name, which must be unique for the given statement. void soci_set_use_state(statement_handle st, char const * name, int state); The soci_set_use_state function allows to set the state of the given use element. If the state parameter is set to non-zero the use element is considered non-null (which is also the default state after creating the use element). int soci_use_get_size_v(statement_handle st); void soci_use_resize_v (statement_handle st, int new_size); These functions get and set the size of vector use elements (see comments for vector into elements above). void soci_set_use_string (statement_handle st, char const * name, char const * val); void soci_set_use_int (statement_handle st, char const * name, int val); void soci_set_use_long_long(statement_handle st, char const * name, long long val); void soci_set_use_double (statement_handle st, char const * name, double val); void soci_set_use_date (statement_handle st, char const * name, char const * val); void soci_set_use_blob (statement_handle st, char const * name, blob_handle blob); void soci_set_use_state_v (statement_handle st, char const * name, int index, int state); void soci_set_use_string_v (statement_handle st, char const * name, int index, char const * val); void soci_set_use_int_v (statement_handle st, char const * name, int index, int val); void soci_set_use_long_long_v(statement_handle st, char const * name, int index, long long val); void soci_set_use_double_v (statement_handle st, char const * name, int index, double val); void soci_set_use_date_v (statement_handle st, char const * name, int index, char const * val); The functions above set the value of the given use element, for both single and vector elements. Note: The expected format for the data values is \" YYYY MM DD HH mm ss \". int soci_get_use_state (statement_handle st, char const * name); char const * soci_get_use_string (statement_handle st, char const * name); int soci_get_use_int (statement_handle st, char const * name); long long soci_get_use_long_long(statement_handle st, char const * name); double soci_get_use_double (statement_handle st, char const * name); char const * soci_get_use_date (statement_handle st, char const * name); blob_handle soci_get_use_blob (statement_handle st, char const * name); These functions allow to inspect the state and value of named use elements. Note: these functions are provide only for single use elements, not for vectors; the rationale for this is that modifiable use elements are not supported for bulk operations. void soci_prepare(statement_handle st, char const * query); int soci_execute(statement_handle st, int withDataExchange); int soci_fetch(statement_handle st); int soci_got_data(statement_handle st); The functions above provide the core execution functionality for the statement object and their meaning is equivalent to the respective functions in the core C++ interface described above.","title":"Simple Client Interface"},{"location":"backends/","text":"Supported Backends and Features Follow the links to learn more about each backend and detailed supported features. Oracle PostgreSQL MySQL SQLite3 Firebird ODBC DB2 Binding by Name YES YES (\u22658.0) YES YES YES YES YES Dynamic Binding YES YES YES YES YES YES Bulk Operations YES YES YES YES YES YES YES Transactions YES YES YES (\u22654.0) YES YES YES YES BLOB Data Type YES YES YES (mapped to std::string ) YES YES NO NO RowID Data Type YES YES NO NO NO NO NO Nested Statements YES NO NO NO NO NO YES Stored Procedures YES YES NO (but stored functions, YES) NO YES NO YES","title":"Features"},{"location":"backends/#supported-backends-and-features","text":"Follow the links to learn more about each backend and detailed supported features. Oracle PostgreSQL MySQL SQLite3 Firebird ODBC DB2 Binding by Name YES YES (\u22658.0) YES YES YES YES YES Dynamic Binding YES YES YES YES YES YES Bulk Operations YES YES YES YES YES YES YES Transactions YES YES YES (\u22654.0) YES YES YES YES BLOB Data Type YES YES YES (mapped to std::string ) YES YES NO NO RowID Data Type YES YES NO NO NO NO NO Nested Statements YES NO NO NO NO NO YES Stored Procedures YES YES NO (but stored functions, YES) NO YES NO YES","title":"Supported Backends and Features"},{"location":"backends/db2/","text":"DB2 Backend Reference SOCI backend for accessing IBM DB2 database. Prerequisites Supported Versions See Tested Platforms . Tested Platforms DB2 OS Compiler - Linux PPC64 GCC 9.1 Linux GCC 9.5 Linux GCC 9.7 Linux GCC 10.1 Linux GCC 10.1 Windows 8 Visual Studio 2012 10.5.0.5 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI DB2 backend requires client library from the IBM Data Server Driver Package (DS Driver) . Connecting to the Database On Unix, before using the DB2 backend please make sure, that you have sourced DB2 profile into your environment: . ~/db2inst1/sqllib/db2profile To establish a connection to the DB2 database, create a session object using the DB2 backend factory together with the database file name: soci::session sql(soci::db2, \"your DB2 connection string here\"); SOCI Feature Support Dynamic Binding TODO Bulk Operations Supported, but with caution as it hasn't been extensively tested. Transactions Currently, not supported. BLOB Data Type Currently, not supported. Nested Statements Nesting statements are not processed by SOCI in any special way and they work as implemented by the DB2 database. Stored Procedures Stored procedures are supported, with CALL statement. Native API Access TODO Backend-specific extensions None. Configuration options This backend supports db2_option_driver_complete option which can be passed to it via connection_parameters class. The value of this option is passed to SQLDriverConnect() function as \"driver completion\" parameter and so must be one of SQL_DRIVER_XXX values, in the string form. The default value of this option is SQL_DRIVER_PROMPT meaning that the driver will query the user for the user name and/or the password if they are not stored together with the connection. If this is undesirable for some reason, you can use SQL_DRIVER_NOPROMPT value for this option to suppress showing the message box: connection_parameters parameters(\"db2\", \"DSN=sample\"); parameters.set_option(db2_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters); Note, db2_option_driver_complete controls driver completion specific to the IBM DB2 driver for ODBC and CLI.","title":"DB2"},{"location":"backends/db2/#db2-backend-reference","text":"SOCI backend for accessing IBM DB2 database.","title":"DB2 Backend Reference"},{"location":"backends/db2/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/db2/#supported-versions","text":"See Tested Platforms .","title":"Supported Versions"},{"location":"backends/db2/#tested-platforms","text":"DB2 OS Compiler - Linux PPC64 GCC 9.1 Linux GCC 9.5 Linux GCC 9.7 Linux GCC 10.1 Linux GCC 10.1 Windows 8 Visual Studio 2012 10.5.0.5 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/db2/#required-client-libraries","text":"The SOCI DB2 backend requires client library from the IBM Data Server Driver Package (DS Driver) .","title":"Required Client Libraries"},{"location":"backends/db2/#connecting-to-the-database","text":"On Unix, before using the DB2 backend please make sure, that you have sourced DB2 profile into your environment: . ~/db2inst1/sqllib/db2profile To establish a connection to the DB2 database, create a session object using the DB2 backend factory together with the database file name: soci::session sql(soci::db2, \"your DB2 connection string here\");","title":"Connecting to the Database"},{"location":"backends/db2/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/db2/#dynamic-binding","text":"TODO","title":"Dynamic Binding"},{"location":"backends/db2/#bulk-operations","text":"Supported, but with caution as it hasn't been extensively tested.","title":"Bulk Operations"},{"location":"backends/db2/#transactions","text":"Currently, not supported.","title":"Transactions"},{"location":"backends/db2/#blob-data-type","text":"Currently, not supported.","title":"BLOB Data Type"},{"location":"backends/db2/#nested-statements","text":"Nesting statements are not processed by SOCI in any special way and they work as implemented by the DB2 database.","title":"Nested Statements"},{"location":"backends/db2/#stored-procedures","text":"Stored procedures are supported, with CALL statement.","title":"Stored Procedures"},{"location":"backends/db2/#native-api-access","text":"TODO","title":"Native API Access"},{"location":"backends/db2/#backend-specific-extensions","text":"None.","title":"Backend-specific extensions"},{"location":"backends/db2/#configuration-options","text":"This backend supports db2_option_driver_complete option which can be passed to it via connection_parameters class. The value of this option is passed to SQLDriverConnect() function as \"driver completion\" parameter and so must be one of SQL_DRIVER_XXX values, in the string form. The default value of this option is SQL_DRIVER_PROMPT meaning that the driver will query the user for the user name and/or the password if they are not stored together with the connection. If this is undesirable for some reason, you can use SQL_DRIVER_NOPROMPT value for this option to suppress showing the message box: connection_parameters parameters(\"db2\", \"DSN=sample\"); parameters.set_option(db2_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters); Note, db2_option_driver_complete controls driver completion specific to the IBM DB2 driver for ODBC and CLI.","title":"Configuration options"},{"location":"backends/firebird/","text":"Firebird Backend Reference SOCI backend for accessing Firebird database. Prerequisites Supported Versions The SOCI Firebird backend supports versions of Firebird from 1.5 to 2.5 and can be used with either the client-server or embedded Firebird libraries. The former is the default, to select the latter set SOCI_FIREBIRD_EMBEDDED CMake option to ON value when building. Tested Platforms Firebird OS Compiler 1.5.2.4731 SunOS 5.10 g++ 3.4.3 1.5.2.4731 Windows XP Visual C++ 8.0 1.5.3.4870 Windows XP Visual C++ 8.0 Professional 2.5.2.26540 Debian GNU/Linux 7 g++ 4.7.2 2.5.8.27089 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The Firebird backend requires Firebird's libfbclient client library. For example, on Ubuntu Linux, for example, firebird-dev package and its dependencies are required. Connecting to the Database To establish a connection to a Firebird database, create a Session object using the firebird backend factory together with a connection string: BackEndFactory const &backEnd = firebird; session sql(backEnd, \"service=/usr/local/firbird/db/test.fdb user=SYSDBA password=masterkey\"); or simply: session sql(firebird, \"service=/usr/local/firbird/db/test.fdb user=SYSDBA password=masterkey\"); The set of parameters used in the connection string for Firebird is: service user password role charset The following parameters have to be provided as part of the connection string : service , user , password . Role and charset parameters are optional. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from user_tables\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The Firebird backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the Firebird backend, this type mapping is: Firebird Data Type SOCI Data Type row::get<T> specializations numeric, decimal (where scale > 0) dt_double double numeric, decimal [^1] (where scale = 0) dt_integer, dt_double int, double double precision, float dt_double double smallint, integer dt_integer int char, varchar dt_string std::string date, time, timestamp dt_date std::tm [^1] There is also 64bit integer type for larger values which is currently not supported. (See the dynamic resultset binding documentation for general information on using the Row class.) Binding by Name In addition to binding by position , the Firebird backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") It should be noted that parameter binding by name is supported only by means of emulation, since the underlying API used by the backend doesn't provide this feature. Bulk Operations The Firebird backend has full support for SOCI bulk operations interface. This feature is also supported by emulation. Transactions Transactions are also fully supported by the Firebird backend. In fact, an implicit transaction is always started when using this backend if one hadn't been started by explicitly calling begin() before. The current transaction is automatically committed in session destructor. BLOB Data Type The Firebird backend supports working with data stored in columns of type Blob, via SOCI BLOB class. It should by noted, that entire Blob data is fetched from database to allow random read and write access. This is because Firebird itself allows only writing to a new Blob or reading from existing one - modifications of existing Blob means creating a new one. Firebird backend hides those details from user. RowID Data Type This feature is not supported by Firebird backend. Nested Statements This feature is not supported by Firebird backend. Stored Procedures Firebird stored procedures can be executed by using SOCI Procedure class. Native API Access SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The Firebird backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() firebird_session_backend statement_backend * statement::get_backend() firebird_statement_backend blob_backend * blob::get_backend() firebird_blob_backend rowid_backend * rowid::get_backend() Backend-specific extensions firebird_soci_error The Firebird backend can throw instances of class firebird_soci_error , which is publicly derived from soci_error and has an additional public status_ member containing the Firebird status vector.","title":"Firebird"},{"location":"backends/firebird/#firebird-backend-reference","text":"SOCI backend for accessing Firebird database.","title":"Firebird Backend Reference"},{"location":"backends/firebird/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/firebird/#supported-versions","text":"The SOCI Firebird backend supports versions of Firebird from 1.5 to 2.5 and can be used with either the client-server or embedded Firebird libraries. The former is the default, to select the latter set SOCI_FIREBIRD_EMBEDDED CMake option to ON value when building.","title":"Supported Versions"},{"location":"backends/firebird/#tested-platforms","text":"Firebird OS Compiler 1.5.2.4731 SunOS 5.10 g++ 3.4.3 1.5.2.4731 Windows XP Visual C++ 8.0 1.5.3.4870 Windows XP Visual C++ 8.0 Professional 2.5.2.26540 Debian GNU/Linux 7 g++ 4.7.2 2.5.8.27089 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/firebird/#required-client-libraries","text":"The Firebird backend requires Firebird's libfbclient client library. For example, on Ubuntu Linux, for example, firebird-dev package and its dependencies are required.","title":"Required Client Libraries"},{"location":"backends/firebird/#connecting-to-the-database","text":"To establish a connection to a Firebird database, create a Session object using the firebird backend factory together with a connection string: BackEndFactory const &backEnd = firebird; session sql(backEnd, \"service=/usr/local/firbird/db/test.fdb user=SYSDBA password=masterkey\"); or simply: session sql(firebird, \"service=/usr/local/firbird/db/test.fdb user=SYSDBA password=masterkey\"); The set of parameters used in the connection string for Firebird is: service user password role charset The following parameters have to be provided as part of the connection string : service , user , password . Role and charset parameters are optional. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from user_tables\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/firebird/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/firebird/#dynamic-binding","text":"The Firebird backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the Firebird backend, this type mapping is: Firebird Data Type SOCI Data Type row::get<T> specializations numeric, decimal (where scale > 0) dt_double double numeric, decimal [^1] (where scale = 0) dt_integer, dt_double int, double double precision, float dt_double double smallint, integer dt_integer int char, varchar dt_string std::string date, time, timestamp dt_date std::tm [^1] There is also 64bit integer type for larger values which is currently not supported. (See the dynamic resultset binding documentation for general information on using the Row class.)","title":"Dynamic Binding"},{"location":"backends/firebird/#binding-by-name","text":"In addition to binding by position , the Firebird backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") It should be noted that parameter binding by name is supported only by means of emulation, since the underlying API used by the backend doesn't provide this feature.","title":"Binding by Name"},{"location":"backends/firebird/#bulk-operations","text":"The Firebird backend has full support for SOCI bulk operations interface. This feature is also supported by emulation.","title":"Bulk Operations"},{"location":"backends/firebird/#transactions","text":"Transactions are also fully supported by the Firebird backend. In fact, an implicit transaction is always started when using this backend if one hadn't been started by explicitly calling begin() before. The current transaction is automatically committed in session destructor.","title":"Transactions"},{"location":"backends/firebird/#blob-data-type","text":"The Firebird backend supports working with data stored in columns of type Blob, via SOCI BLOB class. It should by noted, that entire Blob data is fetched from database to allow random read and write access. This is because Firebird itself allows only writing to a new Blob or reading from existing one - modifications of existing Blob means creating a new one. Firebird backend hides those details from user.","title":"BLOB Data Type"},{"location":"backends/firebird/#rowid-data-type","text":"This feature is not supported by Firebird backend.","title":"RowID Data Type"},{"location":"backends/firebird/#nested-statements","text":"This feature is not supported by Firebird backend.","title":"Nested Statements"},{"location":"backends/firebird/#stored-procedures","text":"Firebird stored procedures can be executed by using SOCI Procedure class.","title":"Stored Procedures"},{"location":"backends/firebird/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The Firebird backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() firebird_session_backend statement_backend * statement::get_backend() firebird_statement_backend blob_backend * blob::get_backend() firebird_blob_backend rowid_backend * rowid::get_backend()","title":"Native API Access"},{"location":"backends/firebird/#backend-specific-extensions","text":"","title":"Backend-specific extensions"},{"location":"backends/firebird/#firebird_soci_error","text":"The Firebird backend can throw instances of class firebird_soci_error , which is publicly derived from soci_error and has an additional public status_ member containing the Firebird status vector.","title":"firebird_soci_error"},{"location":"backends/mysql/","text":"MySQL Backend Reference SOCI backend for accessing MySQL database. Prerequisites Supported Versions The SOCI MySQL backend should in principle work with every version of MySQL 5.x. Some of the features (transactions, stored functions) are not available when MySQL server doesn't support them. Tested Platforms MySQL OS Compiler 8.0.1 Windows 10 Visual Studio 2017 (15.3.3) 5.5.28 OS X 10.8.2 Apple LLVM version 4.2 (clang-425.0.24) 5.0.96 Ubuntu 8.04.4 LTS (Hardy Heron) g++ (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4) 5.7.22 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI MySQL backend requires MySQL's libmysqlclient client library from the MySQL Connector/C . Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_mysql -ldl -lmysqlclient Connecting to the Database To establish a connection to a MySQL server, create a session object using the mysql backend factory together with a connection string: session sql(mysql, \"db=test user=root password='Ala ma kota'\"); // or: session sql(\"mysql\", \"db=test user=root password='Ala ma kota'\"); // or: session sql(\"mysql://db=test user=root password='Ala ma kota'\"); The set of parameters used in the connection string for MySQL is: dbname or db or service (required) user password or pass host port unix_socket sslca sslcert local_infile - should be 0 or 1 , 1 means MYSQL_OPT_LOCAL_INFILE will be set. charset connect_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_CONNECT_TIMEOUT . read_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_READ_TIMEOUT . write_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_WRITE_TIMEOUT . Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The MySQL backend supports the use of the SOCI row class, which facilitates retrieval of data which type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the MySQL backend, this type mapping is: MySQL Data Type SOCI Data Type row::get<T> specializations FLOAT, DOUBLE, DECIMAL and synonyms dt_double double TINYINT, TINYINT UNSIGNED, SMALLINT, SMALLINT UNSIGNED, INT dt_integer int INT UNSIGNED dt_long_long long long or unsigned BIGINT dt_long_long long long BIGINT UNSIGNED dt_unsigned_long_long unsigned long long CHAR, VARCHAR, BINARY, VARBINARY, TINYBLOB, MEDIUMBLOB, BLOB,LONGBLOB, TINYTEXT, MEDIUMTEXT, TEXT, LONGTEXT, ENUM dt_string std::string TIMESTAMP (works only with MySQL >= 5.0), DATE, TIME, DATETIME dt_date std::tm (See the dynamic resultset binding documentation for general information on using the Row class.) Binding by Name In addition to binding by position , the MySQL backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") It should be noted that parameter binding of any kind is supported only by means of emulation, since the underlying API used by the backend doesn't provide this feature. Bulk Operations Transactions Transactions are also supported by the MySQL backend. Please note, however, that transactions can only be used when the MySQL server supports them (it depends on options used during the compilation of the server; typically, but not always, servers >=4.0 support transactions and earlier versions do not) and only with appropriate table types. BLOB Data Type SOCI blob interface is not supported by the MySQL backend. Note that this does not mean you cannot use MySQL's BLOB types. They can be selected using the usual SQL syntax and read into std::string on the C++ side, so no special interface is required. RowID Data Type The rowid functionality is not supported by the MySQL backend. Nested Statements Nested statements are not supported by the MySQL backend. Stored Procedures MySQL version 5.0 and later supports two kinds of stored routines: stored procedures and stored functions (for details, please consult the Defining Stored Programs ). Stored functions can be executed by using SOCI's procedure class . There is currently no support for stored procedures. Native API Access SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The MySQL backend provides the following concrete classes for native API access: Accessor Function Concrete Class session_backend * session::get_backend() mysql_session_backend statement_backend * statement::get_backend() mysql_statement_backend Backend-specific extensions None. Configuration options None.","title":"MySQL"},{"location":"backends/mysql/#mysql-backend-reference","text":"SOCI backend for accessing MySQL database.","title":"MySQL Backend Reference"},{"location":"backends/mysql/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/mysql/#supported-versions","text":"The SOCI MySQL backend should in principle work with every version of MySQL 5.x. Some of the features (transactions, stored functions) are not available when MySQL server doesn't support them.","title":"Supported Versions"},{"location":"backends/mysql/#tested-platforms","text":"MySQL OS Compiler 8.0.1 Windows 10 Visual Studio 2017 (15.3.3) 5.5.28 OS X 10.8.2 Apple LLVM version 4.2 (clang-425.0.24) 5.0.96 Ubuntu 8.04.4 LTS (Hardy Heron) g++ (GCC) 4.2.4 (Ubuntu 4.2.4-1ubuntu4) 5.7.22 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/mysql/#required-client-libraries","text":"The SOCI MySQL backend requires MySQL's libmysqlclient client library from the MySQL Connector/C . Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_mysql -ldl -lmysqlclient","title":"Required Client Libraries"},{"location":"backends/mysql/#connecting-to-the-database","text":"To establish a connection to a MySQL server, create a session object using the mysql backend factory together with a connection string: session sql(mysql, \"db=test user=root password='Ala ma kota'\"); // or: session sql(\"mysql\", \"db=test user=root password='Ala ma kota'\"); // or: session sql(\"mysql://db=test user=root password='Ala ma kota'\"); The set of parameters used in the connection string for MySQL is: dbname or db or service (required) user password or pass host port unix_socket sslca sslcert local_infile - should be 0 or 1 , 1 means MYSQL_OPT_LOCAL_INFILE will be set. charset connect_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_CONNECT_TIMEOUT . read_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_READ_TIMEOUT . write_timeout - should be positive integer value that means seconds corresponding to MYSQL_OPT_WRITE_TIMEOUT . Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/mysql/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/mysql/#dynamic-binding","text":"The MySQL backend supports the use of the SOCI row class, which facilitates retrieval of data which type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the MySQL backend, this type mapping is: MySQL Data Type SOCI Data Type row::get<T> specializations FLOAT, DOUBLE, DECIMAL and synonyms dt_double double TINYINT, TINYINT UNSIGNED, SMALLINT, SMALLINT UNSIGNED, INT dt_integer int INT UNSIGNED dt_long_long long long or unsigned BIGINT dt_long_long long long BIGINT UNSIGNED dt_unsigned_long_long unsigned long long CHAR, VARCHAR, BINARY, VARBINARY, TINYBLOB, MEDIUMBLOB, BLOB,LONGBLOB, TINYTEXT, MEDIUMTEXT, TEXT, LONGTEXT, ENUM dt_string std::string TIMESTAMP (works only with MySQL >= 5.0), DATE, TIME, DATETIME dt_date std::tm (See the dynamic resultset binding documentation for general information on using the Row class.)","title":"Dynamic Binding"},{"location":"backends/mysql/#binding-by-name","text":"In addition to binding by position , the MySQL backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") It should be noted that parameter binding of any kind is supported only by means of emulation, since the underlying API used by the backend doesn't provide this feature.","title":"Binding by Name"},{"location":"backends/mysql/#bulk-operations","text":"","title":"Bulk Operations"},{"location":"backends/mysql/#transactions","text":"Transactions are also supported by the MySQL backend. Please note, however, that transactions can only be used when the MySQL server supports them (it depends on options used during the compilation of the server; typically, but not always, servers >=4.0 support transactions and earlier versions do not) and only with appropriate table types.","title":"Transactions"},{"location":"backends/mysql/#blob-data-type","text":"SOCI blob interface is not supported by the MySQL backend. Note that this does not mean you cannot use MySQL's BLOB types. They can be selected using the usual SQL syntax and read into std::string on the C++ side, so no special interface is required.","title":"BLOB Data Type"},{"location":"backends/mysql/#rowid-data-type","text":"The rowid functionality is not supported by the MySQL backend.","title":"RowID Data Type"},{"location":"backends/mysql/#nested-statements","text":"Nested statements are not supported by the MySQL backend.","title":"Nested Statements"},{"location":"backends/mysql/#stored-procedures","text":"MySQL version 5.0 and later supports two kinds of stored routines: stored procedures and stored functions (for details, please consult the Defining Stored Programs ). Stored functions can be executed by using SOCI's procedure class . There is currently no support for stored procedures.","title":"Stored Procedures"},{"location":"backends/mysql/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The MySQL backend provides the following concrete classes for native API access: Accessor Function Concrete Class session_backend * session::get_backend() mysql_session_backend statement_backend * statement::get_backend() mysql_statement_backend","title":"Native API Access"},{"location":"backends/mysql/#backend-specific-extensions","text":"None.","title":"Backend-specific extensions"},{"location":"backends/mysql/#configuration-options","text":"None.","title":"Configuration options"},{"location":"backends/odbc/","text":"ODBC Backend Reference SOCI backend for accessing variety of databases via ODBC API. Prerequisites Supported Versions The SOCI ODBC backend is supported for use with ODBC 3. Tested Platforms ODBC OS Compiler 3 Linux (Ubuntu 12.04) g++ 4.6.3 3 Linux (Ubuntu 12.04) clang 3.2 3.8 Windows 8 Visual Studio 2012 3 Windows 7 Visual Studio 2010 3 Windows XP Visual Studio 2005 (express) 3 Windows XP Visual C++ 8.0 Professional 3 Windows XP g++ 3.3.4 (Cygwin) 3 (unixodbc 2.3.6) macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI ODBC backend requires the ODBC client library. Connecting to the Database To establish a connection to the ODBC database, create a Session object using the ODBC backend factory together with a connection string: backend_factory const&amp; backEnd = odbc; session sql(backEnd, \"filedsn=c:\\\\my.dsn\"); or simply: session sql(odbc, \"filedsn=c:\\\\my.dsn\"); The set of parameters used in the connection string for ODBC is the same as accepted by the SQLDriverConnect function from the ODBC library. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The ODBC backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the ODBC backend, this type mapping is: ODBC Data Type SOCI Data Type row::get<T> specializations SQL_DOUBLE, SQL_DECIMAL, SQL_REAL, SQL_FLOAT, SQL_NUMERIC dt_double double SQL_TINYINT, SQL_SMALLINT, SQL_INTEGER, SQL_BIGINT dt_integer int SQL_CHAR, SQL_VARCHAR dt_string std::string SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP dt_date std::tm Not all ODBC drivers support all datatypes. (See the dynamic resultset binding documentation for general information on using the row class.) Binding by Name In addition to binding by position , the ODBC backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") Apart from the portable \"colon-name\" syntax above, which is achieved by rewriting the query string, the backend also supports the ODBC ? syntax: int i = 7; int j = 8; sql << \"insert into t(x, y) values(?, ?)\", use(i), use(j); Bulk Operations The ODBC backend has support for SOCI's bulk operations interface. Not all ODBC drivers support bulk operations, the following is a list of some tested backends: ODBC Driver Bulk Read Bulk Insert MS SQL Server 2005 YES YES MS Access 2003 YES NO PostgresQL 8.1 YES YES MySQL 4.1 NO NO Transactions Transactions are also fully supported by the ODBC backend, provided that they are supported by the underlying database. BLOB Data Type Not currently supported. RowID Data Type Not currently supported. Nested Statements Not currently supported. Stored Procedures Not currently supported. Native API Access SOCI provides access to underlying datbabase APIs via several getBackEnd() functions, as described in the beyond SOCI documentation. The ODBC backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend* session::get_backend() odbc_session_backend statement_backend* statement::get_backend() odbc_statement_backend rowid_backend* rowid::get_backend() odbc_rowid_backend Backend-specific extensions odbc_soci_error The ODBC backend can throw instances of class odbc_soci_error , which is publicly derived from soci_error and has additional public members containing the ODBC error code, the Native database error code, and the message returned from ODBC: int main() { try { // regular code } catch (soci::odbc_soci_error const&amp; e) { cerr << \"ODBC Error Code: \" << e.odbc_error_code() << endl << \"Native Error Code: \" << e.native_error_code() << endl << \"SOCI Message: \" << e.what() << std::endl << \"ODBC Message: \" << e.odbc_error_message() << endl; } catch (exception const &amp;e) { cerr << \"Some other error: \" << e.what() << endl; } } get_connection_string() The odbc_session_backend class provides std::string get_connection_string() const method that returns fully expanded connection string as returned by the SQLDriverConnect function. Configuration options This backend supports odbc_option_driver_complete option which can be passed to it via connection_parameters class. The value of this option is passed to SQLDriverConnect() function as \"driver completion\" parameter and so must be one of SQL_DRIVER_XXX values, in the string form. The default value of this option is SQL_DRIVER_PROMPT meaning that the driver will query the user for the user name and/or the password if they are not stored together with the connection. If this is undesirable for some reason, you can use SQL_DRIVER_NOPROMPT value for this option to suppress showing the message box: connection_parameters parameters(\"odbc\", \"DSN=mydb\"); parameters.set_option(odbc_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters);","title":"ODBC"},{"location":"backends/odbc/#odbc-backend-reference","text":"SOCI backend for accessing variety of databases via ODBC API.","title":"ODBC Backend Reference"},{"location":"backends/odbc/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/odbc/#supported-versions","text":"The SOCI ODBC backend is supported for use with ODBC 3.","title":"Supported Versions"},{"location":"backends/odbc/#tested-platforms","text":"ODBC OS Compiler 3 Linux (Ubuntu 12.04) g++ 4.6.3 3 Linux (Ubuntu 12.04) clang 3.2 3.8 Windows 8 Visual Studio 2012 3 Windows 7 Visual Studio 2010 3 Windows XP Visual Studio 2005 (express) 3 Windows XP Visual C++ 8.0 Professional 3 Windows XP g++ 3.3.4 (Cygwin) 3 (unixodbc 2.3.6) macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/odbc/#required-client-libraries","text":"The SOCI ODBC backend requires the ODBC client library.","title":"Required Client Libraries"},{"location":"backends/odbc/#connecting-to-the-database","text":"To establish a connection to the ODBC database, create a Session object using the ODBC backend factory together with a connection string: backend_factory const&amp; backEnd = odbc; session sql(backEnd, \"filedsn=c:\\\\my.dsn\"); or simply: session sql(odbc, \"filedsn=c:\\\\my.dsn\"); The set of parameters used in the connection string for ODBC is the same as accepted by the SQLDriverConnect function from the ODBC library. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/odbc/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/odbc/#dynamic-binding","text":"The ODBC backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the ODBC backend, this type mapping is: ODBC Data Type SOCI Data Type row::get<T> specializations SQL_DOUBLE, SQL_DECIMAL, SQL_REAL, SQL_FLOAT, SQL_NUMERIC dt_double double SQL_TINYINT, SQL_SMALLINT, SQL_INTEGER, SQL_BIGINT dt_integer int SQL_CHAR, SQL_VARCHAR dt_string std::string SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP dt_date std::tm Not all ODBC drivers support all datatypes. (See the dynamic resultset binding documentation for general information on using the row class.)","title":"Dynamic Binding"},{"location":"backends/odbc/#binding-by-name","text":"In addition to binding by position , the ODBC backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") Apart from the portable \"colon-name\" syntax above, which is achieved by rewriting the query string, the backend also supports the ODBC ? syntax: int i = 7; int j = 8; sql << \"insert into t(x, y) values(?, ?)\", use(i), use(j);","title":"Binding by Name"},{"location":"backends/odbc/#bulk-operations","text":"The ODBC backend has support for SOCI's bulk operations interface. Not all ODBC drivers support bulk operations, the following is a list of some tested backends: ODBC Driver Bulk Read Bulk Insert MS SQL Server 2005 YES YES MS Access 2003 YES NO PostgresQL 8.1 YES YES MySQL 4.1 NO NO","title":"Bulk Operations"},{"location":"backends/odbc/#transactions","text":"Transactions are also fully supported by the ODBC backend, provided that they are supported by the underlying database.","title":"Transactions"},{"location":"backends/odbc/#blob-data-type","text":"Not currently supported.","title":"BLOB Data Type"},{"location":"backends/odbc/#rowid-data-type","text":"Not currently supported.","title":"RowID Data Type"},{"location":"backends/odbc/#nested-statements","text":"Not currently supported.","title":"Nested Statements"},{"location":"backends/odbc/#stored-procedures","text":"Not currently supported.","title":"Stored Procedures"},{"location":"backends/odbc/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several getBackEnd() functions, as described in the beyond SOCI documentation. The ODBC backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend* session::get_backend() odbc_session_backend statement_backend* statement::get_backend() odbc_statement_backend rowid_backend* rowid::get_backend() odbc_rowid_backend","title":"Native API Access"},{"location":"backends/odbc/#backend-specific-extensions","text":"","title":"Backend-specific extensions"},{"location":"backends/odbc/#odbc_soci_error","text":"The ODBC backend can throw instances of class odbc_soci_error , which is publicly derived from soci_error and has additional public members containing the ODBC error code, the Native database error code, and the message returned from ODBC: int main() { try { // regular code } catch (soci::odbc_soci_error const&amp; e) { cerr << \"ODBC Error Code: \" << e.odbc_error_code() << endl << \"Native Error Code: \" << e.native_error_code() << endl << \"SOCI Message: \" << e.what() << std::endl << \"ODBC Message: \" << e.odbc_error_message() << endl; } catch (exception const &amp;e) { cerr << \"Some other error: \" << e.what() << endl; } }","title":"odbc_soci_error"},{"location":"backends/odbc/#get_connection_string","text":"The odbc_session_backend class provides std::string get_connection_string() const method that returns fully expanded connection string as returned by the SQLDriverConnect function.","title":"get_connection_string()"},{"location":"backends/odbc/#configuration-options","text":"This backend supports odbc_option_driver_complete option which can be passed to it via connection_parameters class. The value of this option is passed to SQLDriverConnect() function as \"driver completion\" parameter and so must be one of SQL_DRIVER_XXX values, in the string form. The default value of this option is SQL_DRIVER_PROMPT meaning that the driver will query the user for the user name and/or the password if they are not stored together with the connection. If this is undesirable for some reason, you can use SQL_DRIVER_NOPROMPT value for this option to suppress showing the message box: connection_parameters parameters(\"odbc\", \"DSN=mydb\"); parameters.set_option(odbc_option_driver_complete, \"0\" /* SQL_DRIVER_NOPROMPT */); session sql(parameters);","title":"Configuration options"},{"location":"backends/oracle/","text":"Oracle Backend Reference SOCI backend for accessing Oracle database. Prerequisites Supported Versions The SOCI Oracle backend is currently supported for use with Oracle 10 or later. Older versions of Oracle may work as well, but they have not been tested by the SOCI team. Tested Platforms Oracle OS Compiler 10.2.0 (XE) RedHat 5 g++ 4.3 11.2.0 (XE) Ubuntu 12.04 g++ 4.6.3 12.2.0.1 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI Oracle backend requires Oracle's libclntsh client library. Depending on the particular system, the libnnz10 library might be needed as well. Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_oracle -ldl -lclntsh -lnnz10 Connecting to the Database To establish a connection to an Oracle database, create a session object using the oracle backend factory together with a connection string: session sql(oracle, \"service=orcl user=scott password=tiger\"); // or: session sql(\"oracle\", \"service=orcl user=scott password=tiger\"); // or: session sql(\"oracle://service=orcl user=scott password=tiger\"); // or: session sql(oracle, \"service=//your_host:1521/your_sid user=scott password=tiger\"); The set of parameters used in the connection string for Oracle is: service user password mode (optional; valid values are sysdba , sysoper and default ) charset and ncharset (optional; valid values are utf8 , utf16 , we8mswin1252 and win1252 ) If both user and password are provided, the session will authenticate using the database credentials, whereas if none of them is set, then external Oracle credentials will be used - this allows integration with so called Oracle wallet authentication. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from user_tables\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The Oracle backend supports the use of the SOCI row class, which facilitates retrieval of data which type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the Oracle backend, this type mapping is: Oracle Data Type SOCI Data Type row::get<T> specializations number (where scale > 0) dt_double double number(where scale = 0 and precision \u2264 std::numeric_limits<int>::digits10 ) dt_integer int number dt_long_long long long char, varchar, varchar2 dt_string std::string date dt_date std::tm (See the dynamic resultset binding documentation for general information on using the row class.) Binding by Name In addition to binding by position , the Oracle backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") SOCI's use of ':' to indicate a value to be bound within a SQL string is consistent with the underlying Oracle client library syntax. Bulk Operations The Oracle backend has full support for SOCI's bulk operations interface. Transactions Transactions are also fully supported by the Oracle backend, although transactions with non-default isolation levels have to be managed by explicit SQL statements. blob Data Type The Oracle backend supports working with data stored in columns of type Blob, via SOCI's blob class. rowid Data Type Oracle rowid's are accessible via SOCI's rowid class. Nested Statements The Oracle backend supports selecting into objects of type statement , so that you may work with nested sql statements and PL/SQL cursors: statement stInner(sql); statement stOuter = (sql.prepare << \"select cursor(select name from person order by id)\" \" from person where id = 1\", into(stInner)); stInner.exchange(into(name)); stOuter.execute(); stOuter.fetch(); while (stInner.fetch()) { std::cout << name << '\\n'; } Stored Procedures Oracle stored procedures can be executed by using SOCI's procedure class. Native API Access SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The Oracle backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() oracle_session_backend statement_backend * statement::get_backend() oracle_statement_backend blob_backend * blob::get_backend() oracle_blob_backend rowid_backend * rowid::get_backend() oracle_rowid_backend Backend-specific extensions oracle_soci_error The Oracle backend can throw instances of class oracle_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the Oracle error code: int main() { try { // regular code } catch (oracle_soci_error const & e) { cerr << \"Oracle error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (exception const & e) { cerr << \"Some other error: \"<< e.what() << endl; } }","title":"Oracle"},{"location":"backends/oracle/#oracle-backend-reference","text":"SOCI backend for accessing Oracle database.","title":"Oracle Backend Reference"},{"location":"backends/oracle/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/oracle/#supported-versions","text":"The SOCI Oracle backend is currently supported for use with Oracle 10 or later. Older versions of Oracle may work as well, but they have not been tested by the SOCI team.","title":"Supported Versions"},{"location":"backends/oracle/#tested-platforms","text":"Oracle OS Compiler 10.2.0 (XE) RedHat 5 g++ 4.3 11.2.0 (XE) Ubuntu 12.04 g++ 4.6.3 12.2.0.1 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/oracle/#required-client-libraries","text":"The SOCI Oracle backend requires Oracle's libclntsh client library. Depending on the particular system, the libnnz10 library might be needed as well. Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_oracle -ldl -lclntsh -lnnz10","title":"Required Client Libraries"},{"location":"backends/oracle/#connecting-to-the-database","text":"To establish a connection to an Oracle database, create a session object using the oracle backend factory together with a connection string: session sql(oracle, \"service=orcl user=scott password=tiger\"); // or: session sql(\"oracle\", \"service=orcl user=scott password=tiger\"); // or: session sql(\"oracle://service=orcl user=scott password=tiger\"); // or: session sql(oracle, \"service=//your_host:1521/your_sid user=scott password=tiger\"); The set of parameters used in the connection string for Oracle is: service user password mode (optional; valid values are sysdba , sysoper and default ) charset and ncharset (optional; valid values are utf8 , utf16 , we8mswin1252 and win1252 ) If both user and password are provided, the session will authenticate using the database credentials, whereas if none of them is set, then external Oracle credentials will be used - this allows integration with so called Oracle wallet authentication. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from user_tables\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/oracle/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/oracle/#dynamic-binding","text":"The Oracle backend supports the use of the SOCI row class, which facilitates retrieval of data which type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the Oracle backend, this type mapping is: Oracle Data Type SOCI Data Type row::get<T> specializations number (where scale > 0) dt_double double number(where scale = 0 and precision \u2264 std::numeric_limits<int>::digits10 ) dt_integer int number dt_long_long long long char, varchar, varchar2 dt_string std::string date dt_date std::tm (See the dynamic resultset binding documentation for general information on using the row class.)","title":"Dynamic Binding"},{"location":"backends/oracle/#binding-by-name","text":"In addition to binding by position , the Oracle backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") SOCI's use of ':' to indicate a value to be bound within a SQL string is consistent with the underlying Oracle client library syntax.","title":"Binding by Name"},{"location":"backends/oracle/#bulk-operations","text":"The Oracle backend has full support for SOCI's bulk operations interface.","title":"Bulk Operations"},{"location":"backends/oracle/#transactions","text":"Transactions are also fully supported by the Oracle backend, although transactions with non-default isolation levels have to be managed by explicit SQL statements.","title":"Transactions"},{"location":"backends/oracle/#blob-data-type","text":"The Oracle backend supports working with data stored in columns of type Blob, via SOCI's blob class.","title":"blob Data Type"},{"location":"backends/oracle/#rowid-data-type","text":"Oracle rowid's are accessible via SOCI's rowid class.","title":"rowid Data Type"},{"location":"backends/oracle/#nested-statements","text":"The Oracle backend supports selecting into objects of type statement , so that you may work with nested sql statements and PL/SQL cursors: statement stInner(sql); statement stOuter = (sql.prepare << \"select cursor(select name from person order by id)\" \" from person where id = 1\", into(stInner)); stInner.exchange(into(name)); stOuter.execute(); stOuter.fetch(); while (stInner.fetch()) { std::cout << name << '\\n'; }","title":"Nested Statements"},{"location":"backends/oracle/#stored-procedures","text":"Oracle stored procedures can be executed by using SOCI's procedure class.","title":"Stored Procedures"},{"location":"backends/oracle/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the Beyond SOCI documentation. The Oracle backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() oracle_session_backend statement_backend * statement::get_backend() oracle_statement_backend blob_backend * blob::get_backend() oracle_blob_backend rowid_backend * rowid::get_backend() oracle_rowid_backend","title":"Native API Access"},{"location":"backends/oracle/#backend-specific-extensions","text":"","title":"Backend-specific extensions"},{"location":"backends/oracle/#oracle_soci_error","text":"The Oracle backend can throw instances of class oracle_soci_error , which is publicly derived from soci_error and has an additional public err_num_ member containing the Oracle error code: int main() { try { // regular code } catch (oracle_soci_error const & e) { cerr << \"Oracle error: \" << e.err_num_ << \" \" << e.what() << endl; } catch (exception const & e) { cerr << \"Some other error: \"<< e.what() << endl; } }","title":"oracle_soci_error"},{"location":"backends/postgresql/","text":"PostgreSQL Backend Reference SOCI backend for accessing PostgreSQL database. Prerequisites Supported Versions The SOCI PostgreSQL backend is supported for use with PostgreSQL >= 7.3, although versions older than 8.0 will suffer from limited feature support. See below for details. Tested Platforms PostgreSQL OS Compiler 9.6 Windows Server 2016 MSVC++ 14.1 9.4 Windows Server 2012 R2 MSVC++ 14.0 9.4 Windows Server 2012 R2 MSVC++ 12.0 9.4 Windows Server 2012 R2 MSVC++ 11.0 9.4 Windows Server 2012 R2 Mingw-w64/GCC 4.8 9.3 Ubuntu 12.04 g++ 4.6.3 9.0 Mac OS X 10.6.6 g++ 4.2 8.4 FreeBSD 8.2 g++ 4.1 8.4 Debian 6 g++ 4.3 8.4 RedHat 5 g++ 4.3 10.03 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI PostgreSQL backend requires PostgreSQL's libpq client library. Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_postgresql -ldl -lpq Connecting to the Database To establish a connection to the PostgreSQL database, create a session object using the postgresql backend factory together with a connection string: session sql(postgresql, \"dbname=mydatabase\"); // or: session sql(\"postgresql\", \"dbname=mydatabase\"); // or: session sql(\"postgresql://dbname=mydatabase\"); The set of parameters used in the connection string for PostgreSQL is the same as accepted by the PQconnectdb function from the libpq library. In addition to standard PostgreSQL connection parameters, the following can be set: singlerow or singlerows For example: session sql(postgresql, \"dbname=mydatabase singlerows=true\"); If the singlerows parameter is set to true or yes , then queries will be executed in the single-row mode, which prevents the client library from loading full query result set into memory and instead fetches rows one by one, as they are requested by the statement's fetch() function. This mode can be of interest to those users who want to make their client applications more responsive (with more fine-grained operation) by avoiding potentially long blocking times when complete query results are loaded to client's memory. Note that in the single-row operation: bulk queries are not supported, and in order to fulfill the expectations of the underlying client library, the complete rowset has to be exhausted before executing further queries on the same session. Also please note that single rows mode requires PostgreSQL 9 or later, both at compile- and run-time. If you need to support earlier versions of PostgreSQL, you can define SOCI_POSTGRESQL_NOSINGLEROWMODE when building the library to disable it. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The PostgreSQL backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the PostgreSQL backend, this type mapping is: PostgreSQL Data Type SOCI Data Type row::get<T> specializations numeric, real, double dt_double double boolean, smallint, integer dt_integer int int8 dt_long_long long long oid dt_integer unsigned long char, varchar, text, cstring, bpchar dt_string std::string abstime, reltime, date, time, timestamp, timestamptz, timetz dt_date std::tm (See the dynamic resultset binding documentation for general information on using the row class.) Binding by Name In addition to binding by position , the PostgreSQL backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") Bulk Operations The PostgreSQL backend has full support for SOCI's bulk operations interface. Transactions Transactions are also fully supported by the PostgreSQL backend. blob Data Type The PostgreSQL backend supports working with data stored in columns of type Blob, via SOCI's blob class with the exception that trimming is not supported. rowid Data Type The concept of row identifier (OID in PostgreSQL) is supported via SOCI's rowid class. Nested Statements Nested statements are not supported by PostgreSQL backend. Stored Procedures PostgreSQL stored procedures can be executed by using SOCI's procedure class. Native API Access SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the beyond SOCI documentation. The PostgreSQL backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() postgresql_session_backend statement_backend * statement::get_backend() postgresql_statement_backend blob_backend * blob::get_backend() postgresql_blob_backend rowid_backend * rowid::get_backend() postgresql_rowid_backend Backend-specific extensions uuid Data Type The PostgreSQL backend supports working with data stored in columns of type UUID via simple string operations. All string representations of UUID supported by PostgreSQL are accepted on input, the backend will return the standard format of UUID on output. See the test test_uuid_column_type_support for usage examples. Configuration options To support older PostgreSQL versions, the following configuration macros are recognized: SOCI_POSTGRESQL_NOSINLGEROWMODE - disable single mode retrieving query results row-by-row. It is necessary for PostgreSQL prior to version 9.","title":"PostgreSQL"},{"location":"backends/postgresql/#postgresql-backend-reference","text":"SOCI backend for accessing PostgreSQL database.","title":"PostgreSQL Backend Reference"},{"location":"backends/postgresql/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/postgresql/#supported-versions","text":"The SOCI PostgreSQL backend is supported for use with PostgreSQL >= 7.3, although versions older than 8.0 will suffer from limited feature support. See below for details.","title":"Supported Versions"},{"location":"backends/postgresql/#tested-platforms","text":"PostgreSQL OS Compiler 9.6 Windows Server 2016 MSVC++ 14.1 9.4 Windows Server 2012 R2 MSVC++ 14.0 9.4 Windows Server 2012 R2 MSVC++ 12.0 9.4 Windows Server 2012 R2 MSVC++ 11.0 9.4 Windows Server 2012 R2 Mingw-w64/GCC 4.8 9.3 Ubuntu 12.04 g++ 4.6.3 9.0 Mac OS X 10.6.6 g++ 4.2 8.4 FreeBSD 8.2 g++ 4.1 8.4 Debian 6 g++ 4.3 8.4 RedHat 5 g++ 4.3 10.03 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/postgresql/#required-client-libraries","text":"The SOCI PostgreSQL backend requires PostgreSQL's libpq client library. Note that the SOCI library itself depends also on libdl , so the minimum set of libraries needed to compile a basic client program is: -lsoci_core -lsoci_postgresql -ldl -lpq","title":"Required Client Libraries"},{"location":"backends/postgresql/#connecting-to-the-database","text":"To establish a connection to the PostgreSQL database, create a session object using the postgresql backend factory together with a connection string: session sql(postgresql, \"dbname=mydatabase\"); // or: session sql(\"postgresql\", \"dbname=mydatabase\"); // or: session sql(\"postgresql://dbname=mydatabase\"); The set of parameters used in the connection string for PostgreSQL is the same as accepted by the PQconnectdb function from the libpq library. In addition to standard PostgreSQL connection parameters, the following can be set: singlerow or singlerows For example: session sql(postgresql, \"dbname=mydatabase singlerows=true\"); If the singlerows parameter is set to true or yes , then queries will be executed in the single-row mode, which prevents the client library from loading full query result set into memory and instead fetches rows one by one, as they are requested by the statement's fetch() function. This mode can be of interest to those users who want to make their client applications more responsive (with more fine-grained operation) by avoiding potentially long blocking times when complete query results are loaded to client's memory. Note that in the single-row operation: bulk queries are not supported, and in order to fulfill the expectations of the underlying client library, the complete rowset has to be exhausted before executing further queries on the same session. Also please note that single rows mode requires PostgreSQL 9 or later, both at compile- and run-time. If you need to support earlier versions of PostgreSQL, you can define SOCI_POSTGRESQL_NOSINGLEROWMODE when building the library to disable it. Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/postgresql/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/postgresql/#dynamic-binding","text":"The PostgreSQL backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the PostgreSQL backend, this type mapping is: PostgreSQL Data Type SOCI Data Type row::get<T> specializations numeric, real, double dt_double double boolean, smallint, integer dt_integer int int8 dt_long_long long long oid dt_integer unsigned long char, varchar, text, cstring, bpchar dt_string std::string abstime, reltime, date, time, timestamp, timestamptz, timetz dt_date std::tm (See the dynamic resultset binding documentation for general information on using the row class.)","title":"Dynamic Binding"},{"location":"backends/postgresql/#binding-by-name","text":"In addition to binding by position , the PostgreSQL backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\")","title":"Binding by Name"},{"location":"backends/postgresql/#bulk-operations","text":"The PostgreSQL backend has full support for SOCI's bulk operations interface.","title":"Bulk Operations"},{"location":"backends/postgresql/#transactions","text":"Transactions are also fully supported by the PostgreSQL backend.","title":"Transactions"},{"location":"backends/postgresql/#blob-data-type","text":"The PostgreSQL backend supports working with data stored in columns of type Blob, via SOCI's blob class with the exception that trimming is not supported.","title":"blob Data Type"},{"location":"backends/postgresql/#rowid-data-type","text":"The concept of row identifier (OID in PostgreSQL) is supported via SOCI's rowid class.","title":"rowid Data Type"},{"location":"backends/postgresql/#nested-statements","text":"Nested statements are not supported by PostgreSQL backend.","title":"Nested Statements"},{"location":"backends/postgresql/#stored-procedures","text":"PostgreSQL stored procedures can be executed by using SOCI's procedure class.","title":"Stored Procedures"},{"location":"backends/postgresql/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the beyond SOCI documentation. The PostgreSQL backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend * session::get_backend() postgresql_session_backend statement_backend * statement::get_backend() postgresql_statement_backend blob_backend * blob::get_backend() postgresql_blob_backend rowid_backend * rowid::get_backend() postgresql_rowid_backend","title":"Native API Access"},{"location":"backends/postgresql/#backend-specific-extensions","text":"","title":"Backend-specific extensions"},{"location":"backends/postgresql/#uuid-data-type","text":"The PostgreSQL backend supports working with data stored in columns of type UUID via simple string operations. All string representations of UUID supported by PostgreSQL are accepted on input, the backend will return the standard format of UUID on output. See the test test_uuid_column_type_support for usage examples.","title":"uuid Data Type"},{"location":"backends/postgresql/#configuration-options","text":"To support older PostgreSQL versions, the following configuration macros are recognized: SOCI_POSTGRESQL_NOSINLGEROWMODE - disable single mode retrieving query results row-by-row. It is necessary for PostgreSQL prior to version 9.","title":"Configuration options"},{"location":"backends/sqlite3/","text":"SQLite3 Backend Reference SOCI backend for accessing SQLite 3 database. Prerequisites Supported Versions The SOCI SQLite3 backend is supported for use with SQLite3 >= 3.1 Tested Platforms SQLite3 OS Compiler 3.12.1 Windows Server 2016 MSVC++ 14.1 3.12.1 Windows Server 2012 R2 MSVC++ 14.0 3.12.1 Windows Server 2012 R2 MSVC++ 12.0 3.12.1 Windows Server 2012 R2 MSVC++ 11.0 3.12.1 Windows Server 2012 R2 Mingw-w64/GCC 4.8 3.7.9 Ubuntu 12.04 g++ 4.6.3 3.4.0 Windows XP (cygwin) g++ 3.4.4 3.4.0 Windows XP Visual C++ 2005 Express Edition 3.3.8 Windows XP Visual C++ 2005 Professional 3.5.2 Mac OS X 10.5 g++ 4.0.1 3.3.4 Ubuntu 5.1 g++ 4.0.2 3.3.4 Windows XP (cygwin) g++ 3.3.4 3.3.4 Windows XP Visual C++ 2005 Express Edition 3.2.1 Linux i686 2.6.10-gentoo-r6 g++ 3.4.5 3.1.3 Mac OS X 10.4 g++ 4.0.1 3.24.0 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039 Required Client Libraries The SOCI SQLite3 backend requires SQLite3's libsqlite3 client library. Connecting to the Database To establish a connection to the SQLite3 database, create a Session object using the SQLite3 backend factory together with the database file name: session sql(sqlite3, \"database_filename\"); // or: session sql(\"sqlite3\", \"db=db.sqlite timeout=2 shared_cache=true\"); The set of parameters used in the connection string for SQLite is: dbname or db timeout - set sqlite busy timeout (in seconds) ( link ) synchronous - set the pragma synchronous flag ( link ) shared_cache - should be true ( link ) Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.) SOCI Feature Support Dynamic Binding The SQLite3 backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the SQLite3 backend, this type mapping is complicated by the fact the SQLite3 does not enforce [types][INTEGER_PRIMARY_KEY] and makes no attempt to validate the type names used in table creation or alteration statements. SQLite3 will return the type as a string, SOCI will recognize the following strings and match them the corresponding SOCI types: SQLite3 Data Type SOCI Data Type row::get<T> specializations float , double dt_double double int8 , bigint dt_long_long long long unsigned big int dt_unsigned_long_long unsigned long long int , boolean dt_integer int text, char* dt_string std::string date , time dt_date std::tm [INTEGER_PRIMARY_KEY] : There is one case where SQLite3 enforces type. If a column is declared as \"integer primary key\", then SQLite3 uses that as an alias to the internal ROWID column that exists for every table. Only integers are allowed in this column. (See the dynamic resultset binding documentation for general information on using the row class.) Binding by Name In addition to binding by position , the SQLite3 backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") The backend also supports the SQLite3 native numbered syntax, \"one or more literals can be replace by a parameter \"?\" or \":AAA\" or \"@AAA\" or \"$VVV\" where AAA is an alphanumeric identifier and VVV is a variable name according to the syntax rules of the TCL programming language.\" [1] : int i = 7; int j = 8; sql << \"insert into t(x, y) values(?, ?)\", use(i), use(j); Bulk Operations The SQLite3 backend has full support for SOCI's bulk operations interface. However, this support is emulated and is not native. Transactions Transactions are also fully supported by the SQLite3 backend. BLOB Data Type The SQLite3 backend supports working with data stored in columns of type Blob, via SOCI's BLOB class. Because of SQLite3 general typelessness the column does not have to be declared any particular type. RowID Data Type In SQLite3 RowID is an integer. \"Each entry in an SQLite table has a unique integer key called the \"rowid\". The rowid is always available as an undeclared column named ROWID, OID, or ROWID . If the table has a column of type INTEGER PRIMARY KEY then that column is another an alias for the rowid.\" [2] Nested Statements Nested statements are not supported by SQLite3 backend. Stored Procedures Stored procedures are not supported by SQLite3 backend Native API Access SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the beyond SOCI documentation. The SQLite3 backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend* session::get_backend() sqlie3_session_backend statement_backend* statement::get_backend() sqlite3_statement_backend rowid_backend* rowid::get_backend() sqlite3_rowid_backend Backend-specific extensions SQLite3 result code support SQLite3 result code is provided via the backend specific sqlite3_soci_error class. Catching the backend specific error yields the value of SQLite3 result code via the result() method. Configuration options None","title":"SQLite3"},{"location":"backends/sqlite3/#sqlite3-backend-reference","text":"SOCI backend for accessing SQLite 3 database.","title":"SQLite3 Backend Reference"},{"location":"backends/sqlite3/#prerequisites","text":"","title":"Prerequisites"},{"location":"backends/sqlite3/#supported-versions","text":"The SOCI SQLite3 backend is supported for use with SQLite3 >= 3.1","title":"Supported Versions"},{"location":"backends/sqlite3/#tested-platforms","text":"SQLite3 OS Compiler 3.12.1 Windows Server 2016 MSVC++ 14.1 3.12.1 Windows Server 2012 R2 MSVC++ 14.0 3.12.1 Windows Server 2012 R2 MSVC++ 12.0 3.12.1 Windows Server 2012 R2 MSVC++ 11.0 3.12.1 Windows Server 2012 R2 Mingw-w64/GCC 4.8 3.7.9 Ubuntu 12.04 g++ 4.6.3 3.4.0 Windows XP (cygwin) g++ 3.4.4 3.4.0 Windows XP Visual C++ 2005 Express Edition 3.3.8 Windows XP Visual C++ 2005 Professional 3.5.2 Mac OS X 10.5 g++ 4.0.1 3.3.4 Ubuntu 5.1 g++ 4.0.2 3.3.4 Windows XP (cygwin) g++ 3.3.4 3.3.4 Windows XP Visual C++ 2005 Express Edition 3.2.1 Linux i686 2.6.10-gentoo-r6 g++ 3.4.5 3.1.3 Mac OS X 10.4 g++ 4.0.1 3.24.0 macOS High Sierra 10.13.5 AppleClang 9.1.0.9020039","title":"Tested Platforms"},{"location":"backends/sqlite3/#required-client-libraries","text":"The SOCI SQLite3 backend requires SQLite3's libsqlite3 client library.","title":"Required Client Libraries"},{"location":"backends/sqlite3/#connecting-to-the-database","text":"To establish a connection to the SQLite3 database, create a Session object using the SQLite3 backend factory together with the database file name: session sql(sqlite3, \"database_filename\"); // or: session sql(\"sqlite3\", \"db=db.sqlite timeout=2 shared_cache=true\"); The set of parameters used in the connection string for SQLite is: dbname or db timeout - set sqlite busy timeout (in seconds) ( link ) synchronous - set the pragma synchronous flag ( link ) shared_cache - should be true ( link ) Once you have created a session object as shown above, you can use it to access the database, for example: int count; sql << \"select count(*) from invoices\", into(count); (See the connection and data binding documentation for general information on using the session class.)","title":"Connecting to the Database"},{"location":"backends/sqlite3/#soci-feature-support","text":"","title":"SOCI Feature Support"},{"location":"backends/sqlite3/#dynamic-binding","text":"The SQLite3 backend supports the use of the SOCI row class, which facilitates retrieval of data whose type is not known at compile time. When calling row::get<T>() , the type you should pass as T depends upon the underlying database type. For the SQLite3 backend, this type mapping is complicated by the fact the SQLite3 does not enforce [types][INTEGER_PRIMARY_KEY] and makes no attempt to validate the type names used in table creation or alteration statements. SQLite3 will return the type as a string, SOCI will recognize the following strings and match them the corresponding SOCI types: SQLite3 Data Type SOCI Data Type row::get<T> specializations float , double dt_double double int8 , bigint dt_long_long long long unsigned big int dt_unsigned_long_long unsigned long long int , boolean dt_integer int text, char* dt_string std::string date , time dt_date std::tm [INTEGER_PRIMARY_KEY] : There is one case where SQLite3 enforces type. If a column is declared as \"integer primary key\", then SQLite3 uses that as an alias to the internal ROWID column that exists for every table. Only integers are allowed in this column. (See the dynamic resultset binding documentation for general information on using the row class.)","title":"Dynamic Binding"},{"location":"backends/sqlite3/#binding-by-name","text":"In addition to binding by position , the SQLite3 backend supports binding by name , via an overload of the use() function: int id = 7; sql << \"select name from person where id = :id\", use(id, \"id\") The backend also supports the SQLite3 native numbered syntax, \"one or more literals can be replace by a parameter \"?\" or \":AAA\" or \"@AAA\" or \"$VVV\" where AAA is an alphanumeric identifier and VVV is a variable name according to the syntax rules of the TCL programming language.\" [1] : int i = 7; int j = 8; sql << \"insert into t(x, y) values(?, ?)\", use(i), use(j);","title":"Binding by Name"},{"location":"backends/sqlite3/#bulk-operations","text":"The SQLite3 backend has full support for SOCI's bulk operations interface. However, this support is emulated and is not native.","title":"Bulk Operations"},{"location":"backends/sqlite3/#transactions","text":"Transactions are also fully supported by the SQLite3 backend.","title":"Transactions"},{"location":"backends/sqlite3/#blob-data-type","text":"The SQLite3 backend supports working with data stored in columns of type Blob, via SOCI's BLOB class. Because of SQLite3 general typelessness the column does not have to be declared any particular type.","title":"BLOB Data Type"},{"location":"backends/sqlite3/#rowid-data-type","text":"In SQLite3 RowID is an integer. \"Each entry in an SQLite table has a unique integer key called the \"rowid\". The rowid is always available as an undeclared column named ROWID, OID, or ROWID . If the table has a column of type INTEGER PRIMARY KEY then that column is another an alias for the rowid.\" [2]","title":"RowID Data Type"},{"location":"backends/sqlite3/#nested-statements","text":"Nested statements are not supported by SQLite3 backend.","title":"Nested Statements"},{"location":"backends/sqlite3/#stored-procedures","text":"Stored procedures are not supported by SQLite3 backend","title":"Stored Procedures"},{"location":"backends/sqlite3/#native-api-access","text":"SOCI provides access to underlying datbabase APIs via several get_backend() functions, as described in the beyond SOCI documentation. The SQLite3 backend provides the following concrete classes for navite API access: Accessor Function Concrete Class session_backend* session::get_backend() sqlie3_session_backend statement_backend* statement::get_backend() sqlite3_statement_backend rowid_backend* rowid::get_backend() sqlite3_rowid_backend","title":"Native API Access"},{"location":"backends/sqlite3/#backend-specific-extensions","text":"","title":"Backend-specific extensions"},{"location":"backends/sqlite3/#sqlite3-result-code-support","text":"SQLite3 result code is provided via the backend specific sqlite3_soci_error class. Catching the backend specific error yields the value of SQLite3 result code via the result() method.","title":"SQLite3 result code support"},{"location":"backends/sqlite3/#configuration-options","text":"None","title":"Configuration options"},{"location":"languages/","text":"Language bindings Ada","title":"Language bindings"},{"location":"languages/#language-bindings","text":"Ada","title":"Language bindings"},{"location":"languages/ada/","text":"Ada Bindings Concepts Idioms API Reference Introduction SOCI-Ada is a database access library for Ada. The library itself is a wrapper for the selected functionality of the SOCI library, which is a C++ database access library recognized for its high quality and innovative interface. The SOCI-Ada library offers the following features to the Ada community: Modular design based on dynamic backend loading. Thanks to this feature, new backends implemented within the context of the main SOCI project are immediately available for Ada programmers without any additional work. A large community of C++ users can help ensure that the new backends are well tested in a variety of environments and usage scenarios. Native backends for major database servers ensure optimal performance and minimize configuration overhead and complexity that is usually associated with other database access methods. Direct support for bulk operations allow to achieve high performance with queries that operate on large data sets. Very liberal open-source license ( Boost, accepted by Open Source Initiative ) that encourages both commercial and non-commercial use. Easy to use and compact interface. Currently the following database servers are directly supported via their native interfaces: Oracle PostgreSQL MySQL Other backends exist in the SOCI Git repository and can be provided with future version of the library. Compilation In order to use SOCI-Ada, compile the C++ parts first (core and required backends). Note: SOCI header files are not needed to use SOCI-Ada, only compiled SOCI libraries (core and relevant backend) need to exist to build and use SOCI-Ada programs. The SOCI-Ada library itself is a single package named SOCI . This package can be just imported in the target project as is or pre-built to the binary form if required. In order to link the user programs the -lsoci_core -lstdc++ linker options need to be provided on the Unix/Linux platforms.","title":"Ada Bindings"},{"location":"languages/ada/#ada-bindings","text":"Concepts Idioms API Reference","title":"Ada Bindings"},{"location":"languages/ada/#introduction","text":"SOCI-Ada is a database access library for Ada. The library itself is a wrapper for the selected functionality of the SOCI library, which is a C++ database access library recognized for its high quality and innovative interface. The SOCI-Ada library offers the following features to the Ada community: Modular design based on dynamic backend loading. Thanks to this feature, new backends implemented within the context of the main SOCI project are immediately available for Ada programmers without any additional work. A large community of C++ users can help ensure that the new backends are well tested in a variety of environments and usage scenarios. Native backends for major database servers ensure optimal performance and minimize configuration overhead and complexity that is usually associated with other database access methods. Direct support for bulk operations allow to achieve high performance with queries that operate on large data sets. Very liberal open-source license ( Boost, accepted by Open Source Initiative ) that encourages both commercial and non-commercial use. Easy to use and compact interface. Currently the following database servers are directly supported via their native interfaces: Oracle PostgreSQL MySQL Other backends exist in the SOCI Git repository and can be provided with future version of the library.","title":"Introduction"},{"location":"languages/ada/#compilation","text":"In order to use SOCI-Ada, compile the C++ parts first (core and required backends). Note: SOCI header files are not needed to use SOCI-Ada, only compiled SOCI libraries (core and relevant backend) need to exist to build and use SOCI-Ada programs. The SOCI-Ada library itself is a single package named SOCI . This package can be just imported in the target project as is or pre-built to the binary form if required. In order to link the user programs the -lsoci_core -lstdc++ linker options need to be provided on the Unix/Linux platforms.","title":"Compilation"},{"location":"languages/ada/concepts/","text":"Ada Concepts The SOCI-Ada library borrows its concepts and naming from the main SOCI project. They are shortly explained here in the bottom-up fashion. One of the main properties of the library is that the data objects which are bound for transfer to and from the database server are managed by the library itself and are not directly visible from the user code. This ensures that no aliasing of objects occurs between Ada and underlying C++ code, which makes the inter-language interface easier and more resilient to the differences in how compilers handle the linkage. As a direct result of this design choice, users of SOCI-Ada need to instruct the library to internally create all objects that will be subject to data transfer. There are two kinds of objects that can be managed by the SOCI-Ada library: Into elements , which are data objects that are transferred from the database to the user program as a result of executing a query. There are single into elements for binding single rows of results and vector into elements for binding whole bunches of data corresponding to whole result sets or their subranges. The into elements are identified by their position . Use elements , which are data objects that are transferred from the user program to the database as parameters of the query (and, if supported by the target database, that can be modified by the database server and transferred back to the user program). There are single use elements for binding parameters of single-row queries and vector use elements for binding whole bunches of data for transfer. The use elements are identified by their name . The user program can read the current value of into and use elements and assign new values to use elements. Elements are strongly typed and the following types are currently supported: String SOCI.DB_Integer , which is defined by the library in terms of Interfaces.C.int SOCI.DB_Long_Long_Integer , which is defined in terms of Interfaces.Integer_64 SOCI.DB_Long_Float , which is defined in terms of Interfaces.C.double Ada.Calendar.Time Both into and use elements are managed for a single statement , which can be prepared once and executed once or many times, with data transfer handled during execution or fetch phase. Statements can be managed explicitly, which is required if they are to be used repeteadly or when data transfer is needed or implicitly, which is a shorthand notation that is particularly useful with simple queries or DDL commands. All statements are handled within the context of some session , which also supports transactions . Sessions can be managed in isolation or as a group called connection pool , which helps to decouple tasking design choices from the concurrency policies at the database connection level. Sessions are leased from the pool for some time during which no other task can access them and returned back when no longer needed, where they can be acquired again by other tasks. All potential problems are signalled via exceptions that have some descriptive message attached to them.","title":"Ada Concepts"},{"location":"languages/ada/concepts/#ada-concepts","text":"The SOCI-Ada library borrows its concepts and naming from the main SOCI project. They are shortly explained here in the bottom-up fashion. One of the main properties of the library is that the data objects which are bound for transfer to and from the database server are managed by the library itself and are not directly visible from the user code. This ensures that no aliasing of objects occurs between Ada and underlying C++ code, which makes the inter-language interface easier and more resilient to the differences in how compilers handle the linkage. As a direct result of this design choice, users of SOCI-Ada need to instruct the library to internally create all objects that will be subject to data transfer. There are two kinds of objects that can be managed by the SOCI-Ada library: Into elements , which are data objects that are transferred from the database to the user program as a result of executing a query. There are single into elements for binding single rows of results and vector into elements for binding whole bunches of data corresponding to whole result sets or their subranges. The into elements are identified by their position . Use elements , which are data objects that are transferred from the user program to the database as parameters of the query (and, if supported by the target database, that can be modified by the database server and transferred back to the user program). There are single use elements for binding parameters of single-row queries and vector use elements for binding whole bunches of data for transfer. The use elements are identified by their name . The user program can read the current value of into and use elements and assign new values to use elements. Elements are strongly typed and the following types are currently supported: String SOCI.DB_Integer , which is defined by the library in terms of Interfaces.C.int SOCI.DB_Long_Long_Integer , which is defined in terms of Interfaces.Integer_64 SOCI.DB_Long_Float , which is defined in terms of Interfaces.C.double Ada.Calendar.Time Both into and use elements are managed for a single statement , which can be prepared once and executed once or many times, with data transfer handled during execution or fetch phase. Statements can be managed explicitly, which is required if they are to be used repeteadly or when data transfer is needed or implicitly, which is a shorthand notation that is particularly useful with simple queries or DDL commands. All statements are handled within the context of some session , which also supports transactions . Sessions can be managed in isolation or as a group called connection pool , which helps to decouple tasking design choices from the concurrency policies at the database connection level. Sessions are leased from the pool for some time during which no other task can access them and returned back when no longer needed, where they can be acquired again by other tasks. All potential problems are signalled via exceptions that have some descriptive message attached to them.","title":"Ada Concepts"},{"location":"languages/ada/idioms/","text":"Ada Idioms As any other library, SOCI-Ada has its set of idioms that ensure optimal work in terms of performance and resource usage. Still, the optimal use will depend on the concrete usage scenario - the places where programmer choices are needed will be described explicitly. The idioms below are provided as complete programs with the intent to make them more understandable and to give complete context of use for each idiom. The programs assume that the target database is PostgreSQL, but this can be changed by a different connection string in each place where the sessions are established. The programs use the Ada 2005 interface and some minor changes will be required to adapt them for Ada 95 compilers. Single query without data transfer This type of query is useful for DDL commands and can be executed directly on the given session, without explicit statement management. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); begin SQL.Execute (\"drop table some_table\"); end My_Program; Note: The session object is initialized by a constructor function call. An alternative would be to declare it without initialization and later use the Open operation to establish a physical connection with the database. Simple query without parameters resulting in one row of data This type of query requires only single into elements, which together with the statement have to be manipulated explicitly. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; Num_Of_Persons : SOCI.DB_Integer; begin Pos := St.Into_Integer; St.Prepare (\"select count(*) from persons\"); St.Execute (True); Num_Of_Persons := St.Get_Into_Integer (Pos); Ada.Text_IO.Put_Line (\"Number of persons: \" & SOCI.DB_Integer'Image (Num_Of_Persons)); end My_Program; Note: The into element is inspected by providing the position value that was obtained at the time if was created. No operations are defined for the position type. There can be many into elements with a single query. Simple query with parameters and without results This type of query requires only use elements. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); begin St.Use_Integer (\"increase\"); St.Set_Use_Integer (\"increase\", 1000); St.Prepare (\"update persons set salary = salary + :increase\"); St.Execute (True); end My_Program; Note: The \" :increase \" in the query is a placeholder variable. There can be many such variables and each of them needs to be filled in by respective use element. Repeated query with parameters and without results This type of query requires only use elements, but they can be set differently for each statement execution. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); begin St.Use_String (\"name\"); St.Prepare (\"insert into countries(country_name) values(:name)\"); St.Set_Use_String (\"name\", \"Poland\"); St.Execute (True); St.Set_Use_String (\"name\", \"Switzerland\"); St.Execute (True); St.Set_Use_String (\"name\", \"France\"); St.Execute (True); end My_Program; Note: Each time the query is executed, the current values of use elements are transferred to the database. Batch query with parameters and without results This type of query requires vector use elements. Compare with the previous example. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); First : SOCI.Vector_Index; use type SOCI.Vector_Index; begin St.Use_Vector_String (\"name\"); St.Use_Vectors_Resize (3); First := St.Use_Vectors_First_Index; St.Set_Use_Vector_String (\"name\", First + 0, \"Poland\"); St.Set_Use_Vector_String (\"name\", First + 1, \"Switzerland\"); St.Set_Use_Vector_String (\"name\", First + 2, \"France\"); St.Prepare (\"insert into countries(country_name) values(:name)\"); St.Execute (True); end My_Program; Note: The whole bunch of data is transferred to the database if the target database server supports it and the statement is automatically repeated otherwise. This is the preferred way to transfer many rows of data to the server when the data for all rows are known before executing the query. Note: The query can be executed many times and each time a new batch of data can be transferred to the server. The size of the batch (set by calling Use_Vectors_Resize ) can be different each time the query is executed, but cannot be larger than the size that was used the first time. The size of the batch defines a tradeoff between the amount of data being transmitted in a single step (this influences the memory used by the user program and the time of a single call) and the number of executions required to handle big data sets. The optimal size of the batch will therefore differ depending on the application, but in general tens of thousands is a reasonable limit for a batch size - the performance of the whole operation is usually not affected above this value so there is no need to imply higher memory usage at the client side. Simple query with many rows of results This type of query requires simple into elements. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; begin Pos := St.Into_String; St.Prepare (\"select country_name from countries\"); St.Execute; while St.Fetch loop Ada.Text_IO.Put_Line (St.Get_Into_String (Pos)); end loop; end My_Program; Note: The loop above executes as many times as there are rows in the result. After each row is read, the into elements contain the respective values from that row. The Execute operation is called without parameter, which is False by default, meaning that no data transfer is intended. The data is being transferred only during the Fetch operation, which returns False when no data has been retrieved and the result is exhausted. This type of query can have simple parameters which are fixed at the execution time. Batch query with many rows of results This type of query requires vector into elements. Compare with previous example. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; Batch_Size : constant := 10; begin Pos := St.Into_Vector_String; St.Into_Vectors_Resize (Batch_Size); St.Prepare (\"select country_name from countries\"); St.Execute; while St.Fetch loop for I in St.Into_Vectors_First_Index .. St.Into_Vectors_Last_Index loop Ada.Text_IO.Put_Line (St.Get_Into_Vector_String (Pos, I)); end loop; St.Into_Vectors_Resize (Batch_Size); end loop; end My_Program; Note: The loop above is nested. The outer while loop fetches consecutive batches of rows from the database with requested batch size; the returned batch can be smaller than requested (the into vector elements are downsized automatically if needed) and the intended batch size is requested again before repeating the Fetch operation. For each returned batch, the into vector elements are inspected in the inner for loop. This scheme ensures correct operation independently on the size of returned batch and is therefore a recommended idiom for efficiently returning many rows of data. There is a tradeoff between efficiency and memory usage and this tradeoff is controlled by the requested batch size. Similarly to one of the examples above, there is no benefit from using batches bigger than tens of thousands of rows. This type of query can have simple (not vectors) parameters that are fixed at execution time. Final note Follow good database usage principles and avoid constructing queries by concatenating strings computed at run-time. Thanks to a good type system Ada is much better in preventing various SQL-injection attacks than weaker languages like PHP, but there is still a potential for vulnerability or at least performance loss. As a rule of thumb, rely on use elements to parameterize your queries and to provide clean separation between data and code. This will prevent many security vulnerabilities and will allow some servers to optimize their work by reusing already cached execution plans.","title":"Ada Idioms"},{"location":"languages/ada/idioms/#ada-idioms","text":"As any other library, SOCI-Ada has its set of idioms that ensure optimal work in terms of performance and resource usage. Still, the optimal use will depend on the concrete usage scenario - the places where programmer choices are needed will be described explicitly. The idioms below are provided as complete programs with the intent to make them more understandable and to give complete context of use for each idiom. The programs assume that the target database is PostgreSQL, but this can be changed by a different connection string in each place where the sessions are established. The programs use the Ada 2005 interface and some minor changes will be required to adapt them for Ada 95 compilers.","title":"Ada Idioms"},{"location":"languages/ada/idioms/#single-query-without-data-transfer","text":"This type of query is useful for DDL commands and can be executed directly on the given session, without explicit statement management. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); begin SQL.Execute (\"drop table some_table\"); end My_Program; Note: The session object is initialized by a constructor function call. An alternative would be to declare it without initialization and later use the Open operation to establish a physical connection with the database.","title":"Single query without data transfer"},{"location":"languages/ada/idioms/#simple-query-without-parameters-resulting-in-one-row-of-data","text":"This type of query requires only single into elements, which together with the statement have to be manipulated explicitly. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; Num_Of_Persons : SOCI.DB_Integer; begin Pos := St.Into_Integer; St.Prepare (\"select count(*) from persons\"); St.Execute (True); Num_Of_Persons := St.Get_Into_Integer (Pos); Ada.Text_IO.Put_Line (\"Number of persons: \" & SOCI.DB_Integer'Image (Num_Of_Persons)); end My_Program; Note: The into element is inspected by providing the position value that was obtained at the time if was created. No operations are defined for the position type. There can be many into elements with a single query.","title":"Simple query without parameters resulting in one row of data"},{"location":"languages/ada/idioms/#simple-query-with-parameters-and-without-results","text":"This type of query requires only use elements. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); begin St.Use_Integer (\"increase\"); St.Set_Use_Integer (\"increase\", 1000); St.Prepare (\"update persons set salary = salary + :increase\"); St.Execute (True); end My_Program; Note: The \" :increase \" in the query is a placeholder variable. There can be many such variables and each of them needs to be filled in by respective use element.","title":"Simple query with parameters and without results"},{"location":"languages/ada/idioms/#repeated-query-with-parameters-and-without-results","text":"This type of query requires only use elements, but they can be set differently for each statement execution. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); begin St.Use_String (\"name\"); St.Prepare (\"insert into countries(country_name) values(:name)\"); St.Set_Use_String (\"name\", \"Poland\"); St.Execute (True); St.Set_Use_String (\"name\", \"Switzerland\"); St.Execute (True); St.Set_Use_String (\"name\", \"France\"); St.Execute (True); end My_Program; Note: Each time the query is executed, the current values of use elements are transferred to the database.","title":"Repeated query with parameters and without results"},{"location":"languages/ada/idioms/#batch-query-with-parameters-and-without-results","text":"This type of query requires vector use elements. Compare with the previous example. with SOCI; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); First : SOCI.Vector_Index; use type SOCI.Vector_Index; begin St.Use_Vector_String (\"name\"); St.Use_Vectors_Resize (3); First := St.Use_Vectors_First_Index; St.Set_Use_Vector_String (\"name\", First + 0, \"Poland\"); St.Set_Use_Vector_String (\"name\", First + 1, \"Switzerland\"); St.Set_Use_Vector_String (\"name\", First + 2, \"France\"); St.Prepare (\"insert into countries(country_name) values(:name)\"); St.Execute (True); end My_Program; Note: The whole bunch of data is transferred to the database if the target database server supports it and the statement is automatically repeated otherwise. This is the preferred way to transfer many rows of data to the server when the data for all rows are known before executing the query. Note: The query can be executed many times and each time a new batch of data can be transferred to the server. The size of the batch (set by calling Use_Vectors_Resize ) can be different each time the query is executed, but cannot be larger than the size that was used the first time. The size of the batch defines a tradeoff between the amount of data being transmitted in a single step (this influences the memory used by the user program and the time of a single call) and the number of executions required to handle big data sets. The optimal size of the batch will therefore differ depending on the application, but in general tens of thousands is a reasonable limit for a batch size - the performance of the whole operation is usually not affected above this value so there is no need to imply higher memory usage at the client side.","title":"Batch query with parameters and without results"},{"location":"languages/ada/idioms/#simple-query-with-many-rows-of-results","text":"This type of query requires simple into elements. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; begin Pos := St.Into_String; St.Prepare (\"select country_name from countries\"); St.Execute; while St.Fetch loop Ada.Text_IO.Put_Line (St.Get_Into_String (Pos)); end loop; end My_Program; Note: The loop above executes as many times as there are rows in the result. After each row is read, the into elements contain the respective values from that row. The Execute operation is called without parameter, which is False by default, meaning that no data transfer is intended. The data is being transferred only during the Fetch operation, which returns False when no data has been retrieved and the result is exhausted. This type of query can have simple parameters which are fixed at the execution time.","title":"Simple query with many rows of results"},{"location":"languages/ada/idioms/#batch-query-with-many-rows-of-results","text":"This type of query requires vector into elements. Compare with previous example. with SOCI; with Ada.Text_IO; procedure My_Program is SQL : SOCI.Session := SOCI.Make_Session (\"postgresql://dbname=my_database\"); St : SOCI.Statement := SOCI.Make_Statement (SQL); Pos : SOCI.Into_Position; Batch_Size : constant := 10; begin Pos := St.Into_Vector_String; St.Into_Vectors_Resize (Batch_Size); St.Prepare (\"select country_name from countries\"); St.Execute; while St.Fetch loop for I in St.Into_Vectors_First_Index .. St.Into_Vectors_Last_Index loop Ada.Text_IO.Put_Line (St.Get_Into_Vector_String (Pos, I)); end loop; St.Into_Vectors_Resize (Batch_Size); end loop; end My_Program; Note: The loop above is nested. The outer while loop fetches consecutive batches of rows from the database with requested batch size; the returned batch can be smaller than requested (the into vector elements are downsized automatically if needed) and the intended batch size is requested again before repeating the Fetch operation. For each returned batch, the into vector elements are inspected in the inner for loop. This scheme ensures correct operation independently on the size of returned batch and is therefore a recommended idiom for efficiently returning many rows of data. There is a tradeoff between efficiency and memory usage and this tradeoff is controlled by the requested batch size. Similarly to one of the examples above, there is no benefit from using batches bigger than tens of thousands of rows. This type of query can have simple (not vectors) parameters that are fixed at execution time.","title":"Batch query with many rows of results"},{"location":"languages/ada/idioms/#final-note","text":"Follow good database usage principles and avoid constructing queries by concatenating strings computed at run-time. Thanks to a good type system Ada is much better in preventing various SQL-injection attacks than weaker languages like PHP, but there is still a potential for vulnerability or at least performance loss. As a rule of thumb, rely on use elements to parameterize your queries and to provide clean separation between data and code. This will prevent many security vulnerabilities and will allow some servers to optimize their work by reusing already cached execution plans.","title":"Final note"},{"location":"languages/ada/reference/","text":"Ada API Reference The SOCI-Ada library is entirely implemented as a single package named SOCI . Additional child packages contain single procedures for static registration of backends - these child packages are not necessary for typical use, but can be useful to force static linking of backend code. The following describes all publicly visible elements of this package: -- -- General exception related to database and library usage. -- Database_Error : exception; Each problem related to the interaction with the database or to the incorrect usage of the library itself is signalled by raising this exception. Each occurrence of this exception has some human-readable error message that can be obtained by a call to Ada.Exceptions.Exception_Message . -- -- Session. -- type Session is tagged limited private; not overriding function Make_Session (Connection_String : in String) return Session; not overriding procedure Open (This : in out Session; Connection_String : in String); not overriding procedure Close (This : in out Session); not overriding function Is_Open (This : in Session) return Boolean; The Session object can exist in two states: \"connected\" (or \"open\") and \"disconnected\". It can be created as connected at initialization time with a call to the constructor function Make_Session or left default-initialized in the disconnected state and later changed to connected with Open (the latter option is the only that is available in the Ada 95 version of the library). Session objects can be also associated with the connection pool, see below. The Connection_String should have the form \"backendname://parameters\" , where backendname is used to construct the name of the dynamically loadable library that will be used to provide specific database services. Backends included in the current distribution of the main SOCI library are: oracle (implemented as libsoci_oracle.so or libsoci_oracle.dll ) postgresql (implemented as libsoci_postgresql.so or libsoci_postgresql.dll ) mysql (implemented as libsoci_mysql.so or libsoci_mysql.dll ) Other backends can be added to the library in the future or by the user himself, please see the documentation of the main SOCI library for details. The parameters component of the Connection_String depends on the given backend, please see the documentation of the main SOCI project for the meaning and recognized options. The web pages related to the backends above are: Oracle PostgreSQL MySQL The Open operation can be called only in the disconnected state (which changes the state of Session object to connected). The Close operation can be called in any state (provided that the session is not associated with the connection pool, see below) and after that the Session is in the disconnected state. Session objects are closed automatically as part of their finalization. If the Session object is associated with the connection pool, the finalizer detaches from the pool without closing the connection. -- Transaction management. not overriding procedure Start (This : in Session); not overriding procedure Commit (This : in Session); not overriding procedure Rollback (This : in Session); These operations handle transactions. The exact meaning of transactions and whether transactions are automatic for some kinds of statements (and which ones) depend on the target database. -- Immediate query execution. not overriding procedure Execute (This : in Session; Query : in String); This operation allows to create implicit statement, prepare it for the given Query and execute it. -- -- Connection pool management. -- type Connection_Pool (Size : Positive) is tagged limited private; not overriding procedure Open (This : in out Connection_Pool; Position : in Positive; Connection_String : in String); not overriding procedure Close (This : in out Connection_Pool; Position : in Positive); not overriding procedure Lease (This : in out Connection_Pool; S : in out Session'Class); The Connection_Pool encapsulates a fixed-size collection of sessions. Individual sessions are indexed from 1 to Size (provided as discriminant) and can be Open ed and Close d explicitly. Each connection in the pool can be created with different Connection_String , if needed. The Lease operation allows to associate a given Session object (that has to be in the disconnected state itself) with one connection from the pool. The pool guarantees that at most one task can lease a given connection from the pool. If there are no free connections in the pool, the Lease operation will block waiting until some connection is freed. The Session object that is associated with a connection from the pool automatically gives it back to pool as part of the Session 's finalizer. There is no other way to \"detach\" from the pool. Note: It is assumed that the lifetime of Connection_Pool encloses the lifetimes of all Session objects that are leased from it. There is no particular protection against it and it is possible to construct a code example with allocators that create partially overlapping Connection_Pool and Session , but this is considered obscure and not representative to the actual use scenarios. To avoid any potential problems, create Connection_Pool in the scope that encloses the scopes of leased Session s. -- -- Statement. -- type Statement (&lt;&gt;) is tagged limited private; type Data_State is (Data_Null, Data_Not_Null); type Into_Position is private; type Vector_Index is new Natural; The Statement type and supporting types. Data_State is used to indicate null values in the database sense - each value of into or use elements has a state from this type. -- Statement preparation and execution. not overriding procedure Prepare (This : in Statement; Query : in String); not overriding procedure Execute (This : in Statement; With_Data_Exchange : in Boolean := False); not overriding function Execute (This : in Statement; With_Data_Exchange : in Boolean := False) return Boolean; not overriding function Fetch (This : in Statement) return Boolean; not overriding function Got_Data (This : in Statement) return Boolean; The Prepare operation needs to be called before any other operation in the above group and it prepares the execution for the given Query . No into and use elements can be created after this operation is called. The Execute operations cause the statement to execute, which might be combined with data exchange if requested. The function version of this operation returns True if some data has been returned back from the database server. The Fetch function is used to transfer next portion of data (a single row or a whole bunch) from the database server and returns True if some data has been fetched. If this function returns False it means that no new data will be ever fetched for this statement and indicates the end-of-row condition. The Got_Data function returns True if the last execution or fetch resulted in some data being transmitted from the database server. -- -- Data items handling. -- -- Database-specific types. -- These types are most likely identical to standard Integer, -- Long_Long_Integer and Long_Float, but are defined distinctly -- to avoid interfacing problems with other compilers. type DB_Integer is new Interfaces.C.int; type DB_Long_Long_Integer is new Interfaces.Integer_64; type DB_Long_Float is new Interfaces.C.double; The data types used for interaction with the database are: String DB_Integer , defined above DB_Long_Long_Integer , defined above DB_Long_Float , defined above Ada.Calendar.Time -- Creation of single into elements. not overriding function Into_String (This : in Statement) return Into_Position; not overriding function Into_Integer (This : in Statement) return Into_Position; not overriding function Into_Long_Long_Integer (This : in Statement) return Into_Position; not overriding function Into_Long_Float (This : in Statement) return Into_Position; not overriding function Into_Time (This : in Statement) return Into_Position; These functions instruct the library to create internal simple into elements of the relevant type. They return the position of the into element, which can be later used to identify it. Note: Simple into elements cannot be created together with vector into elements for the same statement. Note: Simple into elements cannot be created together with vector into elements for the same statement. -- Inspection of single into elements. not overriding function Get_Into_State (This : in Statement; Position : in Into_Position) return Data_State; not overriding function Get_Into_String (This : in Statement; Position : in Into_Position) return String; not overriding function Get_Into_Integer (This : in Statement; Position : in Into_Position) return DB_Integer; not overriding function Get_Into_Long_Long_Integer (This : in Statement; Position : in Into_Position) return DB_Long_Long_Integer; not overriding function Get_Into_Long_Float (This : in Statement; Position : in Into_Position) return DB_Long_Float; not overriding function Get_Into_Time (This : in Statement; Position : in Into_Position) return Ada.Calendar.Time; These functions allow to inspect the state and value of the simple into element identified by its position. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element. -- Inspection of vector into elements. not overriding function Get_Into_Vectors_Size (This : in Statement) return Natural; not overriding function Into_Vectors_First_Index (This : in Statement) return Vector_Index; not overriding function Into_Vectors_Last_Index (This : in Statement) return Vector_Index; not overriding procedure Into_Vectors_Resize (This : in Statement; New_Size : in Natural); The Get_Into_Vectors_Size returns the number of entries in any of the vector into elements for the given statement. The Into_Vectors_First_Index returns the lowest index value for vector into elements (which is always 0 , even if the vectors are empty). The Into_Vectors_Last_Index returns the last index of into vectors, and raises the CONSTRAINT_ERROR exception if the vectors are empty. The Into_Vectors_Resize procedure allows to change the size of all use vectors for the given statement. not overriding function Get_Into_Vector_State (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return Data_State; not overriding function Get_Into_Vector_String (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return String; not overriding function Get_Into_Vector_Integer (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Integer; not overriding function Get_Into_Vector_Long_Long_Integer (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Long_Long_Integer; not overriding function Get_Into_Vector_Long_Float (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Long_Float; not overriding function Get_Into_Vector_Time (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return Ada.Calendar.Time; These functions allow to inspect the state and value of the vector use element identified by its position and index. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element. -- Creation of single use elements. not overriding procedure Use_String (This : in Statement; Name : in String); not overriding procedure Use_Integer (This : in Statement; Name : in String); not overriding procedure Use_Long_Long_Integer (This : in Statement; Name : in String); not overriding procedure Use_Long_Float (This : in Statement; Name : in String); not overriding procedure Use_Time (This : in Statement; Name : in String); These functions instruct the library to create internal simple use elements of the relevant type, identified by the given Name . Note: Simple use elements cannot be created together with vector use elements for the same statement. Vector use elements cannot be created together with any into elements for the same statement. -- Creation of vector use elements. not overriding procedure Use_Vector_String (This : in Statement; Name : in String); not overriding procedure Use_Vector_Integer (This : in Statement; Name : in String); not overriding procedure Use_Vector_Long_Long_Integer (This : in Statement; Name : in String); not overriding procedure Use_Vector_Long_Float (This : in Statement; Name : in String); not overriding procedure Use_Vector_Time (This : in Statement; Name : in String); These functions instruct the library to create internal vector use elements of the relevant type, identified by the given Name . Note: Simple use elements cannot be created together with vector use elements for the same statement. Vector use elements cannot be created together with any into elements for the same statement. -- Modifiers for single use elements. not overriding procedure Set_Use_State (This : in Statement; Name : in String; State : in Data_State); not overriding procedure Set_Use_String (This : in Statement; Name : in String; Value : in String); not overriding procedure Set_Use_Integer (This : in Statement; Name : in String; Value : in DB_Integer); not overriding procedure Set_Use_Long_Long_Integer (This : in Statement; Name : in String; Value : in DB_Long_Long_Integer); not overriding procedure Set_Use_Long_Float (This : in Statement; Name : in String; Value : in DB_Long_Float); not overriding procedure Set_Use_Time (This : in Statement; Name : in String; Value : in Ada.Calendar.Time); These operations allow to modify the state and value of simple use elements. Setting the value of use element automatically sets its state to Data_Not_Null . -- Modifiers for vector use elements. not overriding function Get_Use_Vectors_Size (This : in Statement) return Natural; not overriding function Use_Vectors_First_Index (This : in Statement) return Vector_Index; not overriding function Use_Vectors_Last_Index (This : in Statement) return Vector_Index; not overriding procedure Use_Vectors_Resize (This : in Statement; New_Size : in Natural); The Get_Use_Vectors_Size returns the number of entries in any of the vector use elements for the given statement. The Use_Vectors_First_Index returns the lowest index value for vector use elements (which is always 0 , even if the vectors are empty). The Use_Vectors_Last_Index returns the last index of use vectors, and raises the CONSTRAINT_ERROR exception if the vectors are empty. The Use_Vectors_Resize procedure allows to change the size of all use vectors for the given statement. not overriding procedure Set_Use_Vector_State (This : in Statement; Name : in String; Index : in Vector_Index; State : in Data_State); not overriding procedure Set_Use_Vector_String (This : in Statement; Name : in String; Index : in Vector_Index; Value : in String); not overriding procedure Set_Use_Vector_Integer (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Integer); not overriding procedure Set_Use_Vector_Long_Long_Integer (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Long_Long_Integer); not overriding procedure Set_Use_Vector_Long_Float (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Long_Float); not overriding procedure Set_Use_Vector_Time (This : in Statement; Name : in String; Index : in Vector_Index; Value : in Ada.Calendar.Time); These operations allow to modify the state and value of vector use elements. Setting the value of use element automatically sets its state to Data_Not_Null . -- Inspection of single use elements. -- -- Note: Use elements can be modified by the database if they -- are bound to out and inout parameters of stored procedures -- (although this is not supported by all database backends). -- This feature is available only for single use elements. not overriding function Get_Use_State (This : in Statement; Name : in String) return Data_State; not overriding function Get_Use_String (This : in Statement; Name : in String) return String; not overriding function Get_Use_Integer (This : in Statement; Name : in String) return DB_Integer; not overriding function Get_Use_Long_Long_Integer (This : in Statement; Name : in String) return DB_Long_Long_Integer; not overriding function Get_Use_Long_Float (This : in Statement; Name : in String) return DB_Long_Float; not overriding function Get_Use_Time (This : in Statement; Name : in String) return Ada.Calendar.Time; These functions allow to inspect the state and value of the simple use element identified by its name. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element.","title":"Ada API Reference"},{"location":"languages/ada/reference/#ada-api-reference","text":"The SOCI-Ada library is entirely implemented as a single package named SOCI . Additional child packages contain single procedures for static registration of backends - these child packages are not necessary for typical use, but can be useful to force static linking of backend code. The following describes all publicly visible elements of this package: -- -- General exception related to database and library usage. -- Database_Error : exception; Each problem related to the interaction with the database or to the incorrect usage of the library itself is signalled by raising this exception. Each occurrence of this exception has some human-readable error message that can be obtained by a call to Ada.Exceptions.Exception_Message . -- -- Session. -- type Session is tagged limited private; not overriding function Make_Session (Connection_String : in String) return Session; not overriding procedure Open (This : in out Session; Connection_String : in String); not overriding procedure Close (This : in out Session); not overriding function Is_Open (This : in Session) return Boolean; The Session object can exist in two states: \"connected\" (or \"open\") and \"disconnected\". It can be created as connected at initialization time with a call to the constructor function Make_Session or left default-initialized in the disconnected state and later changed to connected with Open (the latter option is the only that is available in the Ada 95 version of the library). Session objects can be also associated with the connection pool, see below. The Connection_String should have the form \"backendname://parameters\" , where backendname is used to construct the name of the dynamically loadable library that will be used to provide specific database services. Backends included in the current distribution of the main SOCI library are: oracle (implemented as libsoci_oracle.so or libsoci_oracle.dll ) postgresql (implemented as libsoci_postgresql.so or libsoci_postgresql.dll ) mysql (implemented as libsoci_mysql.so or libsoci_mysql.dll ) Other backends can be added to the library in the future or by the user himself, please see the documentation of the main SOCI library for details. The parameters component of the Connection_String depends on the given backend, please see the documentation of the main SOCI project for the meaning and recognized options. The web pages related to the backends above are: Oracle PostgreSQL MySQL The Open operation can be called only in the disconnected state (which changes the state of Session object to connected). The Close operation can be called in any state (provided that the session is not associated with the connection pool, see below) and after that the Session is in the disconnected state. Session objects are closed automatically as part of their finalization. If the Session object is associated with the connection pool, the finalizer detaches from the pool without closing the connection. -- Transaction management. not overriding procedure Start (This : in Session); not overriding procedure Commit (This : in Session); not overriding procedure Rollback (This : in Session); These operations handle transactions. The exact meaning of transactions and whether transactions are automatic for some kinds of statements (and which ones) depend on the target database. -- Immediate query execution. not overriding procedure Execute (This : in Session; Query : in String); This operation allows to create implicit statement, prepare it for the given Query and execute it. -- -- Connection pool management. -- type Connection_Pool (Size : Positive) is tagged limited private; not overriding procedure Open (This : in out Connection_Pool; Position : in Positive; Connection_String : in String); not overriding procedure Close (This : in out Connection_Pool; Position : in Positive); not overriding procedure Lease (This : in out Connection_Pool; S : in out Session'Class); The Connection_Pool encapsulates a fixed-size collection of sessions. Individual sessions are indexed from 1 to Size (provided as discriminant) and can be Open ed and Close d explicitly. Each connection in the pool can be created with different Connection_String , if needed. The Lease operation allows to associate a given Session object (that has to be in the disconnected state itself) with one connection from the pool. The pool guarantees that at most one task can lease a given connection from the pool. If there are no free connections in the pool, the Lease operation will block waiting until some connection is freed. The Session object that is associated with a connection from the pool automatically gives it back to pool as part of the Session 's finalizer. There is no other way to \"detach\" from the pool. Note: It is assumed that the lifetime of Connection_Pool encloses the lifetimes of all Session objects that are leased from it. There is no particular protection against it and it is possible to construct a code example with allocators that create partially overlapping Connection_Pool and Session , but this is considered obscure and not representative to the actual use scenarios. To avoid any potential problems, create Connection_Pool in the scope that encloses the scopes of leased Session s. -- -- Statement. -- type Statement (&lt;&gt;) is tagged limited private; type Data_State is (Data_Null, Data_Not_Null); type Into_Position is private; type Vector_Index is new Natural; The Statement type and supporting types. Data_State is used to indicate null values in the database sense - each value of into or use elements has a state from this type. -- Statement preparation and execution. not overriding procedure Prepare (This : in Statement; Query : in String); not overriding procedure Execute (This : in Statement; With_Data_Exchange : in Boolean := False); not overriding function Execute (This : in Statement; With_Data_Exchange : in Boolean := False) return Boolean; not overriding function Fetch (This : in Statement) return Boolean; not overriding function Got_Data (This : in Statement) return Boolean; The Prepare operation needs to be called before any other operation in the above group and it prepares the execution for the given Query . No into and use elements can be created after this operation is called. The Execute operations cause the statement to execute, which might be combined with data exchange if requested. The function version of this operation returns True if some data has been returned back from the database server. The Fetch function is used to transfer next portion of data (a single row or a whole bunch) from the database server and returns True if some data has been fetched. If this function returns False it means that no new data will be ever fetched for this statement and indicates the end-of-row condition. The Got_Data function returns True if the last execution or fetch resulted in some data being transmitted from the database server. -- -- Data items handling. -- -- Database-specific types. -- These types are most likely identical to standard Integer, -- Long_Long_Integer and Long_Float, but are defined distinctly -- to avoid interfacing problems with other compilers. type DB_Integer is new Interfaces.C.int; type DB_Long_Long_Integer is new Interfaces.Integer_64; type DB_Long_Float is new Interfaces.C.double; The data types used for interaction with the database are: String DB_Integer , defined above DB_Long_Long_Integer , defined above DB_Long_Float , defined above Ada.Calendar.Time -- Creation of single into elements. not overriding function Into_String (This : in Statement) return Into_Position; not overriding function Into_Integer (This : in Statement) return Into_Position; not overriding function Into_Long_Long_Integer (This : in Statement) return Into_Position; not overriding function Into_Long_Float (This : in Statement) return Into_Position; not overriding function Into_Time (This : in Statement) return Into_Position; These functions instruct the library to create internal simple into elements of the relevant type. They return the position of the into element, which can be later used to identify it. Note: Simple into elements cannot be created together with vector into elements for the same statement. Note: Simple into elements cannot be created together with vector into elements for the same statement. -- Inspection of single into elements. not overriding function Get_Into_State (This : in Statement; Position : in Into_Position) return Data_State; not overriding function Get_Into_String (This : in Statement; Position : in Into_Position) return String; not overriding function Get_Into_Integer (This : in Statement; Position : in Into_Position) return DB_Integer; not overriding function Get_Into_Long_Long_Integer (This : in Statement; Position : in Into_Position) return DB_Long_Long_Integer; not overriding function Get_Into_Long_Float (This : in Statement; Position : in Into_Position) return DB_Long_Float; not overriding function Get_Into_Time (This : in Statement; Position : in Into_Position) return Ada.Calendar.Time; These functions allow to inspect the state and value of the simple into element identified by its position. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element. -- Inspection of vector into elements. not overriding function Get_Into_Vectors_Size (This : in Statement) return Natural; not overriding function Into_Vectors_First_Index (This : in Statement) return Vector_Index; not overriding function Into_Vectors_Last_Index (This : in Statement) return Vector_Index; not overriding procedure Into_Vectors_Resize (This : in Statement; New_Size : in Natural); The Get_Into_Vectors_Size returns the number of entries in any of the vector into elements for the given statement. The Into_Vectors_First_Index returns the lowest index value for vector into elements (which is always 0 , even if the vectors are empty). The Into_Vectors_Last_Index returns the last index of into vectors, and raises the CONSTRAINT_ERROR exception if the vectors are empty. The Into_Vectors_Resize procedure allows to change the size of all use vectors for the given statement. not overriding function Get_Into_Vector_State (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return Data_State; not overriding function Get_Into_Vector_String (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return String; not overriding function Get_Into_Vector_Integer (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Integer; not overriding function Get_Into_Vector_Long_Long_Integer (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Long_Long_Integer; not overriding function Get_Into_Vector_Long_Float (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return DB_Long_Float; not overriding function Get_Into_Vector_Time (This : in Statement; Position : in Into_Position; Index : in Vector_Index) return Ada.Calendar.Time; These functions allow to inspect the state and value of the vector use element identified by its position and index. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element. -- Creation of single use elements. not overriding procedure Use_String (This : in Statement; Name : in String); not overriding procedure Use_Integer (This : in Statement; Name : in String); not overriding procedure Use_Long_Long_Integer (This : in Statement; Name : in String); not overriding procedure Use_Long_Float (This : in Statement; Name : in String); not overriding procedure Use_Time (This : in Statement; Name : in String); These functions instruct the library to create internal simple use elements of the relevant type, identified by the given Name . Note: Simple use elements cannot be created together with vector use elements for the same statement. Vector use elements cannot be created together with any into elements for the same statement. -- Creation of vector use elements. not overriding procedure Use_Vector_String (This : in Statement; Name : in String); not overriding procedure Use_Vector_Integer (This : in Statement; Name : in String); not overriding procedure Use_Vector_Long_Long_Integer (This : in Statement; Name : in String); not overriding procedure Use_Vector_Long_Float (This : in Statement; Name : in String); not overriding procedure Use_Vector_Time (This : in Statement; Name : in String); These functions instruct the library to create internal vector use elements of the relevant type, identified by the given Name . Note: Simple use elements cannot be created together with vector use elements for the same statement. Vector use elements cannot be created together with any into elements for the same statement. -- Modifiers for single use elements. not overriding procedure Set_Use_State (This : in Statement; Name : in String; State : in Data_State); not overriding procedure Set_Use_String (This : in Statement; Name : in String; Value : in String); not overriding procedure Set_Use_Integer (This : in Statement; Name : in String; Value : in DB_Integer); not overriding procedure Set_Use_Long_Long_Integer (This : in Statement; Name : in String; Value : in DB_Long_Long_Integer); not overriding procedure Set_Use_Long_Float (This : in Statement; Name : in String; Value : in DB_Long_Float); not overriding procedure Set_Use_Time (This : in Statement; Name : in String; Value : in Ada.Calendar.Time); These operations allow to modify the state and value of simple use elements. Setting the value of use element automatically sets its state to Data_Not_Null . -- Modifiers for vector use elements. not overriding function Get_Use_Vectors_Size (This : in Statement) return Natural; not overriding function Use_Vectors_First_Index (This : in Statement) return Vector_Index; not overriding function Use_Vectors_Last_Index (This : in Statement) return Vector_Index; not overriding procedure Use_Vectors_Resize (This : in Statement; New_Size : in Natural); The Get_Use_Vectors_Size returns the number of entries in any of the vector use elements for the given statement. The Use_Vectors_First_Index returns the lowest index value for vector use elements (which is always 0 , even if the vectors are empty). The Use_Vectors_Last_Index returns the last index of use vectors, and raises the CONSTRAINT_ERROR exception if the vectors are empty. The Use_Vectors_Resize procedure allows to change the size of all use vectors for the given statement. not overriding procedure Set_Use_Vector_State (This : in Statement; Name : in String; Index : in Vector_Index; State : in Data_State); not overriding procedure Set_Use_Vector_String (This : in Statement; Name : in String; Index : in Vector_Index; Value : in String); not overriding procedure Set_Use_Vector_Integer (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Integer); not overriding procedure Set_Use_Vector_Long_Long_Integer (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Long_Long_Integer); not overriding procedure Set_Use_Vector_Long_Float (This : in Statement; Name : in String; Index : in Vector_Index; Value : in DB_Long_Float); not overriding procedure Set_Use_Vector_Time (This : in Statement; Name : in String; Index : in Vector_Index; Value : in Ada.Calendar.Time); These operations allow to modify the state and value of vector use elements. Setting the value of use element automatically sets its state to Data_Not_Null . -- Inspection of single use elements. -- -- Note: Use elements can be modified by the database if they -- are bound to out and inout parameters of stored procedures -- (although this is not supported by all database backends). -- This feature is available only for single use elements. not overriding function Get_Use_State (This : in Statement; Name : in String) return Data_State; not overriding function Get_Use_String (This : in Statement; Name : in String) return String; not overriding function Get_Use_Integer (This : in Statement; Name : in String) return DB_Integer; not overriding function Get_Use_Long_Long_Integer (This : in Statement; Name : in String) return DB_Long_Long_Integer; not overriding function Get_Use_Long_Float (This : in Statement; Name : in String) return DB_Long_Float; not overriding function Get_Use_Time (This : in Statement; Name : in String) return Ada.Calendar.Time; These functions allow to inspect the state and value of the simple use element identified by its name. If the state of the given element is Data_Null , the data-reading functions raise exceptions for that element.","title":"Ada API Reference"}]}